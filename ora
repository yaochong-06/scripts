#!/bin/bash
#
# Copyright (c) 2018, 2028, YanKu IT GuangZhou Ltd.  All rights reserved.
# Author:   
# 2021-06-18 3.7.3 add awrsqrpt
# 2020-11-06 3.7.2 load command enhencement
# 2020-11-06 3.7.1 new command logon, calculate logon frequency using listener.log
# 2020-11-03 3.7   column width adjust
# 2020-09-17 3.6.4 merge sga_stats into sga
# 2020-09-14 3.6.3 fix bug for ddl partitioned table 
# 2020-08-19 3.6.2 add get timestamp bind value from v#SQL_BIND_CAPTURE
# 2020-08-12 3.6.1 new command highparse2, find top CPU SQL with same force_matching_signature (sql not using bind variables)  
# 2020-08-06 3.6   fix column display width in 11204
# 2020-06-01 3.5.2 fix column display width in 12.2
# 2020-06-01 3.5.1 new command dg (dg_info); old index command rename to idxinfo ; add interactive to freq commands
# 2020-05-28 3.5   review all command ; ddl support interactive; fix bugs......
# 2020-05-22 3.2.2 fix recover(display instance smon recover progress) bug 
# 2020-05-06 3.2.1 sep sql_check and sql_check_his
# 2020-05-06 3.2.0 sql_check add 2 charater: filter and hash join 
# 2020-03-24 3.1.7 modify default lock command not to display object/rowid info, use -a to display
# 2020-03-24 3.1.6 new command snap or snapshot;new commang awr_baseline
# 2020-03-23 3.1.5 fix bug for lock command :dedup for lack of inst_id condition, contributed by Albert Liang
# 2020-03-17 3.1.4 new command mon_bind ;new command pc2 (show if current phv is the best)
# 2020-03-16 3.1.3 rewrite new pc,rename pc to pc_old
# 2020-03-15 3.1.2 to support sql_patch opt_param ,fix bug
# 2020-03-13 3.1.1 session command add sql_text (running)
# 2020-02-20 3.1.0 rename cursor_share to high_version,add get single sql_id info ;  fix if sqlhc.sql file exist bug
# 2020-02-20 3.0.9 fix bug and enhencement(lock command)
# 2020-01-11 3.0.8 fix bug and enhencement 
# 2020-01-08 3.0.7 fix bug and enhencement 
# 2020-01-06 3.0.6 sql_check ; enhencement 
# 2020-01-03 3.0.5 batch_sqlhc  enhencement
# 2020-01-02 3.0.4 fix bug
# 2019-12-26 3.0.3 enhencement
# 2019-12-17 3.0.2 new command [expdash]
# 2019-12-16 3.0   ==========================add sql check=========================
# 2019-12-16 3.0.1 new command [batch_sqlhc] 
# 2019-12-16 2.0.3 add spool to log for most operation
# 2019-12-15 2.0.2 new command [highcost];rename ash to ashcnt ;rename dash to dashcnt;rename ashtop/dashtop to ashsql/dashsql
# 2019-12-14 2.0.1 adjust [sql] command ,add event info from gv_active_session_history; new command [dup_index]
# 2019-12-09 2.0   =========================add -a -s -i option====================
# 2019-12-08 1.3.0 add [table] an interactive mode : ora table <tab_name> [owner] ; add -e mode; rename index to [tabidx]; new commmand index ;
# 2019-12-07 1.2.9 add [awr] an interactive mode
# 2019-12-05 1.2.8 new command : [resize] :resize datafile to shrink tablespace(just show command,no execute)
# 2019-12-03 1.2.7 new command : [sql_baseline]
# 2019-12-01 1.2.6 new command : [col] display column info
# 2019-11-27 1.2.5 support sql_patch for 12.2+
# 2019-11-22 1.2.2 new command : tbs_frag
# 2019-11-19 1.2.1 new command : mon_unzip
# 2019-11-14 1.2.0 adjust many column display format; new command : process ,session ; change xpo and xo to my code mode;fix awr bug(12c)
# 2019-11-10 1.1.7 new command : dir
# 2019-11-10 1.1.6 new command : iostat (only for 12.1 and below version)
# 2019-11-08 1.1.5 new command : file/files
# 2019-11-05 1.1.4 new command : toparea_by_sig ; topsql_by_plan
# 2019-11-04 1.1.3 tophis command,order by cpu|read|time 3 option ;load command add db_cpu and db_time 2 column
# 2019-11-03 1.1.2 new command events: batch display awr top 5 events 
# 2019-11-01 1.1.1 highparse add sql_id column;
# 2019-10-30 1.1.0 new command : big_by_tbs ;fix sparse_table bug ;rename ashsession to ash; rename dashsession to dash;rename segment to seg
# 2019-10-23 1.0.9 adjust output display format for : load 
# 2019-10-22 1.0.8 new command : xo (xplan_awr) / xpo (xplan_cursor) (add execution order column in execution plan);sql command: column adjust
# 2019-10-17 1.0.7 new command :monsavehis (12c+ only); dpr_risk (11203+ only)
# 2019-10-14 1.0.6 new command : drop  profile|patch|baseline  <name> 
# 2019-10-09 1.0.5 fix some display issue; new command  stat
# 2019-10-04 1.0.4 new command  sparse_index , sparse_table , hintname; check command add foreign key no index 
# 2019-09-29 1.0.3 new command : load (awr load profile,in batch mode), top_seg (awr segment order by ,in batch mode)
# 2019-09-26 1.0.2 fix some column format; change top command to topash; pc command order by ratio; sql command add more table info
# 2019-09-22 1.0.1 new command :tbs_usage (fast but may not accurate), tbs_last (from snapshot,fast but may not accurate)
# 2019-09-18 1.0.0 fix few bugs

usage()
{
  echo "
  Usage: ora <command> [<arguments>] or ora [-u user/pass] <command> [<arguments>]
  e.g. : ora check     or   ora -u system/password sqlhc <sqlid1> [sqlid2] [sqlid3] 
  
    General
      -u user/pass                             use USER/PASS to log in
      [] is the default ;  <> is a must
                                          
    Commands list:                          
      - 4031                                   diagnositic ora-4031 problem
      - alert [2]day                           alert.log ORA- info in recent 2(default) days (v\$diag_alert_ext)
      - ashcnt [30]min                         active sessions count(gv_active_session_history),default recent 30min
      - ashdump  [1]min                        dump ash records into trc file,default value is 1 minutes      
      - ashevent 10 2                          ora ashevent recent [10] minutes ,[def=2] ash top n events , grp by inst_id,sample_time,events
      - ashsql \"14:15\" 20                    gv_active_session_history and dba_hist_active_sess_history ,group by sql_id and event                       
      - ashtop | topash
      - asm                                    Show asm space/free space
      - awr [bid] [eid]                        ora awr bid eid (all nodes and RAC),top 50 sql;default is last 2 snapshots interval
      - awrsq [bid] [eid] [sql_id]             ora awrsq bid eid sql_id (all nodes), display awrsqrpt html and text information
      - awrsnap | listsnap  [3]                list snapshots of recent [3] days,alias : listsnap
      - awr_baseline [bid] [eid]               create an awr baseline for given bid eid
                             
      - batch_sqlhc <bid> <eid> <r1><r2><r3> y batch sqlhc for given bid eid,y for no interactive (no need to change select sqlid)
      - batch_osstat [48]|<bid> <eid>          awr osstat in batch mode(similiar with AWR osstat),fixed 48 snaps or given bid and eid
      - batch_event  [48]|<bid> <eid>          awr top 5 event in batch mode,fixed 48 snaps or given bid and eid
      - batch_load   [48]|<bid> <eid>          awr load profile in batch mode,fixed 48 snaps or given bid and eid
      - batch_iostat [48]|<bid> <eid>          awr top 5 reads tablespace in batch mode (awr: Tablespace IO Stats) 12.1 and below      

      - bc [10]                                view contents of buffer cache(Top 10)           
      - big [20]                               top n big size objects (single or partition table/index) 
      - big_by_tbs <tbs_name> [20]             top n big size objects by tablespace name                                  
      - bind | binds <sql_id>                  display bind capture information for  specified cursor  
      
      - col <owner> <tab_name> <col_name>      column info
      - check                                  unusable indexes,etc.      
      - cputime                                cputime by day / by top
      - cursor_summary                         summarize stats about (un)pinned cursors
                                               
      - dashcnt \"yyyy/mm/dd hh24:mi\" [30]    dba_hist_active_sess_history count by sample_time from given time last for 30(def) minutes
      - dashevent \"yyyy/mm/dd hh24:mi\" 20 2  ora dashevent given starttime,last for [20] min, top 2 events,grp by inst_id,sample_time,events
      - dashsql                                same with ashsql 
      - dbtime                                 dbtime by day / by top
      - ddl  <name> [owner] [type]             DDL info : dbms_metadata.get_ddl (Case Insensitive); all interactive mode
      - degree | parallel                      degree of objects (tables and indexes) ,and running parallel processes
      - dg | dg_info                           data guard :contributed by Albert Liang
      - dir                                    show all directories info
      - drop patch|profile|baseline <name>     drop sql patch/sql profile/sql plan baseline
      - dpr_risk [100]                         simple find direct path read risk (blocks > 0.8*_small_table_threshold and exes> 100 /day )
      - dup_index <owner>
      
      - event                                  v\$session summary by event
      - event2sqlid <event_name> <bid> <eid>   dba_hist_active_sess_history
      - event_set                              list all event for alter system set events or set event=      
      - expdash \"2020/05/27 10:33:40\" 30     12.2+ only ; to default DIR ; listed in term   
                                          
      - feature                                about:db link/trigger/partition/compress/temporary/sqlpatch/profile/baseline..    
      - file | files                           list spfile/control_file/datafile/tempfile names
      - fulltext  <sql_id>                     display the entire sql_id SQL text(lob),no more than 32767(v\$.sql_text has a limit of 1000) 
      - gather <owner> <table_name>            gather table stats(cascade=>true,no_invalidate=>false)
                                               
      - histogram <owner><tab_name><col_name>  get histogram value ratio 
      - highparse  [500]                       ora highparse  <500 is default> ,top 50 only (same force_matching_signature ,diff sql_id)
      - highcost [50]                          high cost sql in gv#sql_plan
      - high_version [100]                     display information for reasons cursor not shared (single sqlid: ora sharing <sqlid>)
      - hintname <part of hint name>           get hint info from v\$sql_hint
      - hangdump                               hanganalyze 3 + systemdump 10  
      - idx2sqlid <index_name>                 show sqls use the given index name
      - idxinfo   <index_name>                 get index info      
      - index <table_name>                     get all indexes info for given table
                                               
      - job                                    show all jobs
      - kill <sid> <serial> [inst_id]          kill session immediate
      - longops                                show records in gv\$session_longops (running)
      - lock|blocker                           show blocked rows and blocked chains
      - lob                                    show top space used lob segment
      - lobfree <owner><lobname>               display free space for give securefile lob segmentname(no basicfile type) need \\$\\$      
                                               
      - mvsnap                                 view all_snapshots (mview) status                                       
      - montop [20]                            save top 20(def) sql monitor files, elapsed time desc
      - monlist [50]                           lists top n (def=50) the statements that have been monitored,sql_exec_start desc
      - monsave <sqlid> [active]|text          Spool to <sql_id>_active|text.html
      - mon_bind <sql_id>                      get sql bind values from v#sql_monitor
      - monsavehis <sqlid> [active]|text       get lastest rid sql monitor report from dba_hist_reports  
      - mon_index_create      
      - mon_unzip <12c sql mon html>           unzip 12c base64 sql monitor html to unzip_<file_name>      
                                               
      - obj  <part of obj info>[owner]         view detail info for given part of a object_name  ,need %  
      - open_cursor [100]                      top 30 ,default >100
      - outline  <profile|patch> <name>        ora outline profile|patch name,get hint set (no sql_plan_baseline)
                                               
      - params [<pattern>]                     view all parameters, even hidden ones      
      - parameter [<pattern>] [2]              parameters in his(recent 2 snap) and current
      - pc  [8]                                get plan changed in recent [def 31] days   
      - pc2 [8]                                if last_active phv is the best       
      - pga [50]                               top 50 pga_used_mem
      - pga_detail <os_pid>|-mem <size_M>      Gives details on how PGA memory is consumed by a process (given its os PID) : ora pga_detail <pid>
                                               or by the set of precesses consuming more than <size_mb> MB of PGA memory   : ora pga_detail -mem 100
      - pid  <pid>                             show detailed pid(from OS) info 
      - print_table <sql_text>                 display sql result in single column mode(note: when v\$ view used,\\is needed)
      - process <pid>                          process detail info ,in print_table mode
      - process_dump <pid> <level>
      - processes [<min_mb>]                   display process pga memory info; similiar with pga
      - purge <sql_id>                         SYS.DBMS_SHARED_POOL.PURGE
                                               
      - raw <date|varchar2|number> <value>     ora raw date raw_data_string   
      - realmon                                like oratop ; repeat exec: ora repeat 5 100 realmon
      - redo                                   redo info : generate frequence
      - recover_state|recover                  gv\$fast_start_transactions,recover progress
      - resize                                 show smallest size all datafile can shrink to
      - repeat <interval> <count|forever>      Repeat an coomand <count> time,Sleep <interval> between two calls
              <ora_command>                    E.g. ora repeat 5 100 temp
      - rman                                   rman status and RECOVERY_FILE_DEST info
                                               
      - seq                                    show sequences have bad setting (order_flag='Y' or cache_size<=20)
      - seg <object_name>                      segment info for given object       
      - session  <sid>                         session detail info ,in print_table mode,in rac ,-i maybe needed                              
      - sessions [all]|<active>                ora sessions [active](def)|all  (active:also no BACKGROUD)
      - session_event [all]|<noidle>|<px>      ora session_event | ora session_event px | ora session_event noidle
      - sh                                     Run a shell command. E.g.  ora repeat 2 5 sh 'ps -edf | grep DESC'
      - sharing <sql_id>                       print why cursors are not shared ; high_version diag      
      - sga                                    tell how much sga memory is used and dynamically used
      - snap|snapshot                          dbms_workload_repository.create_snapshot
      - sparse_index
      - sparse_table
      - sql <sqlid>                            display sql info
      - sql_baseline <sqlid> <sqlid> <PHV>     
      - sql_check
      - sql_check_his
      - sql_patch <sqlid> <hint>               ora sql_patch <sqlid> <hint>
      - sql_profile <sqlid> <sqlid> <PHV>      ora sql_profile <sqlid> <sqlid> <PHV> --->fix use given plan
      - sqlhc <sqlid1> [sqlid2] [sqlid3]...    collect sqlhc for given sqlids  
      - stats                                  show infomation about stats collection                   
      - sysmetric \"yyyy/mm/dd hh24:mi\" [30]    DBA_HIST_SYSMETRIC_HISTORY from given time last for default 30 minutes
                                               
      - table  <tab_name> [owner]              show detail info for given table
      - tabidx    <table_name>                 get table index info 
      - tbs_last                               fast show tablespace info from dba_hist_tbspc_space_usage last snapshot
      - tbs_usage                              fast get tablespace usage
      - tbs_frag                               tablespace fragment info
      - tbs                                    view all tablespace detail info 
      - tbsinc                                 display total tablespace size by day
      - temp                                   view detail usage of temp tablespace  
      - topash [5]                             top sql/session/activity in recent n(def=5)minutes
      
      - toparea                                top sql in gv\$sqlarea : 5cpu/5reads/5elap
      - toparea_by_sig cpu|time|read <topn>    v#sqlarea group by force_matching_signature,topn
      - topsql_by_plan cpu|time|read <topn>    v#sql group by phv 
      
      - tophis cpu|read|time [def max-1] [max] top sql in dba_hist_sqlstat: ora tophis <bid> <eid> (default is last snapshot)
      - tophis_byplan cpu|read|time ...
      - tophis_bysig  cpu|read|time ...
      - toppid [5]                             top command top10, LOCAL top 5(def)
      - topseg [bid] [eid]                     show awr top segment info as AWR Segments by 'logical Reads' and 'physical Reads'      
      - top_level <sql_id>                     get sub sql_id by top_level sql_id from dba_hist_active_sess_history     
      - text2sqlid <text_piece>                find sql_id for given piece of key sql text
      - tran                                   list all gv\$transaction  
      - trc                                    get trace path      
                                               
      - undo                                   show undo info
      - user | users                           list all users info
      - version                                show database version
      - xp  <sql_id>                           display_cursor for given sql_id
      - xpo <sql_id> [child_number]            xplan.display_cursor for given sql_id(add execution order column)
      - x   <sql_id>                           display_awr for given sql_id 
      - xo  <sql_id> [phv]                     xplan.display_awr for given sql_id (add execution order column)

  NOTE
  ================
    - Set environment variable DBUSER to change default connect string which  is \"/ as sysdba\"
    - Set environment variable ORA_TMP to the default temp directory (default if /tmp when not set)
"
#echo "sed -n /\"^if \[ \\\"\\\$1\"/p ora|awk '{print \$5 \"            \" \$9}'|sort"
}

##################################################################################

EXEC_NAME=`basename $0`
ORA_PROG=$0
ARGS=""
T_TRC="/tmp"

if [ "$DBUSER" = "" ]; then
  DBUSER="/ as SYSDBA"
  #DBUSER="user/password@xxx"
  #sys/oracle@localhost:1521/pdb_tiger as sysdba
fi

if [ "$ORA_TMP" = "" ]; then
  ORA_TMP="/tmp"
fi

##########################################
#very important init parameter
#filedate=`date +"%Y%m%d_%H%M%S"`
filedate=`date +"%Y%m%d"`
ECHO=""
DEFNODISP="--"
DEFDISP=""
INST="1"
#DEBUG="#"

#########################################################################
while [ 1 ]; do
  case "$1" in
    "-u")
      ARGS="$ARGS $1 $2"
      DBUSER=$2
      shift
      ;;
      
    "-e")#echo sql
      ECHO=";"
      ;;
      
    "-a") #all
      DEFNODISP=""
      ;;
      
    "-s") #simple
      DEFDISP="--"
      ;;
      
   # "-d")
   #   DEBUG=""
   #   ;;
      
    "-i")
      ARGS="$ARGS $1 $2"
      INST=$2
      shift
      ;;
    *)
      break
      ;;
  esac
  shift
done

##############################################################################
#echo "instance_number=$INST"

if [ $# -lt 1 ]; then
  usage 
  exit 1
fi

###usage ver2=`get_ver 2` / ver4=`get_ver 4`
function get_ver
{
    version=`echo "select 12345||trim(version) as ver from PRODUCT_COMPONENT_VERSION where product like 'Oracle%';" | sqlplus -s $DBUSER|grep 12345|cut -c 6-13`
    #echo $version
    echo $version|cut -c 1-$1
    #ver2=`echo $version|cut -c 1-2`
    #ver4=`echo $version|cut -c 1-4`
}

###############################################################################
##this is just a template,if you add new command ,just copy and replace with your own script:
################################################################################
if [ "$1" = "test" ]; then
#  echo "instance_number=$INST"
## if [ "$2" = "" ]; then
##   echo "ora $1 xxx"
##   exit 1
## else
##   PRED="$2"
## fi

   echo ORACLE_SID=$ORACLE_SID
   
   ver2=`get_ver 2`
   ver4=`get_ver 4`
   ver8=`get_ver 8`
   #echo $ver2 
   #echo $ver4
   #echo $ver8

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set head off

    select 'DB_version='||'$ver8' from dual;
    $ECHO
!
exit 0
fi


if [ "$1" = "batch" ]; then
ora batch_load
ora batch_osstat
ora batch_event
ora -i 2 batch_load
ora -i 2 batch_osstat
ora -i 2 batch_event
echo "over"
exit 0
fi


################################################################################
if [ "$1" = "logon" ]; then
   if [ "$2" = "" -o "$3" = "" ]; then
     echo "usage: ora logon \"03-NOV-2020 11:3\" sec  or ora logon \"03-NOV-2020 11\" min"
     exit 1
  else
    datestr=$2
  fi

   logfile=`lsnrctl status|grep "Listener Log File"|awk '{ print $4 }'|sed -e 's/alert\/log.xml/trace\/listener.log/g'`
   
   if [ "$3" = "sec" ]; then
     #by seconds
     fgrep "$datestr" $logfile | fgrep "establish" | awk '{ print $1 " " $2 }'|  sort | uniq -c
   else
     #by minutes
     fgrep "$datestr" $logfile | fgrep "establish" | awk '{ print $1 " " $2 }'| awk -F: '{ print $1 ":" $2 }' | sort | uniq -c
   fi   

exit 0
fi



################################################################################
if [ "$1" = "dg_info" -o "$1" = "dg" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

Pro DataGuard Config Info:
Pro
    set pagesize 200
    set linesize 200
    col name for a30
    col display_value for a70
select name, display_value
  from (select name, display_value
          from v\$parameter
         where name in ('log_archive_config',
                        'db_file_name_convert',
                        'log_file_name_convert',
                        'fal_client',
                        'fal_server')
            or name like 'log_archive_dest%'
            or name like 'log_archive_dest_state_1%'
         order by 1 desc
    )
 where display_value is not null AND display_value !='enable';

Pro DataGuard RunTime Apply Info:
Pro
set linesize 400
col target for a16
col dest_name for a20
select thread#,
       DB_UNIQUE_NAME,
       DEST_NAME,
       TARGET,
       DATABASE_MODE,
       error,
       RECOVERY_MODE,
       GAP_STATUS,
       APPLIED_SEQ#,
       current_scn,
       applied_scn,
       to_char((scn_to_timestamp(current_scn)), 'yyyymmdd hh24:mi:ss') current_scn_time,
       to_char((scn_to_timestamp(applied_scn)), 'yyyymmdd hh24:mi:ss') applied_scn_time,
       extract(day from(scn_to_timestamp(current_scn) -
                    scn_to_timestamp(current_scn))) * 24 * 60 +
       extract(hour from(scn_to_timestamp(current_scn) -
                    scn_to_timestamp(current_scn))) * 60 +
       extract(minute from(scn_to_timestamp(current_scn) -
                    scn_to_timestamp(applied_scn))) as DELAY_TIME_MINUTE
from 
(SELECT al.thread#,
               ads.dest_id,
               ads.DEST_NAME,
               ads.TYPE || ' ' || ad.TARGET TARGET,
               ADS.DATABASE_MODE,
               ads.STATUS,
               ads.error,
               ads.RECOVERY_MODE,
               ads.DB_UNIQUE_NAME,
               ads.DESTINATION,
               ads.GAP_STATUS,
               (SELECT sequence#
                  FROM v\$log na
                 WHERE na.thread# = al.thread#
                   and status = 'CURRENT') Current_Seq#,
               Last_Archived,
               al.APPLIED_SEQ#,
               ad.applied_scn,
               current_scn
          FROM (SELECT dest_id,
                       thread#,
                       d.current_scn,
                       MAX(sequence#) Last_Archived,
                       max(CASE
                             WHEN APPLIED = 'YES' THEN
                              sequence#
                           end) APPLIED_SEQ#
                  FROM v\$archived_log V, v\$database d
                 WHERE V.resetlogs_change# = d.RESETLOGS_CHANGE#
                 group by dest_id, thread#, d.current_scn
                ) al,
               v\$archive_dest_status ads,
               v\$archive_dest AD
         WHERE al.dest_id(+) = ads.dest_id
           AND ads.STATUS != 'INACTIVE'
           AND AD.DEST_ID = ADS.DEST_ID
           and ad.APPLIED_SCN <> 0
         ORDER BY al.thread#, ads.dest_id
);
$ECHO
!
exit 0
fi

################################################################################
if [ "$1" = "awr_baseline" ]; then

    if [ "$2" = "" -o "$3" = "" ]; then
     ora awrsnap
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot 
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
    
   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else 
    bid=$2
    eid=$3   
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    exec dbms_workload_repository.create_baseline($bid,$eid,'baseline_${bid}_${eid}');
    Pro awr baseline ${bid}_${eid} created!
    
!
exit 0
fi


################################################################################
if [ "$1" = "snap" -o "$1" = "snapshot" ]; then

   read -p "This Command will execute dbms_workload_repository.create_snapshot,cont? y/[n]:" cont
   
    if [ "${cont}" = "y" -o "${cont}" = "Y" ];then
    
    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    exec dbms_workload_repository.create_snapshot();
    Pro dbms_workload_repository.create_snapshot executed!
!
   else
      echo "command canceled"
      exit 1
    fi
exit 0
fi

################################################################################
if [ "$1" = "mon_bind" -o "$1" = "monbind" ]; then

  if [ "$2" = "" ]; then
    read -p "please input sqlid :" sqlid
    if [ -z "${sqlid}" ];then
      echo "no input,exit"
      exit 1
    fi
  else
    sqlid=$2
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    set long 9999999
    col bind_info format a80
    select xmltype(binds_xml) as bind_info, SQL_EXEC_START,round(elapsed_time/1e6) as ela_time,status,
     SQL_EXEC_ID,SQL_PLAN_HASH_VALUE 
     from gv\$sql_monitor where process_name='ora' and sql_id='$sqlid';
    $ECHO
!
exit 0
fi

################################################################################
if [ "$1" = "toppid" ]; then

  if [ "$2" = "" ]; then
    topn=5
  else
    topn=$2
  fi

    echo "show top $topn ospid detail info:"
    cnt=0
    top -u oracle  -n 1 -b -c |head -50|grep LOCAL|head -$topn|awk '{print $1}' >pids.log
    while read pid
    do
      let cnt=$cnt+1
      echo "top $cnt pid: $pid"
      ora pid $pid
    done < pids.log

exit 0
fi



################################################################################
if [ "$1" = "process_dump" ]; then
 
  if [ "$2" = "" ]; then
   
  read -p "Please input pid(v#proces.spid where v#session.paddr=v#process.addr):" pid
        if [ -z "${pid}" ];then
             echo "input error"
             exit 1
        fi
   else 
     pid=$2
  fi

  if [ "$3" = "" ]; then
   
  read -p "Please input dump level [10,256,266] (no default):" level
        if [ -z "${level}" ];then
             echo "input error"
             exit 1
        fi
   else 
     level=$3
  fi
    

sqlplus -s /NOLOG << ! | egrep -v "Statement processed|Function returned|rows selected"

      connect $DBUSER

      oradebug setospid $pid
      oradebug unlimit
      oradebug dump processstate $level
      oradebug tracefile_name
!

exit 0
fi


#####################################################################################################

if [ "$1" = "tophis_byplan" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi
      
   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id,default is [$defbid] (max-1):" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id,default is [$defeid] (max):" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi
        
       if [ ${bid} -ge ${eid} ];then
          echo "input error! begin_snap_id:$bid cannot bigger than end_snap_id:$eid"
          exit 1
       fi
       else 
        bid=$3
        eid=$4 
   fi
   
   if [ "$5" = "" ]; then
     deftopn=30
     read -p "Please input top sql count,default is[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER  
    set linesize 250 pagesize 30
    --set numwidth 20
    col inst format 9999
    col rn format 999
    col min_schema format a10 trunc
    col sqltext format a40 trunc
    col min_sql_id format a14
    col plans format 99 
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999 
    col sqls format 9999   
    col CPU_S format 9999999
    col reads_k format 9999999    
    
    spool ora_tophis_byplan_${INST}_${bid}_${eid}_${orderby}.log
    
    with sql_stat as 
    (
     select rownum as RN,v.* from 
      (select 
          INSTANCE_NUMBER as inst,
          plan_hash_value as PHV,
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000,1)  as reads_k,
          min(sql_id) as min_sql_id,
          count(distinct sql_id) as sqls,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1 
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          --count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid
             and INSTANCE_NUMBER=$INST
             and plan_hash_value>0
          group by INSTANCE_NUMBER,plan_hash_value 
          order by $orderby desc 
      ) v where rownum<=$topn
    )
    select a.*,ltrim(nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,100)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** '))) SqlText
    from sql_stat a,dba_hist_sqltext b 
    where a.min_sql_id=b.sql_id 
    order by rn;
    $ECHO
    
   --Pro Current Max snap_id is :
   --select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "instance_number=$INST"
echo "Above result:Begin snap_id=$bid , End snap_id=$eid , top $topn sql ,ordered by $orderby."
echo "usage: ora [ -i 2 ] tophis_byplan [cpu]|<read>|<time> bid eid [30]"
exit 0
fi

#####################################################################################################
# "id=:1 and type=1" vs "id=:1 and type=2" diff in  force_matching_signature
if [ "$1" = "tophis_bysig" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi
      
   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id[$defbid]:" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id[$defeid]:" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi
        
       if [ ${bid} -ge ${eid} ];then
          echo "begin_snap_id:$bid cannot bigger than end_snap_id:$eid  input error!"
          exit 1
       fi
       else 
        bid=$3
        eid=$4 
   fi
   
   if [ "$5" = "" ]; then
     deftopn=30
     read -p "Please input top sql count[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER  
    set linesize 200 pagesize 30
    --set numwidth 20
    col rn format 999
    col inst format 999
    col min_schema format a10 trunc
    col sqltext format a30 trunc
    col min_sql_id format a14
    col plans format 99 
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999
    col force_matching_signature format 999999999999999999999999 
    col sqls format 9999   
    col CPU_S format 9999999
    col reads_k format 9999999     
    
    spool ora_tophis_bysig_${INST}_${bid}_${eid}_${orderby}.log
    
    with sql_stat as 
    (
     select rownum as RN,v.* from 
      (select 
          INSTANCE_NUMBER as inst,
          force_matching_signature,
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000,1)  as reads_k,
          min(sql_id) as min_sql_id,
          count(distinct sql_id) as sqls,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1 
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          --count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid--(select max(snap_id)   from dba_hist_snapshot)
             and INSTANCE_NUMBER=$INST
             and force_matching_signature>0
          group by INSTANCE_NUMBER,force_matching_signature 
          order by $orderby desc 
      ) v where rownum<=$topn
    )
    select a.*,ltrim(nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,50)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** '))) SqlText
    from sql_stat a,dba_hist_sqltext b 
    where a.min_sql_id=b.sql_id 
    order by rn;
    $ECHO
    
    select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "instance_number=$INST"
echo "usage: ora tophis_bysig [cpu]|<read>|<time> bid eid"
echo "Get top sql ,ordered by $orderby . Begin snap_id=$bid ; End snap_id=$eid"
exit 0
fi

################################################################################
if [ "$1" = "mon_index_create" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col owner format a20
    col segment_name format a30
    col segment_type format a20
    col tablespace_name format a20
    select owner,segment_name,segment_type,round(bytes/1024/1024) size_M,tablespace_name
    from dba_segments a where segment_type='TEMPORARY';
    $ECHO
!
echo "ora repeat 10 20 mon_index_create"
exit 0

fi

################################################################################
if [ "$1" = "expdash" ]; then

   ver4=`get_ver 4`
   ver2=`get_ver 2`
   if [ "$ver4" = "12.2" -o "$ver2" = "18" -o "$ver2" = "19" ]; then 
       if [ "$2" = "" -o "$3" = "" ]; then 
         #echo "Usage: ora $1 \"`date +"%Y/%m/%d %H:%M:%S" -d "-1hour"`\" 30"
         echo "Usage: ora $1 \"`date +"%Y/%m/%d %H:%M:%S"`\" 30"
         exit 1
       fi   

    
      expdp \"/ as sysdba\" views_as_tables=sys.DBA_HIST_active_sess_history \
           query=\"where sample_time between to_date\(\'$2\',\'yyyy/mm/dd hh24:mi:ss\'\) and to_date\(\'$2\',\'yyyy/mm/dd hh24:mi:ss\'\)+$3/24\" \
           file=expdash_$filedate.dmp version=12.1
   else
     echo "only support version 12.2+,current version is $ver4"
     exit 1
   fi
   
echo "impdp fred/fred remap_schema=sys:fred"   
exit 0

fi
#"


################################################################################
if [ "$1" = "batch_sqlhc" ]; then
###no more than 30 sqls
##########if begin
   if [ "$2" = "" -o "$3" = "" ]; then
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 200
    break on startup_time
    select  instance_number,snap_id,
            to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot 
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid 
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
    
   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else 
    bid=$2
    eid=$3   
  fi
  
  echo "Your selecttion :begin snap_id is $bid and end snap_id is $eid"
################## if end

  if [ "$4" = "" -o "$5" = "" -o "$6" = "" ]; then
    echo "please select/input top cpu/read/time sql count,default 10 for every dimension,total <=30"
    defr1=10
    read -p "Please input top cpu count[$defr1]:" r1
    if [ -z "${r1}" ];then
         r1=$defr1
    fi
    
    defr2=10
    read -p "Please input top read count[$defr2]:" r2
    if [ -z "${r2}" ];then
         r2=$defr2
    fi
    
    defr3=10
    read -p "Please input top elatime count[$defr3]:" r3
    if [ -z "${r3}" ];then
         r3=$defr3
    fi
    else 
        r1=$4
        r2=$5
        r3=$6
  fi
  
   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set linesize 250 pagesize 200
    
    set trims on head on
    col r_cpu format 99999
    col r_read format 99999
    col r_elap format 99999
    col sql_id format a13
    col sqltext format a100
    spool ora_sql_detail.log
    with tmp_sum as
    (select sql_id
    ,round(sum(cpu_time_delta)/1e6) sum_cpu_s
    ,round(sum(DISK_READS_DELTA)/1e3) sum_reads_k
    ,round(sum(elapsed_time_delta)/1e6) sum_elap_s
    ,max(plan_hash_value) as max_phv
      from dba_hist_sqlstat  
      where $bid < snap_id and  
            $eid >=snap_id and
       plan_hash_value>0
       group by sql_id
    )
    select sql_id,
           max_phv,
          r1 as r_cpu,sum_cpu_s,
          r2 as R_read,sum_reads_k,
          r3 as R_elap,sum_elap_s,
          nvl(replace(replace(to_nchar(SUBSTR(sql_text,1,100)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** ')) SqlText
     from 
    (select a.*
             ,row_number() over (order by sum_cpu_S desc  ) r1
             ,row_number() over (order by sum_reads_k desc) r2 
             ,row_number() over (order by sum_elap_s desc) r3
             ,b.sql_text
      from tmp_sum a ,dba_hist_sqltext b
      where a.sql_id=b.sql_id
    ) 
    where r1<=$r1 or r2<=$r2 or r3<=$r3
    order by r1,r2,r3;
    spool off
!
    #delete 1~---- and blank line: sed -n '1,/^-------------/d;/^$/d;p'
    awk '{ print $1 }' ora_sql_detail.log|sed -n '1,/^----/d;/^$/d;p' >ora_sql_id.log
    
    if [ "$7" = "" ]; then
       read -p "please review or edit(in another terminal) ora_sql_id.log in current dir,ctrl+c or n to exit,Enter to continue:" cont
       if [ "$cont" = "n" -o "$cont" = "N" ]; then
         exit 1
       fi
    fi
    
    cnt=0
    while read sql_id
    do
     let cnt=cnt+1
     if [ $cnt -ge 30 ];then
       echo "no more than 30 sqls"
       exit 0
     fi
     lensql=`echo ${sql_id}|wc -c|tr -d " "`
     if [ "$lensql" = "14" ]; then
         sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

         connect $DBUSER
         prompt generate sqlhc for sql_id : ${sql_id}...........................................................$cnt
         @ora_sqlhc T ${sql_id}
!
    fi
    done <  ora_sql_id.log

exit 0
fi

################################################################################
if [ "$1" = "sql_check_his" ]; then
#sys.WRH$_SQL_PLAN.max(snap_id) >  dba_hist_snapshot.max(snap_id) ????
   if [ "$2" = "" -o "$3" = "" ]; then
   
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
    
   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else 
    bid=$2
    eid=$3   
  fi

   if [ "$4" = "" ]; then
     rn=50 
   else 
     rn=$4
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    spool ora_sql_check_his_$filedate.log
    --1+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro Full scan ,high cost,low cardinality(top $rn),missing index:
    col plan_oper format a30
    col OBJECT_NAME format a30
    col sql_id format a13
    col min_sql_id format a13
    
    with tmp1 as 
    (select * from 
        (
            select sql_id,plan_hash_value,object_name, operation||' '||options as plan_oper
            --,filter_predicates
            ,cost,cardinality,round(cost/cardinality) ratio
            from sys.WRH\$_SQL_PLAN where
             operation||' '||options in ('TABLE ACCESS FULL','INDEX FAST FULL SCAN',
                                         'TABLE ACCESS STORAGE FULL','TABLE ACCESS INMEMORY FULL')
            and object_owner not in ('SYS') and cost >0 and cardinality >0
            and snap_id >$bid and snap_id<=$eid
            order by ratio desc
        )where rownum<=$rn
    ), tmp2 as 
    (select SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO 
         from 
          (select a.*
                   ,row_number() over (partition by sql_id order by ratio desc) as rnum 
           from tmp1 a
           ) where rnum=1 
     )--sql_id dedup
     select min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO , count(*) as sql_cnt
     from tmp2 
     group by PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO --dedup same force_matching_signature
     order by ratio;
    $ECHO
    
    
    --2+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro High card in index,low card "index rowid"(top $rn),suboptimal index:
    with tmp1 as 
    (select sql_id,plan_hash_value, OBJECT_NAME,cardinality as index_card,lag_card as lag_card
          ,round(cardinality/lag_card) as ratio from 
        (
            select * from 
            (
                select sql_id,plan_hash_value, OBJECT_NAME,operation,options ,cardinality,id,parent_id,depth
                ,lag(operation||' '||options) over (partition by sql_id,plan_hash_value order by id) as lag_oper
                ,lag(id) over (partition by sql_id,plan_hash_value order by id) as lag_id
                --,lag(parent_id) over (partition by sql_id,plan_hash_value order by id) as lag_parent_id
                ,lag(cardinality)over (partition by sql_id,plan_hash_value order by id) as lag_card
                from sys.WRH\$_SQL_PLAN
                where cardinality is not null and object_owner<>'SYS' 
                     and snap_id >$bid and snap_id<=$eid
            )where operation||' '||options='INDEX RANGE SCAN' and lag_oper like 'TABLE ACCESS BY%INDEX ROWID%'
                and id=lag_id+1 and parent_id=lag_id
                and lag_card is not null
            order by cardinality/lag_card desc
        )where rownum<=$rn
    ),tmp2 as
    ( select SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO  
      from 
         (select a.*,row_number() over (partition by sql_id order by ratio desc) as rnum 
          from tmp1 a
          ) where rnum=1
     )
     select min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO 
            ,count(*) as sql_cnt     
     from tmp2 
     group by PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO  
     order by ratio;  
    $ECHO
    
    --3+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    $DEFNODISP Pro Filter with more than 2 suboperations
    $DEFNODISP select distinct sql_id,plan_hash_value
    $DEFNODISP from 
    $DEFNODISP (
    $DEFNODISP select sql_id,plan_hash_value,parent_id,count(*) 
    $DEFNODISP from sys.WRH\$_SQL_PLAN 
    $DEFNODISP where (sql_id,plan_hash_value,parent_id )in
    $DEFNODISP      (
    $DEFNODISP       select sql_id,plan_hash_value,id
    $DEFNODISP       from  sys.WRH\$_SQL_PLAN
    $DEFNODISP       where cardinality is not null and object_owner<>'SYS' 
    $DEFNODISP           and snap_id >$bid and snap_id<=$eid and operation='FILTER'
    $DEFNODISP       ) 
    $DEFNODISP     and OBJECT_OWNER<>'SYS' and snap_id >$bid and snap_id<=$eid
    $DEFNODISP group by sql_id,plan_hash_value,parent_id 
    $DEFNODISP having count(*)>1
    $DEFNODISP );    
    --4+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    col oper format a20
    col card format 9999999
    col username format a15 trunc
    col child format 99
    Pro hash join with little join big result in little set:
    with tmp0 as
    ( select a.*
              --,row_number() over (partition by sql_id,plan_hash_value order by cost/cardinality desc) as rn
              ,lead(cardinality) over (partition by sql_id,plan_hash_value order by id) as lead_card
        from --gv\$sql_plan a --where sql_id='8fgsm55xftv5g'
             sys.WRH\$_SQL_PLAN a where snap_id >$bid and snap_id<=$eid
    ),
    tmp1 as 
    (select object_owner,sql_id,plan_hash_value,id,operation||' '||options as oper,cost,cardinality as card,lead_card
          ,round(cost/cardinality,1) as ratio
     from 
        (
        select a.*,row_number() over (partition by sql_id,plan_hash_value order by cost/cardinality desc) as rn
        from tmp0 a 
        where operation ='HASH JOIN' and ( options not like '%ANTI%' or options is null) 
              and cardinality<1000 
        )where rn=1
    )
    select * from 
    (select a.object_owner as username,a.*,substr(b.sql_text,1,30) as sql_text
    from tmp1 a, dba_hist_sqltext b  
    where a.sql_id=b.sql_id 
    and a.object_owner not in ('SYS','DBSNMP') 
    order by ratio desc 
    )where rownum<=20;
        
    --5+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    spool off
!
echo "full nodes"
echo "Missing index or suboptimal index,from WRH\$_SQL_PLAN(with snap_id). top $rn"
exit 0
fi


################################################################################
if [ "$1" = "sql_check" ]; then

   if [ "$2" = "" ]; then
     rn=20
   else 
     rn=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col inst_id format 9999999
    spool ora_sql_check_$filedate.log
    --1+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro Full scan ,high cost,low cardinality(top $rn),missing index:
    col plan_oper format a25
    col OBJECT_NAME format a30
    col sql_id format a13
    col min_sql_id format a13
    
    with tmp1 as 
    (select * from 
        (
            select inst_id,sql_id,plan_hash_value,object_name, operation||' '||options as plan_oper
            --,filter_predicates
            ,cost,cardinality,round(cost/cardinality) ratio
            from gv\$sql_plan  
            where
             operation||' '||options in ('TABLE ACCESS FULL','INDEX FAST FULL SCAN',
                                         'TABLE ACCESS STORAGE FULL','TABLE ACCESS INMEMORY FULL')
            and object_owner not in ('SYS') and cost >0 and cardinality >0
            order by ratio desc
        )where rownum<=$rn
    ), tmp2 as 
    (select inst_id,SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO 
         from 
          (select a.*
                   ,row_number() over (partition by sql_id order by ratio desc) as rnum 
           from tmp1 a
           ) where rnum=1 
     )--sql_id dedup
     select inst_id,min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO , count(*) as sql_cnt
     from tmp2 
     group by inst_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO --dedup same force_matching_signature
     order by ratio;
    $ECHO
    
    
    --2+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro High card in index,low card "index rowid"(top $rn),suboptimal index:
    with tmp1 as 
    (select inst_id,sql_id,plan_hash_value, OBJECT_NAME,cardinality as index_card,lag_card as lag_card
          ,round(cardinality/lag_card) as ratio from 
        (
            select * from 
            (
                select inst_id,sql_id,plan_hash_value, OBJECT_NAME,operation,options ,cardinality,id,parent_id,depth
                ,lag(operation||' '||options) over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_oper
                ,lag(id) over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_id
                --,lag(parent_id) over (partition by sql_id,plan_hash_value order by id) as lag_parent_id
                ,lag(cardinality)over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_card
                from gv\$sql_plan 
                where cardinality is not null and object_owner<>'SYS' 
            )where operation||' '||options='INDEX RANGE SCAN' and lag_oper like 'TABLE ACCESS BY%INDEX ROWID%'
                and id=lag_id+1 and parent_id=lag_id
                and lag_card is not null
            order by cardinality/lag_card desc
        )where rownum<=$rn
    ),tmp2 as
    ( select inst_id,SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO  
      from 
         (select a.*,row_number() over (partition by sql_id order by ratio desc) as rnum 
          from tmp1 a
          ) where rnum=1
     )
     select inst_id,min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO 
            ,count(*) as sql_cnt     
     from tmp2 
     group by inst_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO  
     order by ratio;  
    $ECHO
    
    --3+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    $DEFNODISP Pro Filter with more than 2 suboperations
    $DEFNODISP 
    $DEFNODISP select distinct sql_id,plan_hash_value
    $DEFNODISP from 
    $DEFNODISP (
    $DEFNODISP select inst_id,sql_id,plan_hash_value,child_number,parent_id,count(*) 
    $DEFNODISP from gv\$sql_plan 
    $DEFNODISP where (inst_id,sql_id,plan_hash_value,child_number,parent_id )in
    $DEFNODISP      (select inst_id,sql_id,plan_hash_value,child_number,id
    $DEFNODISP      from gv\$sql_plan 
    $DEFNODISP      where operation='FILTER' 
    $DEFNODISP      ) 
    $DEFNODISP     and OBJECT_OWNER<>'SYS'
    $DEFNODISP group by inst_id,sql_id,plan_hash_value,child_number,parent_id 
    $DEFNODISP having count(*)>1
    $DEFNODISP ) where rownum<=$rn;  
    
    --4+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    col oper format a25
    col card format 9999999
    col username format a15 trunc
    col child format 99
    col id format 999
    
    Pro hash join with little join big result in little set:
    with tmp0 as
    ( select a.*
              --,row_number() over (partition by inst_id,sql_id,plan_hash_value order by cost/cardinality desc) as rn
              ,lead(cardinality) over (partition by inst_id,sql_id,plan_hash_value order by id) as lead_card
        from gv\$sql_plan a --where sql_id='8fgsm55xftv5g'
    ),
    tmp1 as 
    (select inst_id,sql_id,plan_hash_value,id,child_number as child,operation||' '||options as oper,cost,cardinality as card,lead_card
          ,round(cost/cardinality,1) as ratio
     from 
        (
        select a.*,row_number() over (partition by inst_id,sql_id,plan_hash_value order by cost/cardinality desc) as rn
        from tmp0 a 
        where operation ='HASH JOIN' and ( options not like '%ANTI%' or options is null) 
              and cardinality<1000
        )where rn=1
    )
    select * from 
    (select B.PARSING_SCHEMA_NAME as username,a.*--,substr(b.sql_text,1,30) as sql_text
    from tmp1 a, gv\$sqlarea b  
    where a.sql_id=b.sql_id and a.inst_id=b.inst_id
    and B.PARSING_SCHEMA_NAME not in ('SYS','DBSNMP') 
    order by ratio desc 
    )where rownum<=$rn;
        
    --5+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    
    spool off
!
echo "full nodes"
echo "Missing index or suboptimal index,from WRH\$_SQL_PLAN(with snap_id). top $rn"
exit 0
fi

################################################################################
if [ "$1" = "dup_index" ]; then

   if [ "$2" = "" ]; then
       ora user
       read -p "Please input a owner:" owner
        if [ -z "${owner}" ];then
             echo "table owner needed!"
             exit 1
        fi
   else 
     owner=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180
    col table_name format a30 
    col index_name format a30
    col index_col_lists format a30
    col dup_col_lists format a30
    col dup_index_name format a30
    spool ora_dup_index_$filedate.log
    with tmp as
    (
    select table_owner,table_name,index_name,
           listagg(column_name,chr(10)||',') within group (order by column_position) as col_lists
    from dba_ind_columns where table_owner=upper('$owner')
    group by table_owner,table_name,index_name
    )
    select table_name,index_name,index_col_lists,dup_col_lists,dup_index_name
    from 
    (select table_owner,
          table_name,index_name,col_lists as index_col_lists
         ,lag(col_lists) over (partition by table_owner,table_name order by col_lists) as dup_col_lists 
         ,lag(index_name) over (partition by table_owner,table_name order by col_lists) as dup_index_name
    from tmp a
    )where table_owner=upper('$owner') and 
           index_col_lists like dup_col_lists||chr(10)||',%';  
    $ECHO
    spool off
!
echo "get duplicate index by table owner for $owner"
exit 0
fi

################################################################################
if [ "$1" = "highcost" ]; then

   if [ "$2" = "" ]; then
     rn=50 
   else 
     rn=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col sql_id format a13
    col sql_text format a64
    spool ora_highcost_${INST}_${filedate}.log
    with tmp as
    (select rownum as rn,a.* from 
        (select inst_id,sql_id,max(cost) max_cost 
          from gv\$sql_plan 
         where id=0 and cost>=100 
               and inst_id=$INST
         group by inst_id,sql_id
         order by max_cost desc
        )a where rownum<=$rn
    )
    select a.*,b.sql_text 
    from tmp a,gv\$sqltext b
    where a.sql_id=b.sql_id 
          and b.inst_id=$INST
          and b.piece=0
          order by rn;    
    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "get top cost sql from gv_sql_plan"
exit 0
fi

################################################################################
if [ "$1" = "trc" ]; then

   ver2=`get_ver 2`

   if [ "$ver2" = "10" ]; then
      echo "$ORACLE_BASE/admin/$ORACLE_SID/bdump/"
      exit 0
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set head off
    select value from v\$diag_info where name='Diag Trace';
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "index" ]; then

  if [ "$2" = ""  ]; then
   read -p "Please input table_name:" tablename
    if [ -z "${tablename}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    tablename=$2
  fi   
   
   if [ "$3" = ""  ]; then
    
    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_tables where table_name=upper('$tablename') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    #defowner=`echo "select trim(12345||owner) as owner from dba_tables where table_name=upper('$tablename') and rownum<=1;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-30`
    if [ -z "${defowner}" ];then
       echo "table $tablename not found,please check again!"
       exit 1
    fi
   read -p "Please input table_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else 
    owner=$3   
  fi
   
#   ora print_table "select * from dba_indexes where index_name=''$2''"
   
   ver2=`get_ver 2`
   if [ $ver2 -lt 11 ];then
     ver="--"
   else
     ver=""
   fi
  
   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
  
    connect $DBUSER
  
    set pagesize 30
    set linesize 200
    col owner format a15
    col table_owner format a15
    col index_name format a30
    col index_type format a20
    col avg_lb_key format 999999999
    col avg_db_key format 999999999

    
column index_name  format a30
column column_name format a20
column func        format a30
col uni format a3
col blv format 999
col prefix format 999
col pos format 99

spool ora_indexes_of_${owner}_${tablename}.log
 
break   on index_name skip 1 
 
select
        ind.index_name,
        decode(ind.uniqueness,'NONUNIQUE','N','Y') as uni,
        $ver decode(visibility,'VISIBLE','Y','NO') as vis,
        tab.num_rows            t_rows,
        ind.num_rows            i_rows,
        ind.distinct_keys,
        ind.blevel as blv,
        ind.leaf_blocks,
        inc.column_name,
        inc.column_position as pos,
        case inc.descend  when 'DESC'  then 'D' else null end descend,
        tbc.nullable,
        tbc.num_distinct,
        tbc.num_nulls
        $DEFNODISP ,inx.column_expression   func,
        $DEFNODISP ind.prefix_length       prefix
from
        dba_tables          tab,
        dba_indexes         ind,
        dba_ind_columns     inc,
        dba_tab_cols        tbc,
        dba_ind_expressions inx
where
        tab.owner        = upper('$owner') and
        tab.table_name   = upper('$tablename')
/*                  */
and     ind.table_owner  = tab.owner
and     ind.table_name   = tab.table_name
/*                  */
and     inc.table_owner  = ind.table_owner
and     inc.table_name   = ind.table_name
and     inc.index_owner  = ind.owner
and     inc.index_name   = ind.index_name
/*                  */
and     tbc.owner        = inc.table_owner
and     tbc.table_name   = inc.table_name
and     tbc.column_name  = inc.column_name
/*                  */
and     inx.table_owner(+)     = inc.table_owner
and     inx.table_name(+)      = inc.table_name
and     inx.index_owner(+)     = inc.index_owner
and     inx.index_name(+)      = inc.index_name
and     inx.column_position(+) = inc.column_position
order by ind.index_name, inc.column_position;
$ECHO
  spool off  
!
exit 0
fi


################################################################################
if [ "$1" = "idxinfo" ]; then

   ##if [ "$2" = "" ]; then
   ##  echo "ora idxinfo idx_name"
   ##  exit 1
   ##fi
   
  if [ "$2" = ""  ]; then
   read -p "Please input index_name:" indexname
    if [ -z "${indexname}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    indexname=$2
  fi   
   
   if [ "$3" = ""  ]; then
    
    defowner=`echo "select trim(12345||LISTAGG (table_owner,',') WITHIN GROUP (ORDER BY table_owner)) AS owner from dba_indexes where index_name=upper('$indexname') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "Index $indexname not found,please check again!"
       exit 1
    fi
   read -p "Please input index_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else 
    owner=$3   
  fi
   
   
   ver2=`get_ver 2`
   if [ $ver2 -lt 11 ];then
     ver="--"
   else
     ver=""
   fi
  
   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
  
    connect $DBUSER
  
    set pagesize 30
    set linesize 200
    col owner format a15
    col table_owner format a15
    col index_name format a30
    col index_type format a21 trunc
    col avg_lb_key format 999999999
    col avg_db_key format 999999999
    col COMPRESSION format a8 trunc
    col table_name format a20 trunc
    
    select owner,table_owner,table_name,
       blevel,leaf_blocks,distinct_keys,
       avg_leaf_blocks_per_key as avg_lb_key,
       avg_data_blocks_per_key as avg_db_key,
       clustering_factor
       --num_rows,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
       --degree,partitioned,visibility
    from dba_indexes where index_name=upper('$indexname') and TABLE_OWNER=upper('$owner');
    $ECHO
    
    col degree format a6
    col tablespace_name format a10 trunc
    col LAST_ANALYZED format a19
    select tablespace_name, index_type,
       --blevel,leaf_blocks,distinct_keys,avg_leaf_blocks_per_key,
       --avg_data_blocks_per_key,clustering_factor,status,
       num_rows,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
       degree,partitioned,
       decode(uniqueness,'NONUNIQUE','N','UNIQUE') as uniq,
       $ver decode(visibility,'VISIBLE','Y','INVISIBLE') as visible,
       compression, status
    from dba_indexes where index_name=upper('$indexname') and TABLE_OWNER=upper('$owner');
    $ECHO
    
    col column_name format a30
    col column_position format 99
    col table_name format a30
    col index_owner format a30
    select index_owner,index_name,table_name,column_name, column_position as pos,descend
    from dba_ind_columns where index_name=upper('$indexname') and TABLE_OWNER=upper('$owner')
    order by index_owner,column_position;
    $ECHO
    
column index_name  format a30
column column_name format a20
column func        format a30
column pos format 99
 
break   on index_name skip 1 on uniqueness on pref_len -
        on t_rows on i_rows on distinct_keys 
        --on blevel on leaf_blocks
 
select
        --ind.index_name,
        --ind.uniqueness,
        tab.num_rows            t_rows,
        ind.num_rows            i_rows,
        ind.distinct_keys,
        --ind.blevel,
        --ind.leaf_blocks,
        inc.column_name,
        inc.column_position as pos,
        case inc.descend  when 'DESC'  then 'D' else null end descend,
        tbc.nullable,
        tbc.num_distinct,
        tbc.num_nulls,  
        ind.prefix_length       prefix,
        inx.column_expression   func
from
        dba_tables          tab,
        dba_indexes         ind,
        dba_ind_columns     inc,
        dba_tab_cols        tbc,
        dba_ind_expressions inx
where
        --tab.owner        = upper('owner') and
        ind.TABLE_OWNER  = upper('$owner') and
        ind.index_name   = upper('$indexname')
/*                  */
and     ind.table_owner  = tab.owner
and     ind.table_name   = tab.table_name
/*                  */
and     inc.table_owner  = ind.table_owner
and     inc.table_name   = ind.table_name
and     inc.index_owner  = ind.owner
and     inc.index_name   = ind.index_name
/*                  */
and     tbc.owner        = inc.table_owner
and     tbc.table_name   = inc.table_name
and     tbc.column_name  = inc.column_name
/*                  */
and     inx.table_owner(+)     = inc.table_owner
and     inx.table_name(+)      = inc.table_name
and     inx.index_owner(+)     = inc.index_owner
and     inx.index_name(+)      = inc.index_name
and     inx.column_position(+) = inc.column_position
order by ind.index_name, inc.column_position
;
$ECHO
    
!
echo "index info of $2"
exit 0
fi


################################################################################
if [ "$1" = "resize" ]; then

#################
sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

connect $DBUSER

set linesize 200 pagesize 100
col ResizeCmd format a120

select a.file#,  
         --a.name,  
         round(a.bytes / 1024 / 1024) Current_MB,  
         ceil(HWM * a.block_size / 1024 / 1024) ResizeTo,  
         round((a.bytes - HWM * a.block_size) / 1024 / 1024) Release_MB,  
         'alter database datafile ''' || a.name || ''' resize ' ||  
         ceil(HWM * a.block_size / 1024 / 1024) || 'M;' ResizeCmd  
from v\$datafile a,  
       (SELECT file_id, MAX(block_id + blocks - 1) HWM  
          FROM DBA_EXTENTS  
         GROUP BY file_id
         ) b  
where a.file# = b.file_id(+)  
And (a.bytes - HWM * a.block_size) >0  
order by Release_MB;
$ECHO
!
exit 0
fi



################################################################################
if [ "$1" = "sql_baseline" ]; then

     if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col plan_name format a30
    col signature format 99999999999999999999
    col created format a20
    col sql_handle format a20
    col description format a40 trunc
    col creator format a10 trunc
    col sql_text format a50 trunc
    col ORIGIN format a12 trunc
    select * from 
    (select plan_NAME,enabled, accepted, fixed--,signature,sql_handle
           ,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss') as created
            ,creator,origin, DESCRIPTION,SQL_TEXT 
           from dba_sql_plan_baselines order by created desc
     ) where rownum<=20;
!
    echo "ora sql_baseline sql_id_1 sql_id_2 phv"
    exit 1
  fi

  if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then
  
    echo "ora sql_baseline <ori_sqlid> <modi_sqlid> <modi_phv>"
    exit 1
  fi 
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150


--SPO coe_load_sql_baseline.log;
SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUM 20 SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;
DEF original_sql_id = '$2';
DEF modified_sql_id = '$3';
DEF plan_hash_value = '$4';
PRO
PRO Values passed to coe_load_sql_baseline:
PRO ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRO ORIGINAL_SQL_ID: "&&original_sql_id."
PRO MODIFIED_SQL_ID: "&&modified_sql_id."
PRO PLAN_HASH_VALUE: "&&plan_hash_value."
PRO
WHENEVER SQLERROR EXIT SQL.SQLCODE;
SET TERM OFF ECHO ON;

-- trim parameters
COL original_sql_id NEW_V original_sql_id FOR A30;
COL modified_sql_id NEW_V modified_sql_id FOR A30;
COL plan_hash_value NEW_V plan_hash_value FOR A30;
SELECT TRIM('&&original_sql_id.') original_sql_id, TRIM('&&modified_sql_id.') modified_sql_id, 
TRIM('&&plan_hash_value.') plan_hash_value FROM DUAL;

-- open log file
--SPO coe_load_sql_baseline_&&original_sql_id..log;
--GET coe_load_sql_baseline.log;

-- get user
COL connected_user NEW_V connected_user FOR A30;
SELECT USER connected_user FROM DUAL;

VAR sql_text CLOB;
VAR plan_name VARCHAR2(30);
EXEC :sql_text := NULL;
EXEC :plan_name := NULL;

-- get sql_text from memory
BEGIN
  SELECT REPLACE(sql_fulltext, CHR(00), ' ')
    INTO :sql_text
    FROM gv\$sqlarea
   WHERE sql_id = TRIM('&&original_sql_id.')
     AND ROWNUM = 1;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT REPLACE(sql_text, CHR(00), ' ')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&original_sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- sql_text as found
col sql_text format a100
SELECT :sql_text as sql_text FROM DUAL;

-- check is sql_text for original sql is available
SET TERM ON;
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for original SQL_ID &&original_sql_id. was not found in memory (gv\$sqlarea) or AWR (dba_hist_sqltext).');
  END IF;
END;
/

-- check phv is found
DECLARE
  l_count NUMBER;
BEGIN
  SELECT COUNT(*)
    INTO l_count
    FROM gv\$sql
   WHERE sql_id = TRIM('&&modified_sql_id.')
     AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'));

   IF l_count = 0 THEN
     RAISE_APPLICATION_ERROR(-20110, 'PHV &&plan_hash_value. for modified SQL_ID &&modified_sql_id. was not be found in memory (gv\$sql).');
   END IF;
END;
/

SET ECHO OFF;
DECLARE
  plans NUMBER;
  description VARCHAR2(500);
  sys_sql_handle VARCHAR2(30);
  sys_plan_name VARCHAR2(30);
BEGIN
  -- create sql_plan_baseline for original sql using plan from modified sql
  plans :=
  DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE (
    sql_id          => TRIM('&&modified_sql_id.'),
    plan_hash_value => TO_NUMBER(TRIM('&&plan_hash_value.')),
    sql_text        => :sql_text );
    
  DBMS_OUTPUT.PUT_LINE('Plans Loaded: '||plans);

  -- find handle and plan_name for sql_plan_baseline just created
  SELECT sql_handle, plan_name
    INTO sys_sql_handle, sys_plan_name
    FROM dba_sql_plan_baselines
   WHERE creator = USER
     AND origin like 'MANUAL-LOAD%'
     AND created = ( -- past 1 minute only
  SELECT MAX(created) max_created
    FROM dba_sql_plan_baselines
   WHERE creator = USER
     AND origin like 'MANUAL-LOAD%'
     AND created > SYSDATE - (1/24/60));

  -- update description of new sql_plan_baseline
  description := 'ori:'||TRIM('&&original_sql_id.')||' modi:'||TRIM('&&modified_sql_id.')||' phv:'||TRIM('&&plan_hash_value.')||' created by coe_load_sql_baseline(tiger)';
  plans :=
  DBMS_SPM.ALTER_SQL_PLAN_BASELINE (
    sql_handle      => sys_sql_handle,
    plan_name       => sys_plan_name,
    attribute_name  => 'description',
    attribute_value => description );
  DBMS_OUTPUT.PUT_LINE(plans||' plan(s) modified description: "'||description||'"');

  -- update plan_name of new sql_plan_baseline
  :plan_name := TRIM('&&modified_sql_id.')||'_'||TRIM('&&plan_hash_value.');
  plans :=
  DBMS_SPM.ALTER_SQL_PLAN_BASELINE (
    sql_handle      => sys_sql_handle,
    plan_name       => sys_plan_name,
    attribute_name  => 'plan_name',
    attribute_value => :plan_name );
  DBMS_OUTPUT.PUT_LINE(plans||' plan(s) modified plan_name: "'||:plan_name||'"');
/*
--tiger liu comment:  -- drop baseline staging table for original sql (if one exists)
--tiger liu comment:  BEGIN
--tiger liu comment:    DBMS_OUTPUT.PUT_LINE('dropping staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:    EXECUTE IMMEDIATE 'DROP TABLE STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'));
--tiger liu comment:  EXCEPTION
--tiger liu comment:    WHEN OTHERS THEN
--tiger liu comment:      DBMS_OUTPUT.PUT_LINE('staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'" did not exist');
--tiger liu comment:  END;
--tiger liu comment:
--tiger liu comment:  -- create baseline staging table for original sql
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE('creating staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:  DBMS_SPM.CREATE_STGTAB_BASELINE (
--tiger liu comment:    table_name  => 'STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.')),
--tiger liu comment:    table_owner => '&&connected_user.' );
--tiger liu comment:
--tiger liu comment:  -- packs new baseline for original sql
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE('packaging new sql baseline into staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:  plans :=
--tiger liu comment:  DBMS_SPM.PACK_STGTAB_BASELINE (
--tiger liu comment:     table_name  => 'STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.')),
--tiger liu comment:     table_owner => '&&connected_user.',
--tiger liu comment:     sql_handle  => sys_sql_handle,
--tiger liu comment:     plan_name   => :plan_name );
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE(plans||' pla(s) packaged');
*/
END;
/

-- display details of new sql_plan_baseline
SET ECHO ON;
col signature format 9999999999999999999
col sql_handle format a30
col plan_name format a30
SELECT signature, sql_handle, plan_name, enabled, accepted, fixed--, reproduced (avail on 11.2.0.2)
  FROM dba_sql_plan_baselines WHERE plan_name = :plan_name;
col description format a100
SELECT description
  FROM dba_sql_plan_baselines WHERE plan_name = :plan_name;
SET ECHO OFF;
/*
--tiger liu comment:PRO
--tiger liu comment:PRO ****************************************************************************
--tiger liu comment:PRO * Enter &&connected_user. password to export staging table STGTAB_BASELINE_&&original_sql_id.
--tiger liu comment:PRO ****************************************************************************
--tiger liu comment:HOS exp &&connected_user. tables=&&connected_user..STGTAB_BASELINE_&&original_sql_id. file=STGTAB_BASELINE_&&original_sql_id..dmp statistics=NONE indexes=N constraints=N grants=N triggers=N
--tiger liu comment:PRO
--tiger liu comment:PRO If you need to implement this SQL Plan Baseline on a similar system,
--tiger liu comment:PRO import and unpack using these commands:
--tiger liu comment:PRO
--tiger liu comment:PRO imp &&connected_user. file=STGTAB_BASELINE_&&original_sql_id..dmp tables=STGTAB_BASELINE_&&original_sql_id. ignore=Y
--tiger liu comment:PRO
--tiger liu comment:PRO SET SERVEROUT ON;;
--tiger liu comment:PRO DECLARE
--tiger liu comment:PRO   plans NUMBER;;
--tiger liu comment:PRO BEGIN
--tiger liu comment:PRO   plans := DBMS_SPM.UNPACK_STGTAB_BASELINE('STGTAB_BASELINE_&&original_sql_id.', '&&connected_user.');;
--tiger liu comment:PRO   DBMS_OUTPUT.PUT_LINE(plans||' plan(s) unpackaged');;
--tiger liu comment:PRO END;;
--tiger liu comment:PRO /
--tiger liu comment:PRO
--tiger liu comment:SPO OFF;
--tiger liu comment:HOS zip -m coe_load_sql_baseline_&&original_sql_id. coe_load_sql_baseline_&&original_sql_id..log STGTAB_BASELINE_&&original_sql_id..dmp coe_load_sql_baseline.log
--tiger liu comment:HOS zip -d coe_load_sql_baseline_&&original_sql_id. coe_load_sql_baseline.log
*/

PRO coe_load_sql_baseline completed.(script modified by Tiger Liu)

!
exit 0
fi



############################################################################################################################
if [ "$1" = "col" ]; then

  if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then
    echo "ora col <owner> <tab_name> <col_name>"
    exit 1
  fi 
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180
    pro column info:
    col owner format a10 trunc
    col table_name format a20 trunc
    col column_name format a20 
    col dtype format a12 trunc
    col low_value format a15
    col high_value format a15 
    col bucks format 999
    col ndv format 999999999
    col histogram format a10 trunc
    
    select owner,table_name,column_name,data_type||'('||data_length||')' as dtype ,num_distinct as ndv,low_value,high_value,
    nullable,num_nulls,histogram,num_buckets as bucks,sample_size,to_char(last_analyzed,'yyyymmdd hh24mmss') as last_analyzed
    from dba_tab_columns 
    where owner=upper('$2') and table_name=upper('$3') and column_name=upper('$4');
    $ECHO

    pro column index info:
    col table_owner format a20
    col idx_columns format a60
    col index_name format a30
    col pos format 99
    select a.* ,b.idx_columns from
    (select table_owner,table_name,index_name,column_name,column_position as pos from dba_ind_columns 
    where table_owner=upper('$2') and table_name=upper('$3') and column_name=upper('$4'))a,
    (select table_owner,index_name,LISTAGG (column_name,',') WITHIN GROUP (ORDER BY column_position) AS idx_columns
    from dba_ind_columns a where  table_owner=upper('$2') and table_name=upper('$3')
    group by table_owner,index_name)b
    where a.table_owner=b.table_owner and a.index_name=b.index_name;
    $ECHO    
    
!
ora histogram $2 $3 $4
exit 0
fi

###################################################################################################################
if [ "$1" = "ashsql" -o "$1" = "dashsql" ]; then

#echo $(TZ=EST-7EDT date +"%Y%m%d %H%M%S") --- get prev 1 hour  
   if [ "$2" = "" ]; then
    defbtime=$(TZ=EST-7EDT date +"%H:%M")
    defbtime2=$(TZ=EST-7EDT date +"%Y/%m/%d %H:%M")
    #defbtime=`date +'%H:%M'`
    read -p "Please input begin time,datetime format is [$defbtime](default) or [$defbtime2] :" btime
      if [ -z "${btime}" ];then
         btime=$defbtime
         #echo "No input,exit"
         #exit 1
      fi  
    defdur=30
    read -p "Please input duration time ,default is [$defdur]:" dur
      if [ -z "${dur}" ];then
         dur=$defdur
      fi    
   else
     btime=$2
     dur=$3     
   fi
   
    strlen=`echo $btime|wc -c|tr -d " "` 
    #echo $strlen
    #exit
    
   if [ $strlen -ne 6 -a $strlen -ne 17 ]; then
       echo "date parameter format error. usage: ora ashsql 08:10 25 or ora ashsql \"2020/01/09 22:39\" 30 "
       #echo "ora ashsql 08:10 25"
       #echo "ora -i 1 ashsql \"2020/01/09 22:39\" 30"
       exit 1
   fi
   
   #08:10  strlen=6
   if [ $strlen = 6 ]; then
      starttime="to_date(to_char(sysdate,'yyyy/mm/dd ')||'$btime','yyyy/mm/dd hh24:mi')"
   fi
   
   #2020/01/09 22:39 strlen=17
   if [ $strlen = 17 ]; then
      starttime="to_date('$btime','yyyy/mm/dd hh24:mi')"
   fi    
   #echo $starttime
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col sql_id format a15
    col event format a40   
    spool ora_ashsql_$filedate.log
    
    Pro active_session_history   :
     select * from 
    (select inst_id,sql_id,nvl(event,session_state) as event,count(*) as cnt from gv\$active_session_history 
    where sample_time between 
        $starttime
    and $starttime+$dur/60/24
    and inst_id=$INST and (sql_id is not null or event is not null)
    group by inst_id,sql_id,nvl(event,session_state) having count(*)>=1
    order by cnt desc
    ) where rownum<=20;    
    $ECHO
    
    
    Pro dba_hist_active_sess_history  :
    select * from 
    (select instance_number as inst_id,sql_id,event,count(*) as cnt from dba_hist_active_sess_history 
    where sample_time between 
        $starttime
    and $starttime+$dur/60/24
    and instance_number=$INST and (sql_id is not null or event is not null)
    group by instance_number,sql_id,event having count(*)>=1
    order by cnt desc
    ) where rownum<=20;
    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "ash and dash group by sql_id,evnet ,from $btime, last $dur ,top 20 sql with event"
echo "ora ashsql <begin_time> <duration> [20]"
exit 0
fi


################################################################################
if [ "$1" = "tbs_frag" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col tablespace_name format a30 
spool ora_tbsfrag_$filedate.log
Pro "datafile usage info:"
select a.file_id "FileNo",a.tablespace_name "Tablespace_name", 
round(a.bytes/1024/1024) "size_M",
round((a.bytes-sum(nvl(b.bytes,0)))/1024/1024) "Used_M", 
round(sum(nvl(b.bytes,0))/1024/1024) "Free_M", 
round(sum(nvl(b.bytes,0))/a.bytes*100) "%free" 
from dba_data_files a, dba_free_space b 
where a.file_id=b.file_id(+) 
group by a.tablespace_name , a.file_id,a.bytes 
order by a.tablespace_name;
$ECHO

Pro "tablespace fragment info:"
 select tablespace_name,--file_id,
 size_type,count(*) as cnt
 ,round(sum(bytes)/1024/1024) as total_m
 ,round(avg(bytes)/1024/1024) as avg_size_M 
 from
 (
 select tablespace_name,file_id,bytes,
        case when bytes <= 1*1024*1024 then '00_01M' 
             when bytes >  1*1024*1024 and bytes <=5*1024*1024 then '01_05M' 
             else '05_99M' end as size_type
 from dba_free_space 
 ) group by  tablespace_name --,file_id
             ,size_type
order by 1,2,3;
$ECHO
spool off
!
exit 0
fi


########################################################################################################

if [ "$1" = "mon_unzip" -o "$1" = "monunzip" ]; then

  if [ "$2" = "" ]; then
    echo "ora mon_unzip <sql_monitor html file> "
    exit 1
  fi
  
{
awk  '/<html>/,/<[/]report_id>/{ sub(/base64/,"");sub(/zlib/,"");print}' $2
awk  '/<[/]report>/{tag=0}tag==1{print}/<[/]report_id>/{tag=1}' $2 | base64 -id | openssl zlib -d
awk  '/<[/]report>/,/<[/]html>/' $2
} > unzip_$2

echo "$2 unziped to unzip_$2"

exit 0;
fi


################################################################################
if [ "$1" = "event" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    
    col inst_id format 9999
    col event format a40 trunc
    col max_sql_id format a14
    col session_cnt format 9999
    col max_user_name format a20 trunc

    select  inst_id,event,max(sql_id) as max_sql_id
           ,max(username) as max_user_name
           ,sum(sysdate-sql_exec_start)*86400 as sum_elap_s
           ,count(*) as session_cnt
    from gv\$session 
    where status='ACTIVE' and upper(event) not like '%IDLE%'
          and inst_id=$INST
    group by inst_id,event 
    order by count(*);
    $ECHO
!
echo "event count in gv\$session status='ACTIVE' group by inst_id, event"
echo "instance_number=$INST"
exit 0
fi


########################################################################################################
if [ "$1" = "session" -o "$1" = "sid" ]; then

  if [ "$2" = "" ]; then
    echo "ora session <sid> "
    exit 1
  fi
  
  ora -i $INST print_table "select a.*,lpad(''-'',60,''-'') as process_info,b.spid,b.tracefile,b.pga_used_mem \
                            ,c.sql_id||'':''||substr(c.SQL_TEXT,1,150) as running_sql \
                     from gv\$session a,gv\$process b,gv\$sqlarea c \
                     where a.sid=$2 and a.paddr=b.addr and a.inst_id=$INST and b.inst_id=$INST \
                          and a.sql_id=c.sql_id(+) and c.inst_id(+)=$INST "
  
  
  echo "instance_number=$INST"
exit 0;
fi

########################################################################################################
if [ "$1" = "process" ]; then

  if [ "$2" = "" ]; then
    echo "ora process <spid> "
    exit 1
  fi
  
  ora -i $INST print_table "select * from gv\$process where spid=$2 and inst_id=$INST"
echo "instance_number=$INST"
exit 0;
fi


################################################################################
if [ "$1" = "dir" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 37
    set linesize 150
    col owner format a12 trunc
    col DIRECTORY_NAME format a25 trunc
    col DIRECTORY_path format a100
    
    select owner,DIRECTORY_NAME,DIRECTORY_path from dba_directories order by 1,2,3;
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "iostat" -o "$1" = "batch_iostat" ]; then
    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 50
    col filename format a120
    col inst_id format 9999
    col tsname format a20 trunc
    col BEGIN_TIME format a20
    break on BEGIN_TIME
    spool ora_batch_iostat_${INST}_$filedate.log
    
    with snap_sum as
    (select instance_number as inst_id,snap_id,tsname
          ,sum(phyrds) as phyrds,sum(readtim) as readtim ,sum(phyblkrd) as phyblkrd
          ,sum(SINGLEBLKRDS) as singleblkrds,sum(phywrts) as phywrts,sum(SINGLEBLKRDTIM) singleblkrdtim
          ,sum(wait_count) as wait_count,sum(time) as time
           from dba_hist_filestatxs e
           where dbid = (select dbid from v\$database)
            and instance_number=$INST and snap_id >=$bid-1 and snap_id<=$eid
    group by instance_number,snap_id,tsname
    ),
    delta_value as
    (select inst_id,tsname,lag(a.snap_id) over (partition by inst_id,tsname order by a.snap_id) as begin_snap_id,a.snap_id as end_snap_id
           ,lag(b.end_interval_time) over (partition by inst_id,tsname order by b.snap_id) as begin_interval_time,b.end_interval_time
           ,(cast(b.end_interval_time as date)-cast((lag(b.end_interval_time) over (partition by inst_id,tsname order by b.snap_id)) as date))*24*60 as ela_min
          ,phyrds-lag(phyrds) over (partition by inst_id,tsname order by a.snap_id) as reads
          ,phyblkrd-lag(phyblkrd) over (partition by inst_id,tsname order by a.snap_id) as phyblkrd
          ,phywrts-lag(phywrts) over (partition by inst_id,tsname order by a.snap_id) as writes
          ,wait_count-lag(wait_count) over (partition by inst_id,tsname order by a.snap_id) as waits
          ,readtim-lag(readtim) over (partition by inst_id,tsname order by a.snap_id) as readtim
          ,SINGLEBLKRDS-lag(SINGLEBLKRDS) over (partition by inst_id,tsname order by a.snap_id) as SINGLEBLKRDS
          ,SINGLEBLKRDTIM-lag(SINGLEBLKRDTIM) over (partition by inst_id,tsname order by a.snap_id) as SINGLEBLKRDTIM
          ,time-lag(time) over (partition by inst_id,tsname order by a.snap_id) as time
    from snap_sum a,dba_hist_snapshot b 
    where a.inst_id=B.INSTANCE_NUMBER  and a.snap_id=b.snap_id  and a.inst_id=$INST
    and b.dbid = (select dbid from v\$database)
    ),
    final_total as
    (select inst_id,to_char(begin_interval_time,'yyyymmdd-hh24mi') as begin_time,end_snap_id as eid,tsname
           ,round(ela_min) as ela_min
           ,reads
           ,round(reads/ela_min/60) as r_p_s
           ,round(decode(reads,0,0,10*(readtim/reads)),2) as avg_rd_ms
           ,round(decode(reads,0,0,(phyblkrd/reads)),2) as blk_pr
           ,writes
           --,round(SINGLEBLKRDS/ela_min/60,2) as sbrps
           ,round(writes/ela_min/60) as w_p_s
           ,waits
           ,round(decode(waits,0,0,10*(time/waits))) as stpwt
           ,reads+writes as ios
    from delta_value
    where ela_min<100 
    )
select * from 
(
select a.*,row_number() over (partition by inst_id,eid order by reads desc)  as rn
from final_total a
)where rn<=5
order by inst_id,eid;
$ECHO
spool off
     
!
echo "instance_number=$INST"
echo "12.1 and below version only"
echo "ora iostat <bid> <eid> (defualt is 48 recent snapshots)"
exit 0
fi


################################################################################
if [ "$1" = "file" -o "$1" = "files" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 100
    col filename format a80
    col name format a30

    pro datafile and tempfile
     select name as filename,round(bytes/1024/1024)as size_m,status from v\$datafile
     union all
     select name as filename,round(bytes/1024/1024),status from v\$tempfile
     order by filename;
     $ECHO
 
    pro spfile and control file:
    col name format a20
    select value as filename,name from v\$parameter where name ='spfile' 
    union all
    select --name--,lv as position
           trim(REGEXP_SUBSTR( value,'[^,]+', 1, lv)) as filename,name
    from (select name,value from v\$parameter  where name = 'control_files')a,
     (select level lv from dual 
       connect by level <=(select max(regexp_count(value, '[^,]+')) from v\$parameter)
      ) b
    where b.lv<=regexp_count(value, '[^,]+');
    $ECHO
    
    pro online redo log:
    select member as filename,round(bytes/1024/1024) as size_M,a.group# ,b.status
     from v\$logfile a,v\$log b
     where a.group#=b.group#
    order by group#;
    $ECHO 
!
exit 0
fi


################################################################################
if [ "$1" = "topsql_by_plan" ]; then
  echo "ora topsql_by_plan cpu|read|time"
  if [ "$2" = "" -o "$2" = "cpu" ]; then
    orderby=cpu_s
  elif  [ "$2" = "read" ]; then
    orderby=reads_k
  elif  [ "$2" = "time" ]; then
    orderby=elap_s
  fi

  if [ "$3" = "" ]; then
    topn=50
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200 trim on
    set numwidth 20
    col min_user format a10 trunc
    col cpu_s format  9999999
    col elap_s format 9999999
    col wait_s format 9999999
    col "wait/elap" format a8
    col execs format  99999999
    col ela_pe format 9999999
    col tot_buf_k format 99999999
    col avg_buf format   999999999
    col reads_k format   9999999
    col iowait_s format  9999999 
    col sql_ids format  99999    
    col rn format 99
    col sql_text format a40 trunc
    col phv format 99999999999
    col min_sqlid format a13
    col inst_id format 999
    spool ora_topsql_by_plan_${INST}_${filedate}_${orderby}.log
select rownum as rn,a.* from 
(select     inst_id,
            min(PARSING_SCHEMA_NAME) as  min_USER, 
            plan_hash_value as phv,
            count(distinct sql_id) as sql_ids,
            min(sql_id) as min_sqlid,
            round(sum(cpu_time)/1e6) as cpu_s ,
            round(sum(elapsed_Time)/1e6) as elap_s ,
            round(sum(elapsed_Time - cpu_time)/1e6) wait_s,
      $DEFNODISP trunc(sum(elapsed_Time - cpu_time)*100/(greatest(sum(elapsed_Time),1)),1)||'%' as "wait/elap",
            sum(executions) as execs,
            round(sum(elapsed_Time)/greatest(sum(executions),1)/1e6,2) ela_Pe,
            round(sum(buffer_gets)/1000) as tot_buf_k,
            round(sum(buffer_gets)/greatest(sum(executions),1),1) as avg_buf,
            round(sum(disk_reads)/1000) as reads_k,
            round(sum(USER_IO_WAIT_TIME)/1e6) as IOwait_s,
            min(substr(sql_text,1,25)) as  sql_text
            from gv\$sql t
            where plan_hash_value>0 and inst_id=$INST
            group by inst_id,plan_hash_value
            --having count(distinct sql_id)>5
            order by $orderby desc
) a where rownum<=$topn;
$ECHO
spool off

!
echo "instance_number=$INST"
echo "top sql group by plan hash value,orderby $orderby , top $topn"
exit 0
fi


################################################################################
if [ "$1" = "toparea_by_sig" ]; then
    echo "ora toparea_by_sig cpu|read|time"
  if [ "$2" = "" -o "$2" = "cpu" ]; then
    orderby=cpu_s
  elif  [ "$2" = "read" ]; then
    orderby=reads_k
  elif  [ "$2" = "time" ]; then
    orderby=elap_s
  fi

  if [ "$3" = "" ]; then
    topn=50
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200 trims on
    set numwidth 20
    col min_user format a10 trunc
    col cpu_s format  9999999
    col elap_s format 9999999
    col wait_s format 9999999
    col "wait/elap" format a8
    col execs format  99999999
    col ela_pe format 9999999
    col tot_buf_k format 9999999
    col avg_buf format   9999999
    col reads_k format   9999999
    col iowait_s format  9999999  
    col cnt format       9999  
    col rn format        99    
    col sql_text format a25
    col min_sql_id format a14
    spool ora_topsql_by_sig_${INST}_${filedate}_${orderby}.log
    
select rownum as rn,a.* from 
(select     
            force_matching_signature,
            count(*) as cnt,
            min(PARSING_SCHEMA_NAME) as  min_USER,
            min(sql_id) as min_sql_id,
            round(sum(cpu_time)/1e6) as cpu_s ,
            round(sum(elapsed_Time)/1e6) as elap_s ,
            round(sum(elapsed_Time - cpu_time)/1e6) wait_s,
            trunc(sum(elapsed_Time - cpu_time)*100/(greatest(sum(elapsed_Time),1)),1)||'%' as "wait/elap",
            sum(executions) as execs,
            round(sum(elapsed_Time)/greatest(sum(executions),1)/1e6,2) ela_Pe,
            round(sum(buffer_gets)/1000) as tot_buf_k,
            round(sum(buffer_gets)/greatest(sum(executions),1),1) as avg_buf,
            round(sum(disk_reads)/1000) as reads_k,
            round(sum(USER_IO_WAIT_TIME)/1e6) as IOwait_s,
            min(substr(sql_text,1,25)) as  sql_text
            from gv\$sqlarea t
            where force_matching_signature>0 and inst_id=$INST
            group by force_matching_signature
            --having count(*)>1
            order by $orderby desc
) a where rownum<=$topn;
$ECHO
spool off

!
echo "instance_number=$INST"
echo "top sqlarea group by force_matching_signarue,orderby $orderby , top $topn"
exit 0
fi


################################################################################
if [ "$1" = "open_cursor" ]; then

  if [ "$2" = "" ]; then
    th=100
  else
    th=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    pro display top 30 having open_cursor >= $th :
    select * from 
    (
    select inst_id,sid,count(*) as cnt 
    from gv\$open_cursor 
    where inst_id=$INST
    group by inst_id,sid 
    having count(*)>=$th 
    order by 3 desc
    )where rownum<=30;
    $ECHO
!
echo "instance_number=$INST"
exit 0
fi


################################################################################
if [ "$1" = "top_event" -o "$1" = "batch_event" ]; then

    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 300 pagesize 8
    col r1_event format a15 trunc
    col r2_event format a15 trunc
    col r3_event format a15 trunc
    col r4_event format a15 trunc
    col r5_event format a15 trunc
    col event format a30 trunc
    col inst_id format 9999
    col wait_class format a15
    col SNAP_END_TIME format a20
    --break on eid
    break on snap_end_time
    spool ora_batch_event_${INST}_$filedate.log
    with tmp_res as
    (select v1.instance_number as inst_id,--v1.begin_snap_id,
            v1.end_snap_id-1 as bid
           ,v2.snap_end_time
           ,event,wtfg as waits
           ,round(tmfg/1e6) as time_s
           ,round(wt_avg/1000,1) as wt_avg_ms
           ,wcls as wait_class
           ,round(v2.db_time/1e6) as db_time_s
           ,round(v1.tmfg/v2.db_time*100,1) as percent
           ,row_number() over (partition by v1.instance_number, v1.begin_snap_id,v1.end_snap_id order by v1.tmfg/v2.db_time desc) as rn       
    from 
    (--v1 begin:
        --other top 4 events
        select instance_number,begin_snap_id,end_snap_id,event,wtfg,tmfg,round(tmfg/wtfg) as wt_avg,wcls 
        from
        (select  a.*,row_number() over (partition by instance_number,begin_snap_id,end_snap_id order by tmfg desc) as rn
         from
         (select e.instance_number,e.snap_id-1 as begin_snap_id,e.snap_id as end_snap_id,
                    e.event_name as event,
                   case when e.total_waits_fg is not null
                          then e.total_waits_fg - 
                               nvl(lag(e.total_waits_fg) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                          else (e.total_waits 
                                - nvl(lag(e.total_waits ) over (partition by e.event_name order by e.instance_number, e.snap_id),0) 
                                - greatest(0,(nvl(ebg.total_waits,0)
                                - nvl(lag(ebg.total_waits)   over (partition by e.event_name order by e.instance_number, e.snap_id),0))))
                    end  wtfg ,
                    case when e.time_waited_micro_fg is not null
                          then e.time_waited_micro_fg - 
                               nvl(lag(e.time_waited_micro_fg) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                          else 
                          (e.time_waited_micro 
                            - nvl(lag(e.time_waited_micro  ) over (partition by e.event_name order by e.instance_number, e.snap_id),0) 
                            - greatest(0,(nvl(ebg.time_waited_micro,0)
                            - nvl(lag(ebg.time_waited_micro) over(partition by e.event_name order by e.instance_number, e.snap_id),0)))
                           )
                    end  tmfg,
                   e.wait_class  wcls
                from dba_hist_system_event e
                   , dba_hist_bg_event_summary ebg
               where 
                     e.dbid          = (select dbid from v\$database)
                 and e.dbid            = ebg.dbid (+)
                 and e.snap_id  =       ebg.snap_id (+)
                 and e.instance_number = ebg.instance_number (+)
                 and e.instance_number = $INST
                 and e.event_id        = ebg.event_id (+)
                 and e.wait_class     <> 'Idle'
         ) a 
        )where rn<=4 and wtfg>0--end other top 4
      union all --DB cpu begin,db_cpu is always in top 5
        select instance_number,begin_snap_id, end_snap_id,'DB CPU' as event,
        to_number(null) as wtfg,
        lag_value as tmfg,
        to_number(null) as wt_avg,
        to_char(null) as wcls
        from
        (  select sp.instance_number,
            sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
            sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, 
            (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
            value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
            sy.stat_name
            from dba_hist_snapshot sp, dba_hist_sys_time_model sy
            where sp.snap_id=sy.snap_id
              and sp.instance_number=sy.instance_number
              and sp.instance_number=$INST
              and sy.stat_name='DB CPU'
              and sp.snap_id >= $bid and sp.snap_id <=$eid  ----max 100 snapshot 
        ) where  nvl(lag_value,0)>0 --DB cpu end
    )v1, --------------------------------------------top 10 events
    (
        select instance_number,begin_snap_id, end_snap_id,lag_value as db_time,snap_end_time
        from
        (  select sp.instance_number,
            sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
            sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, 
            (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
            value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
            sy.stat_name
            from dba_hist_snapshot sp, dba_hist_sys_time_model sy
            where sp.snap_id=sy.snap_id
              and sp.instance_number=sy.instance_number
              and sp.instance_number=$INST
              and sy.stat_name='DB time'
              and sp.snap_id >= $bid and sp.snap_id <=$eid --max 100 snapshot
        ) where   nvl(lag_value,0)>0
    )v2 ------------------------------------------db time
    where v1.instance_number = v2.instance_number 
    and v1.end_snap_id=v2.end_snap_id
    )
    select * from tmp_res
    --pivot 
    --(
    -- max(event) as event,max(waits) as waits ,max(round(time_s/1e6)) as time_s,max(percent) as pct
    -- for rn  in (1 as R1,2 as R2,
    --    3 as R3,4 as R4 , 
    --    5 as R5) --the other columns must have same content; gen 3 * 5 = 15 columns
    --)
    order by inst_id,bid,rn;
    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "get batch awr top event for recent $snaps snapshots"
exit 0
fi


################################################################################
if [ "$1" = "big_by_tbs" ]; then

 if [ "$2" = "" ]; then
   echo "ora big_by_tbs <tablespace_name>"
   exit 1
 fi
 
  if [ "$3" = "" ]; then
    topn=20
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    col tablespace_name format a20 trunc
    col owner format a20 trunc
    col segment_name format a30 
    col segment_type format a20 trunc
    col pct format a10

    select  tablespace_name, 
                      owner, 
                      segment_name, 
                     segment_type, 
                     size_MB,partitions, round((RATIO_TO_REPORT (size_MB) OVER ()) *100,2)||'%' pct
    from 
    (  select 
                     tablespace_name, 
                     owner , 
                     segment_name , 
                     segment_type, 
                     round(SUM(bytes/1024/1024)) size_MB, 
                     case when count(*)=1 then null else count(*) end  partitions 
             from dba_segments 
             where upper(tablespace_name) like upper('$2')  -- tablespace name   
       group by      tablespace_name, 
                     owner, 
                     segment_name, 
                     segment_type 
             order by size_MB desc 
    ) where rownum <= $topn; 
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "dpr_risk" ]; then

  if [ "$2" = "" ]; then
    execs=24
  else
    execs=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    col small_value new_value small_value;
    def hisdays=1
    def ratio=0.8

    set linesize 200 pagesize 37
    set verify off

    --11203+; not include partition table 
    Pro _small_table_threshold :
    col small_value format a30
    col owner format a20 trunc
    col table_name format a30
    spool ora_dpr_risk_$filedate.log
    select ksppstvl  as small_value
    from sys.x\$ksppi x, sys.x\$ksppcv y
    where (x.indx = y.indx)
    and ksppinm ='_small_table_threshold';
      
    --group by object_name:
    Pro list objects order by execs:
    select  v1.owner,v1.table_name,v1.blocks,round(v1.blocks/&small_value,1) as blocks_vs_threshold
           ,sum(executions_delta) as execs_total
           ,round(sum(executions_delta)*v1.blocks*8192/1024/1024) as total_scan_size_M
    from 
    (select  distinct b.sql_id, a.owner,a.table_name,blocks
     from dba_tab_statistics a,dba_hist_sql_plan b
     where (( b.operation||b.options like 'TABLE ACCESS%FULL')or( b.operation||b.options='INDEX FAST FULL SCAN') ) 
           and a.owner=b.object_owner and a.table_name=b.object_name and a.blocks >=&small_value*&ratio
           and a.object_type='TABLE'
    ) v1,dba_hist_sqlstat  v2
    where v1.sql_id=v2.sql_id 
    and v2.snap_id>=(select min(snap_id) from dba_hist_snapshot where end_interval_time>=sysdate-&hisdays)
    group by v1.owner,v1.table_name,v1.blocks  
    having sum(executions_delta)>=$execs 
    order by total_scan_size_M desc  ;
    $ECHO
    
    set pagesize 0
    col param_value format a50
    select 'parameter _serial_direct_read : '||ksppstvl  as param_value
    from sys.x\$ksppi x, sys.x\$ksppcv y
    where (x.indx = y.indx)
    and ksppinm ='_serial_direct_read';
    $ECHO
    spool off
!
echo "full scan executions more than $execs in 1 day"
exit 0
fi


################################################################################
if [ "$1" = "monsavehis" ]; then

   if [ "$2" = "" ]; then
     echo "ora monsavehis <sqlid> active|text"
     exit 1
   fi
   
    if [ "$3" = "" -o "$3" = "active" -o "$3" = "ACTIVE" ]; then
      type=ACTIVE
    else
      type=TEXT
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

      set echo off
      set linesize 10000
      set pages 6000
      set long 20000000
      set longchunksize 20000000
      set trimout on
      set trims on
      set term off
      set head off
      set verify off
  

    col report_id new_value report_id
    select ltrim(report_id) as report_id from 
    (select report_id from dba_hist_reports where key1='$2' order by key3 desc)
    where rownum<=1;
    
    
  
    spool monhis_$2_${type}_RID_&report_id..html
    
    SELECT DBMS_AUTO_REPORT.REPORT_REPOSITORY_DETAIL(RID => &report_id, TYPE => '$type') FROM dual;
    
    spool off
    
    set pagesize 30
    set head on
    pro sql exec his in dba_hist_reports:
    col sql_id format a14
    col sql_exec_id format a10
    col sql_exec_start format a20
    col user_name format a30
    col elap_s format 99999999
    select INSTANCE_NUMBER as inst_id,snap_id    
    ,key1 sql_id, key2 sql_exec_id, key3 sql_exec_start
    ,EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/user') as user_name
    ,round(EXTRACTVALUE(XMLType(report_summary),'/report_repository_summary/sql/stats/stat[@name="elapsed_time"]')/1e6)  as elap_s
    from dba_hist_reports where key1='$2' order by snap_id;
    $ECHO
!

exit 0
fi


################################################################################
if [ "$1" = "drop" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora drop patch|profile|baseline <name>"
    exit 1
  else
     type=$2
     name=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    
    declare
    drop_type varchar2(30);
    v_text PLS_INTEGER;
    begin
         drop_type:=upper('$type');
         if drop_type='PATCH' then
             dbms_sqldiag.drop_sql_patch('$name');
         elsif drop_type='PROFILE' then
               DBMS_SQLTUNE.drop_sql_profile (name=> '$name', ignore => TRUE);
         elsif drop_type='BASELINE' then
               v_text :=DBMS_SPM.drop_sql_plan_baseline(plan_name =>'$name');
         end if;
    end; 
/    
!
exit 0
fi



################################################################################
if [ "$1" = "stat" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "ora stat <owner> <table_name>"
     exit 1
   else
     owner=$2
     tablename=$3
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180

    pro
    pro
    prompt dba_tab_modifications:

    col partition_name format a20 trunc
    col table_owner format a20 trunc
    col table_name format a30 
    

    select b.table_owner,b.TABLE_NAME,b.partition_name    
    ,b.INSERTS,b.UPDATES,b.DELETES               
    ,to_char(b.TIMESTAMP,'yyyy-mm-dd hh24:mi:ss') as flush_time
    ,b.TRUNCATED             
    --,b.DROP_SEGMENTS  
    from dba_tab_modifications b
    where table_name=upper('$tablename') and table_owner=upper('$owner')
    order by partition_name;

    pro
    pro
    prompt Statistics history:

    col table_name format a20 trunc
    col owner format a10 trunc
    col savtime format a20
    
    SELECT *
      FROM (
    SELECT /*+ NO_MERGE LEADING(pt s t m) */
           t.table_name ,
           t.owner,
           'CURRENT' version_type,
           NULL savtime, 
           t.last_analyzed analyzetime, 
           t.num_rows rowcnt, 
           t.sample_size samplesize, 
           CASE WHEN t.num_rows > 0 THEN TO_CHAR(ROUND(t.sample_size * 100 / t.num_rows, 1), '99999990D0') END perc, 
           t.blocks blkcnt, 
           t.avg_row_len avgrln
      FROM  dba_tables t
     WHERE t.owner = upper('$owner') and
           t.table_name=upper('$tablename')
    UNION ALL
    SELECT /*+ NO_MERGE LEADING(s t m) */
           t.object_name,
           t.owner,
           'HISTORY' version_type,
           to_char(h.savtime, 'yyyy-mm-dd hh24:mi:ss') as savetime,
           h.analyzetime, 
           h.rowcnt, 
           h.samplesize, 
           CASE WHEN h.rowcnt > 0 THEN TO_CHAR(ROUND(h.samplesize * 100 / h.rowcnt, 1), '99999990D0') END perc, 
           h.blkcnt, 
           h.avgrln
      FROM dba_objects t,
           sys.WRI\$_OPTSTAT_TAB_HISTORY h  
     WHERE t.owner = upper('$owner')
       and t.object_name=upper('$tablename')
       AND t.object_id = h.obj#
       AND t.object_type = 'TABLE' )
     ORDER BY
           table_name,
           owner,
           savtime DESC NULLS FIRST;  
    
        
    
    Pro Index statistics:
    set linesize 180 pagesize 100
    col idx_type format a10 trunc
    col deg format a3 
    col vis format a3
    col cols format 99
    col lv format 99
    col index_name format a20 trunc
    col LAST_ANALYZED format a15
    col status format a6
    SELECT /*+ NO_MERGE LEADING(pt s i) */
          -- s.table_name,
          -- s.table_owner,
           s.index_name,
          -- s.owner,
           decode(i.index_type,'FUNCTION-BASED NORMAL','F_normal',i.index_type) as idx_type,
           i.partitioned,
           i.degree as deg,
           i.temporary,
           i.status,
           --decode(i.VISIBILITy,'VISIBLE','Y','N') as vis,
           decode(i.uniqueness,'NONUNIQUE','N','UNIQUE','Y','N/A') as uni,
           (SELECT COUNT(*)
              FROM dba_ind_columns c
             WHERE c.index_owner = s.owner
               AND c.index_name = s.index_name
               AND c.table_owner = s.table_owner
               AND c.table_name = s.table_name) cols,
           s.num_rows,
           --s.sample_size,
           --CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
           TO_CHAR(s.last_analyzed, 'YYYYMMDD HH24MISS') last_analyzed,
           s.distinct_keys as DK,
           s.blevel as lv,
           s.leaf_blocks as lf_blks,
           s.avg_leaf_blocks_per_key as LF_key,
           s.avg_data_blocks_per_key as DB_Key,
           s.clustering_factor as CF,
           --s.global_stats,
           --s.user_stats,
           s.stattype_locked as locked,
           s.stale_stats
      FROM --plan_tables pt,
           dba_ind_statistics s,
           dba_indexes i
     WHERE --pt.object_type = 'TABLE'
       --AND pt.object_owner = s.table_owner
       --AND pt.object_name = s.table_name
           s.table_owner=upper('$owner')
       AND s.table_name=upper('$tablename')
       AND s.object_type = 'INDEX'
       AND s.owner = i.owner
       AND s.index_name = i.index_name
       AND s.table_owner = i.table_owner
       AND s.table_name = i.table_name
     ORDER BY s.index_name;
    
         
    PRO
    pro
    pro Columns info:

    col owner format a12
    col table_name format a30
    col table_owner format a30
    col column_name format a30
    col data_type format a12
    col low_val_25 format a25
    col high_val_25 format a25
    col histogram format a15
    col LAST_ANALYZED format a20

    select --owner,table_name,
    column_name,NULLABLE,NUM_NULLS,data_type,num_distinct,
    substr(low_value,1,25) as low_val_25,substr(high_value,1,25) as high_val_25,
    to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
    histogram
    --,NUM_BUCKETS
    from dba_tab_columns
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by column_name;
    
    Pro Table statistics:
    col stale_stats format a12
    select owner,table_name,partition_name,partition_position,num_rows,blocks
    ,last_analyzed,stattype_locked as locked,stale_stats
    from dba_tab_statistics 
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by partition_position;
    
    
    Pro Basic Info:
    col owner format a10
    col table_name format a30
    col degree format a7
    col temporary format a4
    col segment_created format a5
    col logging format a5
    col compression format a9
    col created format a20
    col last_analyzed format a20
    select a.owner,table_name,num_rows,blocks,trim(degree) as degree,a.temporary,
           a.logging,a.segment_created,a.partitioned,a.compression,
           to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
           to_char(b.created,'yyyy-mm-dd hh24:mi:ss') as created
    from dba_tables a,dba_objects b
    where table_name=upper('$tablename') and a.owner=upper('$owner')
          and a.owner=b.owner and b.object_name=a.table_name and b.object_type='TABLE';
    
    prompt Segment info:
    col segment_name format a30
    select owner,segment_name,round(sum(bytes)/1024/1024) seg_size_M ,count(*) as segment_cnt
    from dba_segments 
    where  segment_name=upper('$tablename') and owner=upper('$owner')
    group by owner,segment_name;
    $ECHO     
!
 echo "ora stat $owner $tablename"
 exit 0
fi


################################################################################
if [ "$1" = "sparse_index" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set verify off

    column index_name format a50 trunc
    column part_name format a10 trunc
    column subpart_name format a10 trunc
    column last_ddl_time  format a20
    column x noprint new_value x
    column last_analyzed format a20
    column compression format a11
    col density format a8
    
    spool ora_sparse_index_$filedate.log

    define density='50'

    define obj = 'nvl(isp.obj#, nvl(ip.obj#,i.obj#))'
    define objp = 'nvl(ip.obj#,i.obj#)'
    define rowcnt = 'decode(&obj, isp.obj#, isp.rowcnt, ip.obj#, ip.rowcnt, i.rowcnt)'
    define leafcnt = 'decode(&obj, isp.obj#, isp.leafcnt, ip.obj#, ip.leafcnt, i.leafcnt)'
    define pctf = 'decode(&obj, isp.obj#, isp.pctfree$, ip.obj#, ip.pctfree$, i.pctfree$)'
    define initr = 'decode(&obj, isp.obj#, isp.initrans, ip.obj#, ip.initrans, i.initrans)'
    define last_analyzed = 'nvl(decode(&obj, isp.obj#, isp.analyzetime, ip.obj#, ip.analyzetime, i.analyzetime),to_date(''01.01.1900'',''dd.mm.yyyy''))'
    define compress = 'decode(&obj, isp.obj#, ''N/A'', ip.obj#, decode(bitand(ip.flags, 1024), 0, ''DISABLED'', 1024, ''ENABLED'',''N/A''), decode(bitand(i.flags, 32), 0, ''DISABLED'', 32, ''ENABLED'',''N/A''))'

    select  /*ORACONF*/ /*+ ordered */
      u.name ||'.'|| o.name  index_name,
      op.subname part_name,
      decode(&obj, isp.obj#, o.subname, '') subpart_name,
      to_char(100*(1 - floor( &leafcnt - &rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)))/&leafcnt),'999.00') ||'%' density,
      floor( &leafcnt - &rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)) ) extra_blocks,
      max(o.mtime) last_ddl_time,
      decode(max(&last_analyzed),to_date('01.01.1900','dd.mm.yyyy'),'not analyzed',max(&last_analyzed)) last_analyzed
      --,max(&compress) compression
    from
      sys.ind$  i,
      sys.icol$  ic,
      ( select obj#, part#, bo#, ts#, rowcnt, leafcnt, initrans, pctfree$, analyzetime, flags 
        from sys.indpart$
        union all
        select  /*ORACONF*/ obj#, part#, bo#, defts#, rowcnt, leafcnt, definitrans, defpctfree, analyzetime, flags 
         from sys.indcompart$ 
       ) ip,
      sys.indsubpart$ isp,
      ( select ts#, blocksize value
        from sys.ts$
       )  p,
      sys.hist_head$  h,
      sys.obj$  o,
      sys.user$  u,
      sys.obj$  op
    where
      i.obj# = ip.bo#(+) and
      ip.obj# = isp.pobj#(+) and
      &leafcnt > 1 and
      i.type# in (1) and -- exclude special types
      i.pctthres$ is null and -- exclude IOT secondary indexes
      decode(&obj, isp.obj#, isp.ts#, ip.obj#, ip.ts#, i.ts#) = p.ts# and
      ic.obj# = i.obj# and
      h.obj# = i.bo# and
      h.intcol# = ic.intcol# and
      o.obj# = &obj and
      o.owner# NOT IN 
      (select USER# from sys.user$ 
       where NAME in ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVSYS', 'EXFSYS', 
       'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR', 
       'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' )
      ) and
      u.user# = o.owner# and  op.obj# = &objp
    group by u.name,o.name,op.subname,
      decode(&obj, isp.obj#, o.subname, ''),
      &rowcnt,
      &leafcnt,
      &initr,
      &pctf,
      p.value
      having
         100*(1 - floor( &leafcnt -&rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)))/&leafcnt) <= nvl('&density','70') 
         and      floor( &leafcnt -&rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100))) >= 50
        --fred liu modify >0 to >=50
    order by 4;
    $ECHO
    spool off
!
echo "For your reference only"
exit 0
fi

################################################################################
if [ "$1" = "sparse_table" ]; then

  if [ "$2" = "" ]; then
     min_segsize_M=10
  else
     min_segsize_M="$2"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set verify off
    col "Owner" format a11 wrap heading "Owner"
    col table_name format a30 wrap heading "Tablename"
    col "Partition" format a10 wrap heading "Partition"
    col "Blocks" format 99999999 heading "Used Blocks"
    col "Avg. kBytes/Block" format 99999D99 heading "Avg.|KBytes/Block"
    col "Pct used" format 999 heading "Pct|Used"
    col "Pct free" format 999 heading "Pct|Free"
    col "Freelists" format 999 heading "Free|lists"
    col "last_analyzed" format a11 heading "last|Analyzed"
    col "RowCount" format 9999999999 heading "Row Count"
    col "real_use_M" format 9999999999 heading "Real_use_M"
    col "Empty_Blk" format 9999999999 heading "Empty Blocks"
    col "Free_Spc" format 9999999999 heading "Free Block Space"
    col "Avg_Row_Len" format 999999999 heading "Avg |Row Length"
    col "HWM" format 999999999 heading "HWM"
    col "should_use_m" format 999999999 heading "Should_use_M"
    spool ora_sparse_table_$filedate.log
    SELECT ---table partition
     table_owner "Owner",
     table_name ,
     a.partition_name "Partition",
     trunc(a.num_rows * a.avg_row_len / a.blocks) / 1024 "Avg. kBytes/Block",
     a.num_rows "RowCount",
     a.avg_row_len "Avg_Row_Len",
     round((a.num_rows * a.avg_row_len) / 1024/1024) should_use_M,
     a.blocks "Blocks",
     b.bytes/1048576 "real_use_M",
     a.empty_blocks "Empty_Blk",
     --a.avg_space "Free_Spc",
     (b.blocks - a.empty_blocks - 1) hwm,
     --nvl(to_char(a.pct_used,999),'   -') "Pct used", 
     nvl(to_char(a.pct_free,999),'   -') "Pct free",
     --nvl(to_char(a.freelists,9999),'    -') "Freelists",
     nvl(to_char(a.last_analyzed,'DD-MON-YY'),'not analyzed') "last_analyzed"
    FROM   dba_tab_partitions a,
           dba_segments       b
    WHERE  a.num_rows * a.avg_row_len * 2 < a.blocks *
           (SELECT VALUE 
            FROM   v\$parameter
            WHERE  lower(NAME) = 'db_block_size'
            ) AND
           extents > 1 AND
           a.table_owner = b.owner AND
           b.owner NOT IN ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVF', 'DVSYS', 'EXFSYS', 'HR', 'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'ODM', 'ODM_MTR', 'OE', 'OLAPSYS', 'ORACLE_OCM', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OSE', 'OUTLN', 'PERFSTAT', 'PM', 'QS', 'QS_ADM', 'QS_CB', 'QS_CBADM', 'QS_CS', 'QS_ES', 'QS_OS', 'QS_WS', 'REPADMIN', 'SCOTT', 'SH', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR', 'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' ) AND
           a.table_name = b.segment_name AND
           a.partition_name = b.partition_name AND
           a.blocks > 100 AND
           a.num_rows >= 0 AND
           b.bytes/1024/1024 >=$min_segsize_M AND
           a.last_analyzed IS NOT NULL
    UNION ALL
    SELECT --table
     a.owner "Owner",
     table_name ,
     '' "Partition",
     trunc(a.num_rows * a.avg_row_len / a.blocks) / 1024 "Avg. kBytes/Block",
     a.num_rows "RowCount",
     a.avg_row_len "Avg_Row_Len",
     round((a.num_rows * a.avg_row_len) / 1024/1024) ,
     a.blocks "Blocks",
     b.bytes/1048576 "real_use_M",
     a.empty_blocks "Empty_Blk",
     --a.avg_space "Free_Spc",
     (b.blocks - a.empty_blocks - 1) hwm,
     --nvl(to_char(a.pct_used,999),'   -') "Pct used",
     nvl(to_char(a.pct_free,999),'   -') "Pct free",
     --nvl(to_char(a.freelists,9999),'    -') "Freelists",
     nvl(to_char(a.last_analyzed,'DD-MON-YY'),'not analyzed') "last_analyzed"
    FROM   dba_tables   a,
           dba_segments b
    WHERE  a.num_rows * a.avg_row_len * 2 < a.blocks *
           (SELECT VALUE 
            FROM   v\$parameter
            WHERE  lower(NAME) = 'db_block_size'
            ) AND
           extents > 1 AND
           a.owner = b.owner AND
           b.owner NOT IN ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVF', 'DVSYS', 'EXFSYS', 'HR', 'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'ODM', 'ODM_MTR', 'OE', 'OLAPSYS', 'ORACLE_OCM', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OSE', 'OUTLN', 'PERFSTAT', 'PM', 'QS', 'QS_ADM', 'QS_CB', 'QS_CBADM', 'QS_CS', 'QS_ES', 'QS_OS', 'QS_WS', 'REPADMIN', 'SCOTT', 'SH', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR', 'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' ) AND
           a.table_name = b.segment_name AND
           a.blocks > 100 AND
           a.num_rows >= 0 AND
           b.bytes/1024/1024 > =$min_segsize_M AND
           a.tablespace_name <> ' ' AND
           a.last_analyzed IS NOT NULL and
           a.iot_type IS NULL
    ORDER  BY "Avg. kBytes/Block" DESC;
    $ECHO
    spool off
!
echo "Filter: min_segsize_M=$min_segsize_M  (analyzed / blocks >100 / extents >1 / not sys users / half empty)"
echo usage : ora sparse_table 10
exit 0
fi


################################################################################
if [ "$1" = "hintname" -o "$1" = "hint" ]; then

 if [ "$2" = "" ]; then
   echo "ora hintname index"
   exit 1
 fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col name format a35 trunc
    col inverse format a35 trunc
    col version format a10
    col version_outline format a10 trunc
    select name,inverse,version,version_outline
    from v\$sql_hint where name like upper('%$2%')
    order by name;
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "print_table" ]; then

  if [ "$2" = "" ]; then
    echo "ora print_table  \"select * from t1 where object_name=''T1''\""
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set pagesize 30
    set linesize 150
--usage :  @print_table "select * from t1 where object_name=''T1''"
set verify off serveroutput on size unlimit
declare
    l_theCursor     integer default dbms_sql.open_cursor;
    l_columnValue   varchar2(4000);
    l_status        integer;
    l_descTbl       dbms_sql.desc_tab;
    l_colCnt        number;
    l_rowCnt        number;

    procedure execute_immediate( p_sql in varchar2 )
    is
    BEGIN
        dbms_sql.parse(l_theCursor,p_sql,dbms_sql.native);
        l_status := dbms_sql.execute(l_theCursor);
    END;
    procedure p ( p_str in varchar2 )
    is
        l_str   long := p_str;
    begin
        loop
            exit when l_str is null;
            dbms_output.put_line( substr( l_str, 1, 250 ) );
            l_str := substr( l_str, 251 );
        end loop;
    end;
begin
    execute_immediate( 'alter session set nls_date_format= ''yyyy-mm-dd hh24:mi:ss'' ');
    dbms_sql.parse(  l_theCursor,
                     replace( '$2', '"', ''''),
                     dbms_sql.native );

    dbms_sql.describe_columns( l_theCursor,l_colCnt, l_descTbl );
    l_rowCnt :=0;

    for i in 1 .. l_colCnt loop
        dbms_sql.define_column( l_theCursor, i, l_columnValue, 4000 );

    end loop;

    l_status := dbms_sql.execute(l_theCursor);
    --tiger add:limit with 1000 rows 
    while ( dbms_sql.fetch_rows(l_theCursor) > 0 and l_rowCnt<1000) loop
        for i in 1 .. l_colCnt loop
            dbms_sql.column_value( l_theCursor, i, l_columnValue );
            p( rpad( l_descTbl(i).col_name, 30 ) || ': "' || l_columnValue || '"' );
        end loop;
        l_rowCnt:=l_rowCnt+1;
        dbms_output.put_line( '-----------------' );
    end loop;
    --execute_immediate( 'alter session set nls_date_format=''yyyy-mm-dd hh24:mi:ss'' ');
    dbms_output.put_line( 'total rows = '||l_rowCnt );
exception
    when others then
        execute_immediate( 'alter session set nls_date_format=''dd-MON-yy'' ');
        raise;
end;
/

!
#echo "example:ora print_table \"select * from gv\\\$sql_shared_cursor where sql_id=''69k5bhm12sz98''\""
exit 0
fi


################################################################################################################
if [ "$1" = "sharing" ]; then

  if [ "$2" = "" ]; then
    echo "ora sharing <sql_id>"
    exit 1
  fi
  
 ## ora print_table "select * from gv\$sql_shared_cursor where sql_id=''$2''"

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
   
    Pro group by reason(summary or special sql_id):
    select reason_not_shared, count(*) Reasons
    from gv\$sql_shared_cursor 
     unpivot --column to row
     (val for reason_not_shared in( --68 items 12.2
      UNBOUND_CURSOR,SQL_TYPE_MISMATCH,OPTIMIZER_MISMATCH,OUTLINE_MISMATCH,
      STATS_ROW_MISMATCH,LITERAL_MISMATCH,FORCE_HARD_PARSE,EXPLAIN_PLAN_CURSOR,
      BUFFERED_DML_MISMATCH,PDML_ENV_MISMATCH,INST_DRTLD_MISMATCH,SLAVE_QC_MISMATCH,
      TYPECHECK_MISMATCH,AUTH_CHECK_MISMATCH,BIND_MISMATCH,DESCRIBE_MISMATCH,
      LANGUAGE_MISMATCH,TRANSLATION_MISMATCH,BIND_EQUIV_FAILURE,INSUFF_PRIVS,
      INSUFF_PRIVS_REM,REMOTE_TRANS_MISMATCH,LOGMINER_SESSION_MISMATCH,INCOMP_LTRL_MISMATCH,
      OVERLAP_TIME_MISMATCH,EDITION_MISMATCH,MV_QUERY_GEN_MISMATCH,USER_BIND_PEEK_MISMATCH,
      TYPCHK_DEP_MISMATCH,NO_TRIGGER_MISMATCH,FLASHBACK_CURSOR,ANYDATA_TRANSFORMATION,
      PDDL_ENV_MISMATCH,TOP_LEVEL_RPI_CURSOR,DIFFERENT_LONG_LENGTH,LOGICAL_STANDBY_APPLY,
      DIFF_CALL_DURN,BIND_UACS_DIFF,PLSQL_CMP_SWITCHS_DIFF,CURSOR_PARTS_MISMATCH,
      STB_OBJECT_MISMATCH,CROSSEDITION_TRIGGER_MISMATCH,PQ_SLAVE_MISMATCH,TOP_LEVEL_DDL_MISMATCH,
      MULTI_PX_MISMATCH,BIND_PEEKED_PQ_MISMATCH,MV_REWRITE_MISMATCH,ROLL_INVALID_MISMATCH,
      OPTIMIZER_MODE_MISMATCH,PX_MISMATCH,MV_STALEOBJ_MISMATCH,FLASHBACK_TABLE_MISMATCH,
      LITREP_COMP_MISMATCH,PLSQL_DEBUG,LOAD_OPTIMIZER_STATS,ACL_MISMATCH,
      FLASHBACK_ARCHIVE_MISMATCH,LOCK_USER_SCHEMA_FAILED,REMOTE_MAPPING_MISMATCH,LOAD_RUNTIME_HEAP_FAILED,
      HASH_MATCH_FAILED,PURGED_CURSOR,BIND_LENGTH_UPGRADEABLE,USE_FEEDBACK_STATS)
    )
    where val = 'Y' and inst_id=$INST and sql_id='$2'
    group by reason_not_shared
    order by 2 desc;
    $ECHO
!
echo "instance_number=$INST"
echo "v#sql_shared_cursor : one cursor may have more than one reason."
exit 0
fi


################################################################################
if [ "$1" = "top_seg" -o "$1" = "topseg" ]; then

  ##if [ "$2" = "" -o "$3" = "" ]; then
  ##  bid="(select max(snap_id)-1 from dba_hist_snapshot)"
  ##  eid="(select max(snap_id)   from dba_hist_snapshot)"
  ##else
  ##   bid=$2
  ##   eid=$3
  ##fi
  
  if [ "$2" = "" -o "$3" = "" ]; then
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
    
   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else 
    bid=$2
    eid=$3   
  fi
  
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col owner format a15 trunc
    col tablespace_name format a15 trunc
    col object_name format a30
    col subobject_name format a30
    col OBJECT_TYPE format a20 trunc
    spool ora_topseg_$filedate.log
    PRO Top Logical Reads Objects:
    with sum_logical_reads as
    (select max(value)-min(value) as slr
    from dba_hist_sysstat 
    where stat_name='session logical reads' and snap_id between $bid and $eid
    and dbid=(select dbid from v\$database)
    and instance_number=$INST
    )
    select owner, tablespace_name, object_name, subobject_name,
               object_type, logical_reads, ratio
        from (select n.owner, n.tablespace_name, n.object_name,
                     n.subobject_name, n.object_type, r.logical_reads,
                     round(decode(t.slr, 0, to_number(null), 100 * logical_reads / t.slr),2) ratio
                     --round((ratio_to_report(r.logical_reads) over ())*100,2) as ratio
              from dba_hist_seg_stat_obj n,
                   (select dataobj#, obj#, dbid,
                           sum(logical_reads_delta) logical_reads
                    from dba_hist_seg_stat
                    where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                      and snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                      and dbid    = (select dbid from v\$database)
                      and instance_number   = $INST
                    group by dataobj#, obj#, dbid
                   ) r,sum_logical_reads t
              where n.dataobj#      = r.dataobj#
                and n.obj#          = r.obj#
                and n.dbid          = r.dbid
                and r.logical_reads > 0
              order by r.logical_reads desc, object_name, owner, subobject_name
            )
        where rownum <= 10;
        
        PRO Top physical Reads Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat 
        where stat_name='physical reads' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, physical_reads, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.physical_reads,
                         --round((ratio_to_report(r.physical_reads) over ())*100,2) as ratio
                         round(decode(p.phyr, 0, to_number(null),  100 * r.physical_reads / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(physical_reads_delta) physical_reads
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.physical_reads > 0
                  order by r.physical_reads desc, object_name, owner, subobject_name)
            where rownum <= 10;   
      $ECHO
      
      PRO Top physical Read Requests Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat 
        where stat_name='physical read IO requests' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, physical_read_requests, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.physical_read_requests,
                         round(decode(p.phyr, 0, to_number(null),  100 * r.physical_read_requests / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(PHYSICAL_READ_REQUESTS_DELTA) physical_read_requests
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.physical_read_requests > 0
                  order by r.physical_read_requests desc, object_name, owner, subobject_name)
            where rownum <= 10;   
      $ECHO
      
      PRO Top Direct physical Reads Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat 
        where stat_name='physical reads direct' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, direct_physical_reads, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.direct_physical_reads,
                         round(decode(p.phyr, 0, to_number(null),  100 * r.direct_physical_reads / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(PHYSICAL_READS_DIRECT_DELTA) direct_physical_reads
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.direct_physical_reads > 0
                  order by r.direct_physical_reads desc, object_name, owner, subobject_name)
            where rownum <= 10;   
      $ECHO
      
        PRO Top Table Scans Objects:
        with sum_physical_reads as
        (select sum(scans) as scans from 
            (select max(value)-min(value) as scans
            from dba_hist_sysstat 
            where stat_name ='table scans (direct read)' and snap_id between $bid and $eid
            and dbid=(select dbid from v\$database)
            and instance_number=$INST
            union all
            select max(value)-min(value) as scans
            from dba_hist_sysstat 
            where stat_name= 'index fast full scans (full)' and snap_id between $bid and $eid
            and dbid=(select dbid from v\$database)
            and instance_number=$INST
            )
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, table_scans, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.table_scans,
                         round(decode(p.scans, 0, to_number(null),  100 * r.table_scans / p.scans),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(TABLE_SCANS_DELTA) table_scans
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.table_scans > 0
                  order by r.table_scans desc, object_name, owner, subobject_name)
            where rownum <= 10;   
      $ECHO
      
      
      spool off
!
echo "instance_number=$INST"
echo "top_seg for snapshot $bid $eid"
exit 0
fi

################################################################################
if [ "$1" = "load" -o "$1" = "batch_load" ]; then

 ##if [ "$2" = "" ]; then
 ##   days=2
 ##else
 ##   days=$2
 ##fi
 
     if [ $# -eq 1 ]; then
       bid="(select max(snap_id)-48 from dba_hist_snapshot)"
       eid="(select max(snap_id)    from dba_hist_snapshot)"
     elif [ $# -eq 2 ]; then
       bid="(select max(snap_id)-$2 from dba_hist_snapshot)"
       eid="(select max(snap_id)    from dba_hist_snapshot)"
     elif [ $# -eq 3 ]; then
       bid=$2
       eid=$3
    fi
 

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set trims on
    col inst_id format 999
    col bid format 99999
    col elap format 9999
    col e_time format a11
    col rbs format 999
    col commits format 99999
    col execs format 999999
    col logons format 999
    col ior_m format 9999
    col iow_m format 9999
    col hard_p format 9999
    col SOFT_P format 999999
    col U_CALLS format 99999
    col redo_k format 999999
    col END_TIME format a20
    
    spool ora_batch_load_${INST}_${filedate}.log
    with tmp_stat as
    (select instance_number as inst_id,lag(snap_id) over (partition by dbid,instance_number,stat_id order by snap_id) as bid
           ,a.snap_id as eid,stat_name
           ,value-lag(value) over (partition by dbid,instance_number,stat_id order by snap_id) as delta_value
     from dba_hist_sysstat a 
     where dbid=(select dbid from v\$database) 
     and instance_number = $INST
     and snap_id >=$bid
     and snap_id <=$eid
     and a.stat_name in (
    'db block changes','execute count','logons cumulative','opened cursors cumulative','parse count (total)',
    'parse count (hard)','physical reads','physical writes','redo size','session cursor cache hits',
    'session logical reads','user calls','user commits','user rollbacks','workarea executions - optimal'
    ,'physical write total bytes','physical read total bytes'
    --,'DB time','CPU used by this session'
    )
    ),
    tmp_snap as 
        (select instance_number as inst_id,snap_id-1 as bid,snap_id as eid,to_char(end_interval_time,'yymmdd-hh24mi') as end_time,
        (cast(end_interval_time as date) - cast(begin_interval_time as date))* 24 * 60 * 60 as secs
        from dba_hist_snapshot 
        where snap_id >=$bid 
          and snap_id<=$eid
          and dbid=(select dbid from v\$database) 
          and instance_number=$INST
        ),
    tmp_before_pivot as
    (
     select a.inst_id,a.bid,b.end_time,a.eid,
           a.stat_name,round(b.secs/60) as elp_mins,round(a.delta_value/b.secs,1) as per_second 
     from tmp_stat a,tmp_snap b
     where a.delta_value is not null
     and a.inst_id=b.inst_id
     and a.bid=b.bid and a.eid=b.eid and b.secs>0
    ),
    tmp_load1 as 
    (
    select  inst_id
           ,BID,EID||'_'||end_time as end_time
           ,ELP_MINS as elap
           ,round(ior_m/1024/1024,1) as ior_m
           ,round(iow_m/1024/1024,1) as iow_m
           ,round(redo_size) as redo_size
           ,round(logical_reads) as l_reads
           ,round(Block_changes) as Blk_chgs
           ,round(physical_reads) as phy_reads
           ,round(physical_writes) as phy_writes
           ,round(user_calls) as u_calls
           ,round(parses) as soft_p
           ,round(hard_parses) as hard_p
           ,round(logons) as logons
           ,round(executions) as execs
           ,round(commits) as commits
           ,round(rollbacks) as rbs    
    from tmp_before_pivot a
    pivot 
        (max(per_second) for stat_name in 
            (--'CPU used by this session' as cpu,'DB time' as db_time,
            'redo size' as redo_size,'session logical reads' as logical_reads,
            'db block changes' as Block_changes,    'physical reads' as physical_reads,
            'physical writes' as physical_writes,    'user calls' as user_calls,   
            'parse count (total)' as parses,
            'parse count (hard)' as hard_parses,    'logons cumulative' as logons,
            'execute count' as executions,    --'parse time elapsed','session cursor cache hits',
            'user commits' as commits,    'user rollbacks' as rollbacks
            ,'physical write total bytes' as iow_M,'physical read total bytes' as ior_M
            )
        )
    ),
    tmp_load2 as
    (
    select * from 
    (
    select sp.instance_number as inst_id,
    sp.snap_id-1 as begin_snap_id,
    sp.snap_id   as end_snap_id, 
    to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
    to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, 
    (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
    value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
    sy.stat_name
    from dba_hist_snapshot sp, dba_hist_sys_time_model sy
    where sp.snap_id=sy.snap_id
      and sp.instance_number=sy.instance_number
      and sy.stat_name in ('DB CPU' ,'DB time')
      and sp.instance_number=$INST
    ) pivot (sum(lag_value) for stat_name in  ('DB CPU' as db_cpu ,'DB time' as db_time))
    where   nvl(db_cpu,0)>0 and nvl(db_time,0)>0
    )
select   a.inst_id,BID,end_time,elap
        ,round(db_cpu/60/1000000/interval_min,2) as db_cpu_s
        ,round(db_time/60/1000000/interval_min,2) as db_time_s
        ,ior_m,iow_m,round(redo_size/1024) as redo_k
        ,l_reads,Blk_chgs,phy_reads,phy_writes,u_calls
        ,soft_p,hard_p,logons,execs,commits,rbs
    from tmp_load1 a,tmp_load2 b
 where a.bid=b.begin_snap_id  and a.inst_id=b.inst_id order by 1,2;
 $ECHO
 spool off
!
echo "instance_number=$INST"
echo "ora load [<bid> <eid>]  (default value is recent 48 snaps)" 
exit 0
fi



################################################################################
if [ "$1" = "tbs_last" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col tablespace_name format a20 trunc
    col rtime format a25
      select a.rtime,b.name as tablespace_name,
         round(a.tablespace_size*c.block_size/1024/1024) as total_size_M,
         round(a.tablespace_usedsize*c.block_size/1024/1024) as used_size_M,
         -- ,c.block_size
         round(a.tablespace_usedsize/a.tablespace_size*100,1) as used_percent
     from dba_hist_tbspc_space_usage a,v\$tablespace b,dba_tablespaces c
     where a.snap_id=(select max(snap_id) from dba_hist_snapshot)
     and b.ts#=A.TABLESPACE_ID and b.name=c.tablespace_name
     order by used_percent;
     $ECHO
!
echo get  tablespace_usedsize from dba_hist_tbspc_space_usage
exit 0
fi


 
################################################################################
if [ "$1" = "tbs_usage" ]; then
#undo tablespace maybe not displayed in DBA_TABLESPACE_USAGE_METRICS

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 40
    set linesize 150
    col tablespace_name format a20 trunc
    SELECT a.tablespace_name,
         --round(tablespace_size * b.block_size / 1024/1024) AS total_space_M ===> a.tablespace_size not suitable for autoextensible       
         b.total_size_M,         
         ROUND (a.used_space * b.block_size  / 1024 /1024) AS used_space_M,
         ROUND (a.used_space * b.block_size  / 1024 /1024/ total_size_M*100,1 ) as used_pct,
         --ROUND (a.used_percent,1) AS used_pct =====> a.used_percent not suitable for autoextensible
         b.autoext
    FROM DBA_TABLESPACE_USAGE_METRICS a, ---only get its used_space column
    (select tablespace_name,round(sum(bytes)/1024/1024) as total_size_M
           ,max(autoextensible) as autoext,max(bytes/blocks) as block_size from dba_data_files
           group by tablespace_name
    union all
          select tablespace_name,round(sum(bytes)/1024/1024) as total_size_M
         ,max(autoextensible) as autoext,max(bytes/blocks) as block_size from dba_temp_files
         group by tablespace_name
    )    b
    where a.tablespace_name=b.tablespace_name
    ORDER BY 4 ;
    $ECHO

!
echo get  tablespace_usedsize from DBA_TABLESPACE_USAGE_METRICS
exit 0
fi

################################################################################
################################################################################
if [ "$1" = "4031" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180
    
    col COMPONENT format a30
    
    spool ora_4031_$filedate.log

    REM === -- end of standard header -- ===
    REM
    SET PAGESIZE 9999
    SET LINESIZE 256
    SET TRIMOUT ON
    SET TRIMSPOOL ON
    COL 'Total Shared Pool Usage(M)' FORMAT 99999999999999999999999
    COL bytes FORMAT 999999999999999
    COL current_size FORMAT 999999999999999
    COL name FORMAT A40
    COL value FORMAT A20
    col OPER_TYPE format a12 trunc
    col OPER_MODE format a10 trunc
    ALTER SESSION SET nls_date_format='DD-MON-YYYY HH24:MI:SS';



    /* Current instance parameter values */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Current instance parameter values:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT n.ksppinm name, v.KSPPSTVL value
    FROM x\$ksppi n, x\$ksppsv v
    WHERE n.indx = v.indx
    AND (n.ksppinm LIKE '%shared_pool%' OR n.ksppinm IN ('_kghdsidx_count', '_ksmg_granule_size', '_memory_imm_mode_without_autosga'))
    ORDER BY 1;

    /* Current memory settings */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Current instance parameter values:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT component, current_size FROM v\$sga_dynamic_components;

    /* Memory resizing operations */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Memory resizing operations:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM v\$sga_resize_ops
    ORDER BY 1, 2;

    /* Historical memory resizing operations */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Historical memory resizing operations:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM dba_hist_memory_resize_ops
    ORDER BY 1, 2;

    /* Shared pool 4031 information */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool 4031 information:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT request_failures, last_failure_size FROM v\$shared_pool_reserved;

    /* Shared pool reserved 4031 information */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool reserved 4031 information:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT requests, request_misses, free_space, avg_free_size, free_count, max_free_size FROM v\$shared_pool_reserved;

    /* Shared pool memory allocations by size */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool memory allocations by size:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT name, bytes FROM v\$sgastat WHERE pool = 'shared pool' AND (bytes > 999999 OR name = 'free memory') ORDER BY bytes DESC;

    /* Total shared pool usage */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Total shared pool usage:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT round(SUM(bytes)/1024/1024) "Total Shared Pool Usage(M)" FROM v\$sgastat WHERE pool = 'shared pool' AND name != 'free memory';

   -- /* Cursor sharability problems */
   -- /* This version is for >= 10g; for <= 9i substitute ss.kglhdpar for ss.address!!!! */
   -- SET HEADING OFF
   -- SELECT '**************************************************************************************************************' FROM dual
   -- UNION ALL
   -- SELECT 'Cursor sharability problems (this version is for >= 10g; for <= 9i substitute ss.kglhdpar for ss.address!!!!):' FROM dual
   -- UNION ALL
   -- SELECT '**************************************************************************************************************' FROM dual;
   -- SET HEADING ON
   -- SELECT sa.sql_text,sa.version_count,ss.*
   -- FROM v\$sqlarea sa,v\$sql_shared_cursor ss
   -- WHERE sa.address=ss.address AND sa.version_count > 50
   -- ORDER BY sa.version_count ;
   -- spool off

!
echo "current instance only"
exit 0
fi

################################################################################
if [ "$1" = "pid" ]; then

  if [ "$2" = "" ]; then
    echo "ora pid os_pid"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

col username format a10 trunc
col machine format a10 trunc
col program format a10 trunc
col event format a15 trunc
col sid format 999999
col serial# format 999999
col wait_s format 999999
col sql_id format a13
col b_status format a5 trunc
col B_inst_id format 99
col b_sid format 999999
col sql_text format a20 trunc
col sql_id new_value sql_id
col logon_time format a16
col status format a8

SELECT a.username,
       a.sql_id,
       --a.prev_sql_id,
      a.machine,
      a.program,
      a.sid,
      a.serial#,
      to_char(logon_time,'yyyymmdd hh24miss') logon_time,
      event,
      seconds_in_wait as wait_s,
      a.status,
      round(b.pga_used_mem/1024/1024) as pga_used_M,
      round(b.pga_alloc_mem/1024/1024) as pga_alloc_M,
      BLOCKING_INSTANCE as b_inst_id,
      BLOCKING_SESSION as b_sid,
      BLOCKING_SESSION_STATUS as b_status,
      substr(c.sql_text,1,100 )as sql_text      
FROM  gv\$session a,
      gv\$process b,
      gv\$sql c
WHERE b.spid=$2  
  AND b.addr=a.paddr
  and a.sql_id=c.sql_id(+)
  and a.inst_id=b.inst_id
  and a.inst_id=c.inst_id(+)
  and a.inst_id=$INST
  and a.sql_child_number=c.child_number(+);
  $ECHO
 
!
echo "instance_number=$INST"
exit 0
fi


################################################################################
if [ "$1" = "check" ]; then

 # if [ "$2" = "" ]; then
 #   echo "ora check xxx"
 #   exit 1
 # fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col owner format a20 trunc
    col table_name format a30 
    col table_owner format a20 trunc
    col index_name format a30
    col index_owner format a30
    col partition_name format a20 trunc
    
    spool ora_check_$filedate.log
    
    Pro Unusable Index:
    select owner,table_name,table_owner,index_name from dba_indexes where status='UNUSABLE';
    $ECHO
    
    Pro Unusabel index partition :
    select index_owner,index_name,partition_name from dba_ind_partitions where status='UNUSABLE';
    $ECHO
    
    Pro Unusabel index subpartition:  
    select index_owner,index_name,partition_name,subpartition_name from dba_ind_subpartitions where status='UNUSABLE';
    $ECHO
    
    Pro Invisible Index:
    select owner,table_name,table_owner,index_name from dba_indexes where visibility='INVISIBLE';
    $ECHO
    
    pro
    pro    
    prompt =========================================================================================
    Prompt "Invalid objects by owner and type:"
    prompt =========================================================================================
    col owner format a30
    col object_type format a30
    select owner,object_type,count(*) invalid_cnt
    from dba_objects 
    where status='INVALID'
    group by owner,object_type
    order by 1,2;
    $ECHO
    
    Pro Table with Columns more than 255:  
    select owner,table_name,count(*) as col_cnt from dba_tab_columns  
    group by owner,table_name having count(*) >255
    order by 1,2;    
    $ECHO
    
    Pro Bitmap index:  
    select table_owner,table_name,index_name 
    from dba_indexes where index_type='BITMAP'
    order by 1,2;
    $ECHO
    
    
    Pro foreign key column no index:
    col FK_COLUMNS format a35 trunc
    col OWNER format a20 trunc
    col CONSTRAINT_NAME format a30
    select fk.* from
    (SELECT   b.owner,B.TABLE_NAME,B.CONSTRAINT_NAME, count(*) column_cnt,
                   listagg(COLUMN_NAME, ',') within group (order by POSITION) fk_columns
              FROM DBA_CONS_COLUMNS A,
                   DBA_CONSTRAINTS B
             WHERE b.owner not in ('SYS','SYSTEM','WMSYS','SYSMAN','MDSYS','CTXSYS','OLAPSYS','DBSNMP','XDB','ORDDATA','EXFSYS')
                 and b.owner not like 'APEX%'
               AND A.CONSTRAINT_NAME = B.CONSTRAINT_NAME
               AND A.owner= b.owner
               AND B.CONSTRAINT_TYPE = 'R'
             GROUP BY b.owner,B.TABLE_NAME, B.CONSTRAINT_NAME
    )fk,
    ( select table_owner,table_name,index_name,count(*) column_cnt,
     listagg(COLUMN_NAME, ',') within group (order by COLUMN_POSITION) idx_columns
    from dba_ind_columns 
    where table_owner not in ('SYS','SYSTEM','WMSYS','SYSMAN','MDSYS','CTXSYS','OLAPSYS','DBSNMP','XDB')
          and table_owner not like 'APEX%'
    group by table_owner,table_name,index_name
    )idx
    where fk.owner=idx.table_owner(+) and fk.table_name=idx.table_name(+) and fk.fk_columns=idx.idx_columns(+)
    and idx.table_owner is null
    order by 1,2,3;
    $ECHO
    spool off

!
ora degree
ora feature
ora big
ora file
ora pc
ora pc2
ora stats
ora tbs
ora tbsinc
ora rman
ora dg
ora lob
ora redo
ora temp
ora undo
exit 0
fi


################################################################################
if [ "$1" = "tabidx" ]; then

  if [ "$2" = "" ]; then
    echo "ora tabidx table_name"
    exit 1
  fi

  ver2=`get_ver 2`
  if [ $ver2 -lt 11 ]; then
    ver2='--'
  else
    ver2=''
  fi
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 150 pagesize 200 
    col column_name format a30 
    col table_owner format a20
    col table_name format a30
    col index_name format a30
    col partitioned format a11

    break on TABLE_OWNER skip 1

    
    Pro index info : 
    
    select table_owner,table_name,index_name,status,partitioned,
        $ver2 visibility,
        index_type 
    from dba_indexes 
    where table_name=upper('$2')
    order by 1,2,3;
    $ECHO
    
     break on index_name skip 1
     Pro index columns :
    select table_owner,table_name,index_name,COLUMN_POSITION,column_name 
    from dba_ind_columns 
    where  table_name=upper('$2') 
    order by 1,2,3,4; 
    $ECHO
    

!
exit 0
fi

################################################################################
if [ "$1" = "event2sqlid" ]; then

  if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then
    echo "ora event2sqlid event_name {bid} {eid}"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set feedback off
    
    select * from 
    (
    select sql_id,count(*) as cnt 
    from dba_hist_active_sess_history 
    where event='$2' and snap_id >$3 and snap_id<=$4
    group by sql_id order by cnt desc
    ) where rownum<=5; 
    $ECHO
    

!
echo "full nodes"
echo "usage: ora event2sqlid \"direct path read\" 8888 8890"
exit 0
fi

################################################################################
if [ "$1" = "gather" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "usage:ora gather owner table_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set feedback off
    
    exec dbms_stats.gather_table_stats('$2','$3',cascade=>true,no_invalidate=>false);

!
   echo "dbms_stats.gather_table_stats('$2','$3',cascade=>true,no_invalidate=>false); command executed"
exit 0
fi


################################################################################
if [ "$1" = "kill" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora kill sid serial# [inst_id]"
    exit 1
  fi
  
  if [ "$4" = ""  ]; then
    inst_id=1
  else
    inst_id=$4
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    alter system kill session '$2,$3,@$inst_id' immediate;

!
  echo "alter system kill session '$2,$3,@$inst_id' immediate; command executed!"
exit 0
fi



################################################################################
if [ "$1" = "topash" -o "$1" = "ashtop" ]; then
 
    if [ "$2" = "" ]; then
      dur=10
    else
      dur=$2
    fi
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    spool ora_topash_$filedate.log
    
    Pro Top 10 sql(by cpu) in recent $dur minutes:
    with tmp_ash as
    (
     select SQL_ID ,
     sum(decode(session_state,'ON CPU',1,0)) as CPU,
     sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as WAIT,
     sum(decode(session_state,'WAITING', decode(wait_class, 'User I/O',1,0),0)) as IO,
     sum(decode(session_state,'ON CPU',1,1)) as TOTAL
     from gv\$active_session_history
     where inst_id=$INST 
           and sample_time >=sysdate-$dur/60/24
           and SQL_ID is not NULL
     group by sql_id
     --order by sum(decode(session_state,'ON CPU',1,1))  desc
     )
    select * from 
    (
     select * from tmp_ash t order by total desc
    )
    where rownum<=10 ;
    $ECHO
    
    
    Pro Top session (foregroud only) in recent $2 minutes::   
    col action format a10 trunc
    col program format a15 trunc
    col module format a20 trunc
    --break on inst_id
    with tmp_ash as
    (
    select
         --INST_ID,
         session_id,
         session_serial#,
         program,
         module,
         action,
         sum(decode(session_state,'WAITING',0,1)) "CPU",
         sum(decode(session_state,'WAITING',1,0)) - sum(decode(session_state,'WAITING',decode(wait_class,'User I/O',1,0),0)) "WAITING" ,
         sum(decode(session_state,'WAITING',decode(wait_class,'User I/O',1,0),0)) "IO" ,
         sum(decode(session_state,'WAITING',1,1)) total
    from gv\$active_session_history 
    where --1=$session and 
          session_type='FOREGROUND' and  sample_time >=sysdate-$dur/60/24
          and inst_id=$INST
    group by session_id,session_serial#,module,action,program
    --order by sum(decode(session_state,'WAITING',1,1)) desc
    )
    select * from 
    (
     select * from tmp_ash t order by total desc
    )
    where rownum<=10 ;
    $ECHO
    
    
    Pro Top activity (interval by 1 minutes,display top 5(cpu) sqls) in recent $2 minutes:
    --break on inst_id on interval_min
    
    with tmp_ash as
    (
     select SQL_ID ,
            sum(decode(session_state,'ON CPU',1,1)) as TOTAL
     from gv\$active_session_history
     where sample_time >=sysdate-$dur/60/24
           and SQL_ID is not NULL
           and inst_id=$INST
     group by sql_id
    )    
    SELECT  to_char(trunc(sample_time,'MI'),'yyyymmdd hh24:mi') as interval_min,
            sql_id,
            count(sql_id) as TOTAL
    FROM gv\$active_session_history
    WHERE sample_time >=sysdate-$dur/60/24 and inst_id=$INST
    AND sql_id in 
    (    select sql_id from 
        (
         select * from tmp_ash t order by total desc
        )
        where rownum<=5
    )
    group by to_char(trunc(sample_time,'MI'),'yyyymmdd hh24:mi'),sql_id 
    order by to_char(trunc(sample_time,'MI'),'yyyymmdd hh24:mi');
    $ECHO
    
    
    Pro Top 10 Event in recent $2 minutes::
    with tmp_ash as
    (
    select h.event,
    round(sum(h.wait_time+h.time_waited)/1e6,2) as total_wait_time
    from gv\$active_session_history h
         where h.sample_time>sysdate-$dur/60/24 and inst_id=$INST
    group by h.event
    )
    select * from 
     (select * from tmp_ash order by  total_wait_time desc) 
    where rownum<=10;
    $ECHO
    spool off

!
echo "instance_number=$INST"
echo "ora topash [10]"
echo "ora -i 2 topash 10"

exit 0
fi

################################################################################
if [ "$1" = "realmon" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 250 pagesize 100
col wtime format 9999
col inst format 9999
col sid format 99999
col pid format a8
col uname format a8 truncated
col prgm format a5 truncated
col modl format a5 truncated
col actn format a5 truncated
col opn format a6 truncated
col blses format a7 truncated
--col wc4  format a5 truncated
col svcn format a8 truncated
col latch_nm format a8 truncated
col fbon format a8 truncated
col event format a10 truncated
col state format a5 truncated
col sqlid format a14
col status format a8
col serial# format 999999

SELECT /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ /*+ NO_MONITOR */ 
--s.WAIT_TIME wtime,
 s.inst_id inst
 ,s.sid sid
 ,s.serial# 
 ,p.spid pid
 ,decode(p.BACKGROUND, 1, 'B/G', decode(s.username, NULL, 'F/G', s.username)) uname
 ,decode(p.PNAME, NULL, s.program, p.PNAME) prgm
 ,s.module modl
 --,s.action actn
 ,p.PGA_USED_MEM pgau
 ,p.PGA_ALLOC_MEM pgac
 ,p.PGA_FREEABLE_MEM pgaf
 --,x.pgax pgax
 ,c.COMMAND_NAME opn
 ,DECODE(s.PLSQL_SUBPROGRAM_ID, NULL, s.SQL_ID, NULL) sqlid
 ,DECODE(s.FINAL_BLOCKING_SESSION_STATUS, 'VALID', to_char(s.FINAL_BLOCKING_INSTANCE) || ':' || to_char(s.FINAL_BLOCKING_SESSION), NULL) blses
 ,s.STATUS status
 ,decode(s.STATE, 'WAITING', decode(s.wait_class, 'UserI/O', 'I/O', s.STATE), 'CPU') state
 ,CASE WHEN s.STATE <> 'WAITING' AND s.TIME_SINCE_LAST_WAIT_MICRO < 1000000 THEN 'cpu runqueue' ELSE event END event
 --,s.wait_class wc4
 ,s.WAIT_TIME_MICRO siw
 ,s.last_call_et lcet
 --,s.SERVER sded
 --,s.SERVICE_NAME svcn
 ,DECODE(n.NAME, NULL, NULL, '*' || n.NAME) latch_nm --latch name
 ,DECODE(s.ROW_WAIT_OBJ#, - 1, NULL, substr(to_char(s.ROW_WAIT_FILE#) || ':' || to_char(s.ROW_WAIT_BLOCK#), 1, 24)) fbon--file#:block#
FROM GV\$SESSION s
JOIN gv\$process p
 ON (p.inst_id = s.inst_id AND p.addr = s.paddr)
LEFT OUTER JOIN v\$sqlcommand c
 ON (s.command = c.COMMAND_TYPE)
LEFT OUTER JOIN v\$LATCHNAME n
 ON (s.p2 = n.latch#)
  ,(
   SELECT /*+ OPT_PARAM('_optimizer_adaptive_plans','false') */ inst_id
    ,MAX(PGA_MAX_MEM) pgax
   FROM GV\$PROCESS
   GROUP BY inst_id
   ) x
WHERE x.inst_id = s.inst_id AND s.wait_class <> 'Idle'
ORDER BY siw DESC,lcet DESC;
$ECHO

!
echo "full nodes"
exit 0
fi

################################################################################
if [ "$1" = "idx2sqlid" ]; then

  if [ "$2" = "" ]; then
    echo "ora idx2sqlid index_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    col text_120 format a120
    
    
    Pro dba_hist_sql_plan and gv\$sql_plan*******************************:
    select sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,120)),chr(10),''),chr(13),'') as text_120
    from dba_hist_sqltext 
    where sql_id in
    (
      select sql_id from dba_hist_sql_plan where object_name=upper('$2')
    )
    union
    select sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,120)),chr(10),''),chr(13),'') as text_120
    from gv\$sql
    where sql_id in
    (
      select sql_id from gv\$sql_plan where object_name=upper('$2')
    ) order by 1;
$ECHO

!
exit 0
fi


################################################################################
if [ "$1" = "ashdump" ]; then

  if [ "$2" = "" ]; then
     dur=1
  else
     dur=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    ALTER SYSTEM SET events 'immediate trace name ashdump level $dur';
    
    prompt "Trace file is :"
    col value format a100
    SELECT value FROM v\$diag_info WHERE name = 'Default Trace File';

!
echo "instance_number=$INST"
echo "dump ash records for recent $dur minutes."
exit 0
fi




################################################################################
if [ "$1" = "hangdump" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    --oradebug setmypid
    --oradebug unlimit
    --oradebug hanganalyze 3
    --oradebug dump ashdumpseconds 60
    --oradebug dump systemstate 10
    --oradebug tracefile_name
!
echo "on current instance"
echo "risk operation,commented! If need , uncomment"
exit 0
fi




################################################################################
if [ "$1" = "outline" ]; then

  if [ "$2" = "" -o "$3" = ""  ]; then
    echo "ora outline {profile|patch} {name}"
    exit 1
  fi
  
  name=$3
  if [ "$2" = "profile" ]; then
    vname=dba_sql_profiles
    type=1
  else 
    vname=dba_sql_patches
    type=3
  fi 
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    col name format a30
    col outline_hints format a80
    
    select name, hint as outline_hints
    from (select p.name, p.signature, p.category, row_number()
          over (partition by sd.signature, sd.category order by sd.signature) row_num,
          extractValue(value(t), '/hint') hint
    from sys.sqlobj\$data sd, $vname p,
         table(xmlsequence(extract(xmltype(sd.comp_data),
                                '/outline_data/hint'))) t
    where sd.obj_type = $type
    and p.signature = sd.signature
    and p.category = sd.category
    and p.name='$name'
    )
    order by row_num;
    $ECHO
    
    
    --select name,hint as outline_hints
    --from (select p.name, p.signature, p.category, row_number()
    --      over (partition by sd.signature, sd.category order by sd.signature) row_num,
    --      extractValue(value(t), '/hint') hint
    --from sys.sqlobj$data sd, dba_sql_profiles p,
    --     table(xmlsequence(extract(xmltype(sd.comp_data), '/outline_data/hint'))) t
    --where sd.obj_type = 1
    --and p.signature = sd.signature
    --and p.category = sd.category
    --and p.name = ('$name'))
    --order by row_num;
    
    --sql plan baseline:
    --select plan_name,plan_id,row_num,hint as outline_hints
    --from (select p.plan_name, p.signature, plan_id,row_number()
    --      over (partition by sd.signature,plan_id order by sd.signature) row_num,
    --      extractValue(value(t), '/hint') hint
    --from sys.sqlobj$data sd, dba_sql_plan_baselines p,
    --     table(xmlsequence(extract(xmltype(sd.comp_data), '/outline_data/hint'))) t
    --where sd.obj_type = 2
    --and p.signature = sd.signature
    --and p.plan_name = ('&name'))
    --order by plan_id,row_num;

!
echo "show outline hint for given sql profile or sql patch name".
exit 0
fi


################################################################################
if [ "$1" = "top_level" ]; then

  if [ "$2" = "" ]; then
    echo "ora top_level [sqlid of plsql] <bid> <eid>"
    exit 1
  fi
  
    if [ "$3" = "" -o "$4" = "" ]; then
    echo "ora top_level [sqlid] <begin_snapid> <end_snapid> (default is last two snap) "
    bid="(select max(snap_id)-1 from dba_hist_snapshot)"
    eid="(select max(snap_id)   from dba_hist_snapshot)"
   else
    bid=$3
    eid=$4
   fi  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    set linesize 200 pagesize 100
    select sql_id,
    count(distinct SQL_PLAN_HASH_VALUE) as phv_cnt,
    --sum(TIME_WAITED) as ,
    --sum(TM_DELTA_TIME),
    round(sum(TM_DELTA_DB_TIME)/1e6) as db_time,
    round(sum(TM_DELTA_CPU_TIME)/1e6) as cpu_time,
    round(sum(DELTA_READ_IO_REQUESTS)/1e3) as read_IO_requsts_k
    --round(sum(DELTA_TIME)
    from dba_hist_active_sess_history
    where TOP_LEVEL_SQL_ID='$2' 
    --and sample_time between trunc(sysdate-1) and trunc(sysdate)
    and snap_id >=$bid and snap_id <=$eid
    and sql_id<>'$2'
    group by sql_id
    order by cpu_time;
    $ECHO
    
!
exit 0
fi



################################################################################
if [ "$1" = "high_version" ]; then
#usage ora high_version 100   
  if [ "$2" = "" ]; then
    cnt=100
  else
    cnt=$2
  fi
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200    
    
    Pro Group by sql_id (having count(*)>$cnt):
    select sql_id, count(*) reasons_not_cursors
    from gv\$sql_shared_cursor 
     unpivot --column to row
     (val for reason_not_shared in( --68 items 12.2
      UNBOUND_CURSOR,SQL_TYPE_MISMATCH,OPTIMIZER_MISMATCH,OUTLINE_MISMATCH,
      STATS_ROW_MISMATCH,LITERAL_MISMATCH,FORCE_HARD_PARSE,EXPLAIN_PLAN_CURSOR,
      BUFFERED_DML_MISMATCH,PDML_ENV_MISMATCH,INST_DRTLD_MISMATCH,SLAVE_QC_MISMATCH,
      TYPECHECK_MISMATCH,AUTH_CHECK_MISMATCH,BIND_MISMATCH,DESCRIBE_MISMATCH,
      LANGUAGE_MISMATCH,TRANSLATION_MISMATCH,BIND_EQUIV_FAILURE,INSUFF_PRIVS,
      INSUFF_PRIVS_REM,REMOTE_TRANS_MISMATCH,LOGMINER_SESSION_MISMATCH,INCOMP_LTRL_MISMATCH,
      OVERLAP_TIME_MISMATCH,EDITION_MISMATCH,MV_QUERY_GEN_MISMATCH,USER_BIND_PEEK_MISMATCH,
      TYPCHK_DEP_MISMATCH,NO_TRIGGER_MISMATCH,FLASHBACK_CURSOR,ANYDATA_TRANSFORMATION,
      PDDL_ENV_MISMATCH,TOP_LEVEL_RPI_CURSOR,DIFFERENT_LONG_LENGTH,LOGICAL_STANDBY_APPLY,
      DIFF_CALL_DURN,BIND_UACS_DIFF,PLSQL_CMP_SWITCHS_DIFF,CURSOR_PARTS_MISMATCH,
      STB_OBJECT_MISMATCH,CROSSEDITION_TRIGGER_MISMATCH,PQ_SLAVE_MISMATCH,TOP_LEVEL_DDL_MISMATCH,
      MULTI_PX_MISMATCH,BIND_PEEKED_PQ_MISMATCH,MV_REWRITE_MISMATCH,ROLL_INVALID_MISMATCH,
      OPTIMIZER_MODE_MISMATCH,PX_MISMATCH,MV_STALEOBJ_MISMATCH,FLASHBACK_TABLE_MISMATCH,
      LITREP_COMP_MISMATCH,PLSQL_DEBUG,LOAD_OPTIMIZER_STATS,ACL_MISMATCH,
      FLASHBACK_ARCHIVE_MISMATCH,LOCK_USER_SCHEMA_FAILED,REMOTE_MAPPING_MISMATCH,LOAD_RUNTIME_HEAP_FAILED,
      HASH_MATCH_FAILED,PURGED_CURSOR,BIND_LENGTH_UPGRADEABLE,USE_FEEDBACK_STATS)
    )
    where val = 'Y' and inst_id=$INST
    group by sql_id having count(*)>=$cnt
    order by 2 desc;
    $ECHO
    
!
echo "instance_number=$INST"
echo "display information for reasons cursor not shared more than $cnt."
exit 0
fi



################################################################################
if [ "$1" = "feature" -o  "$1" = "features" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col table_name format a30
    col table_owner format a30 trunc
    
    spool ora_feature_$filedate.log
    
    prompt =========================================================================================
    prompt "V\$DATABASE:"
    prompt =========================================================================================
    col F_LOG format a5
    col DB_UNIQUE_NAME format a10 trunc
    col DB_ROLE format a10
    col FLASHB_ON format a10
    col OPEN_MODE format a10
    col PROT_MODE format a20
    select DB_UNIQUE_NAME,DATABASE_ROLE DB_ROLE,FORCE_LOGGING F_LOG
          ,FLASHBACK_ON FLASHB_ON,LOG_MODE,OPEN_MODE,
          GUARD_STATUS GUARD,PROTECTION_MODE PROT_MODE
    from v\$database;
    
    
    pro
    pro 
    prompt =========================================================================================
    prompt "CHARACTERSET:"
    prompt =========================================================================================
    col value format a30
    select value\$ as value from sys.props\$ where name='NLS_CHARACTERSET';

    pro
    pro    
    prompt =========================================================================================
    prompt "All DB links:"
    prompt =========================================================================================
    col owner format a20
    col db_link format a30
    col username format a20
    col host format a50
    select owner,db_link,username,host from dba_db_links;
    $ECHO

    pro
    pro    
    prompt =========================================================================================
    Prompt "Trigger(+sys +system, -other xxSYS users) by owner and event:"    
    prompt =========================================================================================
    col TRIGGERING_EVENT format a40
    
    select owner,triggering_event,count(*) 
    from dba_triggers 
    where owner not in ('EXFSYS','MDSYS','OLAPSYS','WMSYS','SYSMAN','XDB')
    group by owner,triggering_event
    order by 1;
    $ECHO

    pro
    pro    
    prompt =========================================================================================    
    Prompt "Compressed Tables ,table partitions and table subpartitions count:"
    prompt =========================================================================================
    --select * from
    --(
    select owner,'NORMAL' as table_type,count(*) from dba_tables where compression='ENABLED' group by owner order by 3;
    --union
    select table_owner,'PARTITION',count(*)  from dba_tab_partitions where compression='ENABLED' group by table_owner order by 3;
    --union
    select table_owner,'SUBPARTITION',count(*) from dba_tab_subpartitions where compression='ENABLED' group by table_owner order by 3;
    --)
    --order by owner,table_name;
    --$ECHO
    
    pro
    pro
    prompt =========================================================================================    
    Prompt "partitions(no sys) by owner,table_name(top partitions 5 by owner):"
    prompt =========================================================================================
    with tmp as 
    (
    select table_owner,table_name,count(*)  partition_cnt
    from dba_tab_partitions where table_owner not in('SYS','SYSTEM')
    group by table_owner,table_name
    )
    select table_owner,table_name, partition_cnt from 
    (select t.*,row_number() over (partition by table_owner order by partition_cnt desc ) as rn
      from tmp t)
     where rn<=5      
    order by 1,3 desc;
    $ECHO

    pro
    pro    
    prompt =========================================================================================    
    Prompt "subpartitions(no sys) by owner,table_name:"
    prompt =========================================================================================
    select table_owner,table_name,count(*) sub_partition_cnt  
    from dba_tab_subpartitions where table_owner not in('SYS','SYSTEM')
    group by table_owner,table_name
    order by 1,3;
    $ECHO

    

    pro
    pro
    prompt =========================================================================================    
    Prompt "all sql patches:"
    prompt =========================================================================================
    col description format a40
    col name format a30 
    col created format a19
    col sql_text format a30 trunc
    col status format a8
    col DESCRIPTION format a20 trunc
    set linesize 200
    select name,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
    ,status,force_matching,description,substr(sql_text,1,30)  as sql_text
    from dba_sql_patches
    order by created;
    $EChO

    pro
    pro
    prompt =========================================================================================    
    Prompt "sql profiles(recent created 20):"
    prompt =========================================================================================
    col signature format a20
    col created format a19
    col name format a30
    col sql_text format a20 trunc
    select * from
    (
    select  name ,to_char(signature) as signature
          ,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
          ,substr(sql_text,1,20) as sql_text
          ,status,force_matching
    from DBA_SQL_profiles
    order by created desc)
    where rownum<=20;
    $ECHO


    pro
    pro    
    prompt =========================================================================================   
    Prompt "sql plan baselines(recent created 20):"
    prompt =========================================================================================
    col signature format a20
    col parse_name format a10 trunc
    col plan_name format a30
    col origin format a20 trunc
    col created format a19
    --col sql_text format a30 trunc
    select * from
    (
    select parsing_schema_name as parse_name,plan_name,to_char(signature) as signature
          ,origin
          ,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
          ,substr(sql_text,1,20) as sql_text
          ,enabled,accepted,fixed
    from DBA_SQL_PLAN_BASELINES
    order by created desc)
    where rownum<=20 
    order by parse_name;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "materialized views by owner:"
    prompt =========================================================================================
    col MVIEW_NAME format a30
    col STALENESS format a10
    select owner,mview_name,refresh_mode,last_refresh_date,staleness 
    from dba_mviews
    order by owner;  
    $ECHO
    

    pro
    pro
    prompt =========================================================================================   
    Prompt "index type summary(no sys users,not normal) by owner:"
    prompt =========================================================================================
    select owner,
    index_type,count(*) 
    from dba_indexes 
    where owner not in ('SYS','EXFSYS','CTXSYS','WMSYS','MDSYS','DBSNMP','SYSMAN','SYSTEM','ORDSYS','OLAPSYS','XDB','OUTLN','ORDDATA')
    and owner not like 'APEX%'
    and index_type <>'NORMAL'
    group by  index_type,owner
    order by owner;
    $ECHO
    
    pro
    pro    
    prompt =========================================================================================    
    Prompt "table type summary(no sys users):"
    prompt =========================================================================================
    select sum(case when logging='NO' then 1 else 0 end) as nologging_cnt
          ,sum(case when iot_type like 'IOT%' then 1 else 0 end) as IOT_cnt
          ,sum(case when temporary ='Y' then 1 else 0 end) as temporary_cnt
          ,sum(case when compression ='ENABLED' then 1 else 0 end) as Normal_compressed_cnt
          ,sum(case when Partitioned ='YES' then 1 else 0 end) as partitioned_cnt
          --,sum(case when  ='ENABLED' then 1 else 0 end) as xxx_cnt
       from dba_tables 
       where owner not in ('SYS','EXFSYS','CTXSYS','WMSYS','MDSYS','DBSNMP','SYSMAN','SYSTEM','ORDSYS','OLAPSYS','XDB');

    pro
    pro
    prompt =========================================================================================       
    Prompt "external tables by owner:"
    prompt =========================================================================================
    SELECT owner ,count(*) 
    FROM dba_external_tables 
    group by owner
    order by 1,2;    
    $ECHO
    spool off        

!
exit 0
fi


################################################################################
if [ "$1" = "raw" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora raw number C30F5544 / ora raw date 78660A010D2A32 / ora raw varchar2 415045585F303530313030"
    exit 1
  fi
  
  if [ "$2" = "varchar2" ]; then
    dtype="varchar2(100)"
  else
    dtype=$2
  fi
  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set serveroutput on feedback off
    
    declare 
    v_ret $dtype;
    v_result varchar2(100);    
    begin
         dbms_stats.convert_raw_value('$3',v_ret);
         select 
         case when '$dtype'='date' then to_char(v_ret,'yyyy-mm-dd hh24:mi:ss') 
              when '$dtype'='varchar2(100)' then to_char(v_ret)
              when '$dtype'='number' then to_char(v_ret) end into v_result 
         from dual;
         dbms_output.put_line('raw data $3 convert to $dtype is: '||v_result);
    end;
    /
!
exit 0
fi

##new add method 03:
################################################################################
if [ "$1" = "sql_patch" ]; then

   if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col name format a30
    col created format a20
    col description format a40
    col sql_text format a50 trunc
    select * from (select NAME,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss'),STATUS,FORCE_MATCHING, DESCRIPTION,SQL_TEXT 
    from dba_sql_patches order by created desc) where rownum<=20;
!
    echo "ora sql_patch sql_id [monitor|bind_aware]"
    echo "ora sql_patch sql_id \"opt_param('_fix_control' '13345888:off')\""
    echo "ora sql_patch 0wqx6mfuhashb \"opt_param('_optimizer_use_feedback','false')\""
    echo "ora sql_patch <sql_id> \"parallel(4)\""
    exit 1
  fi
 
  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora sql_patch sql_id [monitor|bind_aware]"
    exit 1
  fi
  
     version=`echo "select 12345||trim(version) as ver from PRODUCT_COMPONENT_VERSION where product like 'Oracle%';" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
     v2=`echo $version|cut -c 1-2`
     v4=`echo $version|cut -c 1-4`

      
   if [ "$v2" = "11" -o  "$v4" = "12.1" ]; then
  # echo $3
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUMF "" SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;

DEF sql_id_1 = '$2';

--DEF hint_text = '$3';

--pro &&hint_text

--SET TERM OFF ECHO ON;
--SELECT TRIM(NVL(REPLACE('hint_text_2.', '"', ''''''), 'def_hint_text.')) hint_text FROM dual;
--WHENEVER SQLERROR EXIT SQL.SQLCODE;

-- trim sql_id parameter
COL sql_id NEW_V sql_id FOR A30;
SELECT TRIM('&&sql_id_1.') sql_id FROM DUAL;

VAR sql_text CLOB;
VAR sql_text2 CLOB;
EXEC :sql_text := NULL;
EXEC :sql_text2 := NULL;

pro get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv\$sqltext_with_newlines
             WHERE sql_id = TRIM('&&sql_id.')
             ORDER BY 1, 2
            )
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' '); -- removes NUL characters
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text); 
  END LOOP;
  -- if found in memory then sql_text is not null
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

col sql_text format a80
SELECT :sql_text as sql_text FROM DUAL;

-- get sql_text2 from awr(in case of sql not in memory)
DECLARE
  l_sql_text VARCHAR2(32767);
  l_clob_size NUMBER;
  l_offset NUMBER;
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT sql_text
      INTO :sql_text2
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
  -- if found in awr then sql_text2 is not null
  IF :sql_text2 IS NOT NULL THEN
    l_clob_size := NVL(DBMS_LOB.GETLENGTH(:sql_text2), 0);
    l_offset := 1;
    DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
    DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    -- store in clob as 64 character pieces 
    WHILE l_offset < l_clob_size
    LOOP
      IF l_clob_size - l_offset > 64 THEN
        l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, 64, l_offset), CHR(00), ' ');
      ELSE -- last piece
        l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, l_clob_size - l_offset + 1, l_offset), CHR(00), ' ');
      END IF;
      DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
      l_offset := l_offset + 64;
    END LOOP;
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

col sql_text_awr format a100
SELECT :sql_text2 as sql_text_awr FROM DUAL;


-- validate sql_text
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for SQL_ID &&sql_id. was not found in memory (gv\$sqltext_with_newlines) or AWR (dba_hist_sqltext).');
  END IF;
END;
/

PRO generate SQL Patch for SQL "&&sql_id." with CBO Hints : $3


-- create SQL Patch
PRO you have to connect as SYS
BEGIN
  SYS.DBMS_SQLDIAG_INTERNAL.I_CREATE_PATCH (
    sql_text    => :sql_text,
    hint_text   => q'[ $3]',
    name        => 'coe_&&sql_id.',
    category    => 'DEFAULT',
    description => q'[/*+ $3 */]'
  );
END;
/

col description format a40
col name format a30 
set linesize 200
select name,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
,status,force_matching,description,substr(sql_text,1,50)  as sql_text
from dba_sql_patches
order by created;

WHENEVER SQLERROR CONTINUE;

PRO coe_gen_sql_patch completed.

!
fi           
     
## for version 12.2+
if [ "$v4" = "12.2" -o  "$v2" = "18" -o "$v2" = "19" ]; then
    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    
    declare patch_name varchar2(30);
begin
patch_name := dbms_sqldiag.create_sql_patch(
     sql_id=>'$2',
     hint_text=>' $3 ');
end;
/
!
fi
echo ora sql_patch sql_id  hint_info
exit 0
fi


################################################################################
if [ "$1" = "sqlhc" ]; then

  if [ "$2" = "" ]; then
    echo "ora sqlhc <sqlid1> <sqlid2>..."
    exit 1
  fi
  
  if [ ! -e ora_sqlhc.sql ]; then
   echo "file ora_sqlhc.sql is missing!"
   exit 1
  fi
  
  shift
  for sqlid in $@
  do

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    prompt generate sqlhc for sql_id : $sqlid...........................
    @ora_sqlhc T $sqlid
    --prompt @sqlhc T $sqlid
    
!
done
echo "need ora_sqlhc.sql in the curret directory!"
exit 0
fi

#####################################################################################################

if [ "$1" = "tophis" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi
      
   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id[$defbid]:" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id[$defeid]:" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi
        
       if [ ${bid} -ge ${eid} ];then
          echo begin_snap_id:$bid end_snap_id:$eid  input error!
          exit 1
       fi
       else 
        bid=$3
        eid=$4 
   fi
   
   if [ "$5" = "" ]; then
     deftopn=50
     read -p "Please input top sql count[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi
   
   
### if [ "$3" = "" -o "$4" = "" ]; then
###  echo "ora tophis cpu|read|time [begin_snapid] [end_snapid](default is last two snap) "
###  bid="(select max(snap_id)-1 from dba_hist_snapshot)"
###  eid="(select max(snap_id)   from dba_hist_snapshot)"
### else
###  bid=$3
###  eid=$4
### fi   
   

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER  
    set linesize 200 pagesize 30
    set tab off
    col rn format 999
    col min_schema format a10 trunc
    col sqltext format a30 trunc
    col sql_id format a14
    col plans format 99 
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999    
    spool ora_tophis_${INST}_${bid}_${eid}_${orderby}.log
    
    with sql_stat as 
    (
     select rownum as RN,v.* from 
      (select 
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000)  as reads_k,
          sql_id,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1 
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid--(select max(snap_id)   from dba_hist_snapshot)
             and INSTANCE_NUMBER=$INST
          group by sql_id 
          order by $orderby desc 
      ) v where rownum<=$topn
    )
    select ltrim(nvl( b.sql_text, (' ** SQL Text Not Available ** '))) SqlText
           ,a.*
    from sql_stat a,(select distinct sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,50)),chr(10),''),chr(13),'') as sql_text 
                     from dba_hist_sqltext) b 
    where a.sql_id=b.sql_id
    order by rn;
    $ECHO
    
    --select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "usage: ora tophis [cpu]|<read>|<time> bid eid"
echo "Get top sql ,ordered by $orderby . Begin snap_id=$bid ; End snap_id=$eid "
echo "instance_number=$INST"
exit 0
fi



################################################################################################################
if [ "$1" = "purge" ]; then

  if [ "$2" = "" ]; then
    echo "ora purge <sqlid>"
    exit 1
  fi
  
  sqlid=$2
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    set verify off

    PRO *** before flush ***
    SELECT inst_id, loaded_versions, invalidations, address, hash_value
    FROM gv\$sqlarea WHERE sql_id = '$sqlid' ORDER BY 1;

    SELECT inst_id, child_number, plan_hash_value, executions, is_shareable
    FROM gv\$sql WHERE sql_id = '$sqlid' ORDER BY 1, 2;

    BEGIN
      FOR i IN (SELECT address, hash_value
                  FROM gv\$sqlarea WHERE sql_id = '$sqlid')
      LOOP
        SYS.DBMS_SHARED_POOL.UNKEEP(name => i.address||','||i.hash_value, flag => 'C');
        SYS.DBMS_SHARED_POOL.PURGE(name => i.address||','||i.hash_value, flag => 'C');
      END LOOP;
    END;
    /

    PRO *** after flush ***
    SELECT inst_id, loaded_versions, invalidations, address, hash_value
    FROM gv\$sqlarea WHERE sql_id = '$sqlid' ORDER BY 1;

    SELECT inst_id, child_number, plan_hash_value, executions, is_shareable
    FROM gv\$sql WHERE sql_id = '$sqlid' ORDER BY 1, 2;

!
echo "instance_number=$INST"
exit 0
fi

################################################################################
if [ "$1" = "sql_profile" -o "$1" = "coe_profile" ]; then

     if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col name format a30
    col created format a20
    col description format a40
    col sql_text format a50 trunc
    select * from 
    (select NAME,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss') as created
            ,STATUS,FORCE_MATCHING, DESCRIPTION,SQL_TEXT 
           from dba_sql_profiles order by created desc
     ) where rownum<=20;
!
    echo "ora sql_profile sql_id_1 sql_id_2 phv"
    exit 1
  fi

  if [ "$2" = "" -o  "$3" = "" -o "$4" = "" ]; then
    echo "ora sql_profile sql_id_1 sql_id_2 phv"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 
set LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUM 20 SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;
DEF original_sql_id = '$2'
DEF modified_sql_id = '$3';

WITH
p AS (
SELECT plan_hash_value
  FROM gv\$sql_plan
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND other_xml IS NOT NULL
 UNION
SELECT plan_hash_value
  FROM dba_hist_sql_plan
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND other_xml IS NOT NULL ),
m AS (
SELECT plan_hash_value,
       SUM(elapsed_time)/SUM(executions) avg_et_secs
  FROM gv\$sql
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND executions > 0
 GROUP BY
       plan_hash_value ),
a AS (
SELECT plan_hash_value,
       SUM(elapsed_time_total)/SUM(executions_total) avg_et_secs
  FROM dba_hist_sqlstat
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND executions_total > 0
 GROUP BY
       plan_hash_value )
SELECT p.plan_hash_value,
       ROUND(NVL(m.avg_et_secs, a.avg_et_secs)/1e6, 3) avg_et_secs
  FROM p, m, a
 WHERE p.plan_hash_value = m.plan_hash_value(+)
   AND p.plan_hash_value = a.plan_hash_value(+)
 ORDER BY
       avg_et_secs NULLS LAST;

DEF plan_hash_value = '$4';

WHENEVER SQLERROR EXIT SQL.SQLCODE;
SET TERM OFF ECHO ON;

-- trim parameters
COL original_sql_id NEW_V original_sql_id FOR A30;
COL modified_sql_id NEW_V modified_sql_id FOR A30;
COL plan_hash_value NEW_V plan_hash_value FOR A30;
SELECT TRIM('&&original_sql_id.') original_sql_id, TRIM('&&modified_sql_id.') modified_sql_id, 
TRIM('&&plan_hash_value.') plan_hash_value FROM DUAL;

-- open log file
--SPO coe_load_sql_profile_&&original_sql_id..log;
--GET coe_load_sql_profile.log;
--.

-- get user
COL connected_user NEW_V connected_user FOR A30;
SELECT USER connected_user FROM DUAL;

VAR sql_text CLOB;
VAR other_xml CLOB;
VAR signature NUMBER;
VAR name VARCHAR2(30);

EXEC :sql_text := NULL;
EXEC :other_xml := NULL;
EXEC :signature := NULL;
EXEC :name := NULL;

-- get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv\$sqltext_with_newlines
             WHERE sql_id = TRIM('&&original_sql_id.')
             ORDER BY 1, 2)
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' ');
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
  END LOOP;
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT REPLACE(sql_text, CHR(00), ' ')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&original_sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- sql_text as found
col sql_text format a150
SELECT :sql_text as sql_text FROM DUAL;

-- check is sql_text for original sql is available
SET TERM ON;
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for original SQL_ID &&original_sql_id. was not found in memory (gv\$sqltext_with_newlines) or AWR (dba_hist_sqltext).');
  END IF;
END;
/
SET TERM OFF;

-- get other_xml from memory
BEGIN
  FOR i IN (SELECT other_xml
              FROM gv\$sql_plan
             WHERE sql_id = TRIM('&&modified_sql_id.')
               AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'))
               AND other_xml IS NOT NULL
             ORDER BY
                   child_number, id)
  LOOP
    :other_xml := i.other_xml;
    EXIT; -- 1st
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting modified other_xml from memory: '||SQLERRM);
    :other_xml := NULL;
END;
/

-- get other_xml from awr
BEGIN
  IF :other_xml IS NULL OR NVL(DBMS_LOB.GETLENGTH(:other_xml), 0) = 0 THEN
    FOR i IN (SELECT other_xml
                FROM dba_hist_sql_plan
               WHERE sql_id = TRIM('&&modified_sql_id.')
                 AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'))
                 AND other_xml IS NOT NULL
               ORDER BY
                     id)
    LOOP
      :other_xml := i.other_xml;
      EXIT; -- 1st
    END LOOP;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting modified other_xml from awr: '||SQLERRM);
    :other_xml := NULL;
END;
/

-- other_xml as found
col other_xml format a150
SELECT :other_xml as other_xml FROM DUAL;

-- validate other_xml
SET TERM ON;
BEGIN
  IF :other_xml IS NULL THEN
    RAISE_APPLICATION_ERROR(-20101, 'PLAN for modified SQL_ID &&modified_sql_id. and PHV &&plan_hash_value. was not found in memory (gv\$sql_plan) or AWR (dba_hist_sql_plan).');
  END IF;
END;
/

SET ECHO OFF;
DECLARE
  h SYS.SQLPROF_ATTR := SYS.SQLPROF_ATTR ();
  idx INTEGER := 0;
  l_pos NUMBER;
  l_hint VARCHAR2(32767);
  description VARCHAR2(500);

  PROCEDURE add_hint (p_hint IN VARCHAR2)
  IS
  BEGIN
    idx := idx + 1;
    DBMS_OUTPUT.PUT_LINE(LPAD(idx, 4, '0')||' '||p_hint);
    h.EXTEND;
    h(idx) := p_hint;
  END add_hint;

BEGIN
  add_hint('BEGIN_OUTLINE_DATA');
  FOR i IN (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                   SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hint
              FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(:other_xml), '/*/outline_data/hint'))) d)
  LOOP
    l_hint := i.hint;
    WHILE NVL(LENGTH(l_hint), 0) > 0
    LOOP
      IF LENGTH(l_hint) <= 500 THEN
        add_hint(l_hint);
        l_hint := NULL;
      ELSE
        l_pos := INSTR(SUBSTR(l_hint, 1, 500), ' ', -1);
        add_hint(SUBSTR(l_hint, 1, l_pos));
        l_hint := '   '||SUBSTR(l_hint, l_pos);
      END IF;
    END LOOP;
  END LOOP;
  add_hint('END_OUTLINE_DATA');

  :signature := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(:sql_text);
  :name := UPPER(TRIM('&&original_sql_id.'))||'_'||TRIM('&&plan_hash_value.');
  description := UPPER('original:'||TRIM('&&original_sql_id.')||' modified:'||TRIM('&&modified_sql_id.')||' phv:'||TRIM('&&plan_hash_value.')||' signature:'||:signature||' created by coe_load_sql_profile.sql');

  -- create custom sql profile for original sql using plan from modified sql
  DBMS_SQLTUNE.IMPORT_SQL_PROFILE (
    sql_text    => :sql_text, -- original sql
    profile     => h, -- plan from modified sql
    name        => :name,
    description => description,
    category    => 'DEFAULT',
    validate    => TRUE,
    replace     => TRUE,
    force_match => TRUE /* TRUE:FORCE (match even when different literals in SQL). FALSE:EXACT (similar to CURSOR_SHARING) */ 
    );

END;
/
    -- profile_name
    COL profile_name NEW_V profile_name FOR A30;
    SELECT :name profile_name FROM DUAL;


    SELECT signature, name, category, type, status,force_matching
      FROM dba_sql_profiles WHERE name = :name;
      
    col description format a130
    SELECT description
      FROM dba_sql_profiles WHERE name = :name;

!
exit 0
fi


################################################################################
if [ "$1" = "dbtime" -o "$1" = "db_time" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set verify off
    
    pro db time by day:
    define statname='DB time'
    set linesize 200 pagesize 1000
    set trims on
    spool ora_dbtime_$filedate.log
    
    with stat_time as
    (   select instance_number,begin_snap_id, end_snap_id,
        snap_begin_time, snap_end_time,
        round(interval_min) as interval_min,
        round(lag_value/60/1000000) as stat_time_min ,
        round(lag_value/60/1000000/interval_min) as stat_time_per_sec
        from
        (
        select sp.instance_number,
        sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
        sp.snap_id   as end_snap_id,   to_char(end_interval_time-1/24/60,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, --1 minute ahead for 00:00:xx,it belongs to prev day
        (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
        value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
        sy.stat_name
        from dba_hist_snapshot sp, dba_hist_sys_time_model sy
        where sp.snap_id=sy.snap_id
          and sp.instance_number=sy.instance_number
          and sy.stat_name='&statname'
        ) where   nvl(lag_value,0)>0
    )
select instance_number,substr(snap_end_time,1,10) as stat_time_day,sum(stat_time_min) as total_dbtime_day 
from stat_time group by instance_number,substr(snap_end_time,1,10)
order by stat_time_day desc;
$ECHO

Pro top 20 dbtime :
with stat_time as
(
select instance_number,begin_snap_id, end_snap_id,
snap_begin_time, snap_end_time,
round(interval_min) as interval_min,
round(lag_value/60/1000000,2) as DB_time_min ,
round(lag_value/60/1000000/interval_min,2) as DB_time_per_sec
from
(
select sp.instance_number,
sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, 
(cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
sy.stat_name
from dba_hist_snapshot sp, dba_hist_sys_time_model sy
where sp.snap_id=sy.snap_id
  and sp.instance_number=sy.instance_number
  and sy.stat_name='&statname'
) where   nvl(lag_value,0)>0)
select * from 
(
select a.* ,row_number() over ( partition by instance_number order by DB_time_per_sec desc) as rank
 from stat_time a
) where rank<=20;
$ECHO
spool off

!
echo "show dbtime by day and top 10 by snapshots"
exit 0
fi

################################################################################
if [ "$1" = "sysmetric" ]; then

#AIX not support date  -d
  if [ "$2" = "" ]; then
     #echo "ora sysmetric \"`date +"%Y/%m/%d %H:%M" -d "-1hour"`\" 30"
     echo "ora sysmetric \"`date +"%Y/%m/%d %H:%M"`\" 30"
    exit 1
  fi
  
   if [ "$3" = "" ]; then
    defdur=30
   else 
     defdur=$3
  fi
  
  btime=$2

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col inst format 99
    col exec_p_s format 999999
    col uc_s format 99999
    col ut_s format 99999
    col start_time format a20
    
    spool ora_sysmetirc_$filedate.log
     
select instance_number as inst,
       to_char(begin_time,'mmdd hh24miss')as start_time,--end_time,
       round(avg_act_sess) as act_sess,
       round(avg_syn_read) as syn_read,
       round(exec_s) as exec_p_s ,
       round(io_m_s,1) as io_m_s,
       round(iops) as iops,
       round(logon_s,1) as logon_s,
       round(net_vol_s) as net_s,
       round(phy_r_s) as phy_r_s,
       round(phy_w_s) as phy_w_s,
       round(redo_s) as redo_s,
       round(sql_res,4) as sql_res,
       round(user_call_s) as uc_s,
       round(user_trx_s) as ut_s
from 
(select instance_number,begin_time,end_time,metric_name,value 
 from DBA_HIST_SYSMETRIC_HISTORY
where begin_time > = to_date('$btime','yyyy/mm/dd hh24:mi') 
  and  begin_time <= to_date('$btime','yyyy/mm/dd hh24:mi')+$defdur/60/24
  and instance_number=$INST
  and metric_name in 
('Average Active Sessions',
'Average Synchronous Single-Block Read Latency',
'Executions Per Sec',
'I/O Megabytes per Second',
'I/O Requests per Second',
'Logons Per Sec',
'Network Traffic Volume Per Sec',
'Physical Reads Per Sec',
'Physical Writes Per Sec',
'Redo Generated Per Sec',
'SQL Service Response Time',
'User Calls Per Sec',
'User Transaction Per Sec')
)
pivot 
(max(value) for metric_name in 
('Average Active Sessions' as avg_act_sess,
'Average Synchronous Single-Block Read Latency' as avg_syn_read,
'Executions Per Sec' as exec_s,
'I/O Megabytes per Second' as IO_M_s,
'I/O Requests per Second' as IOPS,
'Logons Per Sec' as logon_s,
'Network Traffic Volume Per Sec' as net_vol_s,
'Physical Reads Per Sec' as PHY_R_s,
'Physical Writes Per Sec'as phy_w_s,
'Redo Generated Per Sec' as redo_s,
'SQL Service Response Time' as sql_res,
'User Calls Per Sec'as user_call_s,
'User Transaction Per Sec'as user_trx_s)
) order by 1,2;
$ECHO
spool off

!
echo "instance_number=$INST"
exit 0
fi


################################################################################
if [ "$1" = "recover" -o "$1" = "recover_state" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 100  
alter session set NLS_DATE_FORMAT='DD-MON-YYYY HH24:MI:SS';  
select usn,
       state,
       undoblockstotal "Total",
       undoblocksdone "Done",
       undoblockstotal - undoblocksdone "ToDo",
       decode(cputime, 0, 'unknown', sysdate + (((undoblockstotal - undoblocksdone) / (undoblocksdone / cputime)) / 86400)) "Estimated time to complete" 
from gv\$fast_start_transactions;
$ECHO

!
exit 0
fi



################################################################################
if [ "$1" = "ddl" ]; then

  ##if [ "$2" = "" -o "$3" = ""  ]; then
  ##  echo "ora ddl owner object_name object_type"
  ##  exit 1
  ##fi
  
    if [ "$2" = ""  ]; then
      read -p "Please input object_name:" name
       if [ -z "${name}" ];then
       echo "No input,exit!"
       exit 1
       fi
    else
        name=$2
    fi
     
   if [ "$3" = ""  ]; then    
    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_objects 
     where object_name=upper('$name') and object_type not like '%PARTITION' and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "Object_name $name not found in any schema,please check again!"
       exit 1
    fi
   read -p "Please input object_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
       owner=$defowner
    fi
   else 
      owner=$3   
  fi
  
  #owner=$2
  #name=$3
  
  ##type=$4
  
  if [ "$4" = ""  ]; then
   
   deftype=`echo "select trim(12345||LISTAGG (object_type,',') WITHIN GROUP (ORDER BY null)) AS obj_type from dba_objects 
          where owner=upper('$owner') and object_type not like '%PARTITION' and object_name=upper('$name') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
   if [ -z "${deftype}" ];then
      echo "object $owner.$name not found,please check again!"
      exit 1
   fi
   
   read -p "Please input object_type,default is [$deftype]:" type
   if [ -z "${type}" ];then
        type=$deftype
   fi
  else 
   type=$4   
  fi
  

  
  echo DDL of $owner.$name TYPE is : $type

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 600 pagesize 0
    set trims on
    set long 99999999
    set feedback off
    col a for a600 wrapped word
    
    spool ora_DDL_${type}_${owner}_${name}.log

    begin
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'STORAGE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'TABLESPACE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'SEGMENT_ATTRIBUTES', false);
       DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'PRETTY',true);
    end;
    /
    select dbms_metadata.get_ddl(upper('$type'),upper('$name'),upper('$owner'))||';' a from dual;

    spool off

!
## ^^ upper
   #if [ "${type^^}" = "TABLE" ]; then
   if [ "${type}" = "table" -o "${type}" = "TABLE" ]; then
   
   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 600 pagesize 0
    set trims on
    set long 99999999
    set feedback off
    col a for a600 wrapped word
    
    spool ora_DDL_${type}_${owner}_${name}.log append

    begin
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'STORAGE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'TABLESPACE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'SEGMENT_ATTRIBUTES', false);
       DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'PRETTY',true);
    end;
    /
    select dbms_metadata.get_ddl('INDEX',index_name,upper('$owner'))||';' a 
    from dba_indexes where table_name=upper('$name') and owner=upper('$owner')
    ;

    spool off
!
   fi
   
   
exit 0
fi


################################################################################
if [ "$1" = "undo" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    col inst_id format a7
    col TABLESPACE_NAME format a20 trunc
    col owner format a20 trunc
    col SEGMENT_NAME format a30
    col status format a7
    
    SELECT A.INSTANCE_NUM as inst_id,
      A.TABLESPACE_NAME ,
       A.OWNER,
       --A.SEGMENT_NAME ROLL_NAME,
       --A.INITIAL_EXTENT,
       A.SEGMENT_NAME,
      -- A.SEGMENT_ID,
       --A.FILE_ID,
      -- A.BLOCK_ID,
       A.status,
       round(B.BYTES/1024/1024) as size_M,
       B.EXTENTS EXTENTS,
       D.SHRINKS SHRINKS,
       D.WRAPS WRAPS,
       D.OPTSIZE 
  FROM DBA_ROLLBACK_SEGS A
  LEFT OUTER JOIN DBA_SEGMENTS B
    ON A.SEGMENT_NAME = B.SEGMENT_NAME
  LEFT OUTER JOIN V\$ROLLNAME C
    ON A.SEGMENT_NAME = C.NAME
  LEFT OUTER JOIN V\$ROLLSTAT D
    ON C.USN = D.USN
 ORDER BY A.INSTANCE_NUM, A.TABLESPACE_NAME, A.SEGMENT_NAME;
 $ECHO

!
exit 0
fi



#CURDATE=`date +"%Y%m%d"`
#echo $CURDATE

################################################################################
if [ "$1" = "redo" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    --set sqlnumber off : no use for -e
    
col h00 format 999
col h01 format 999
col h02 format 999
col h03 format 999
col h04 format 999
col h05 format 999
col h06 format 999
col h07 format 999
col h08 format 999
col h09 format 999
col h10 format 999
col h11 format 999
col h12 format 999
col h13 format 999
col h14 format 999
col h15 format 999
col h16 format 999
col h17 format 999
col h18 format 999
col h19 format 999
col h20 format 999
col h21 format 999
col h22 format 999
col h23 format 999
spool ora_redo_$filedate.log
PRO redo log swith count by hour:
col day format a5
col weekday format a3
col total format 9999
col inst_id format 9999
SELECT  a.inst_id, SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH:MI:SS'),1,5)  as  Day,TO_CHAR (first_time, 'Dy') as weekday,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'00',1,0)) H00,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'01',1,0)) H01, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'02',1,0)) H02,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'03',1,0)) H03,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'04',1,0)) H04,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'05',1,0)) H05,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'06',1,0)) H06,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'07',1,0)) H07,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'08',1,0)) H08,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'09',1,0)) H09,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'10',1,0)) H10,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'11',1,0)) H11, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'12',1,0)) H12,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'13',1,0)) H13, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'14',1,0)) H14,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'15',1,0)) H15, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'16',1,0)) H16, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'17',1,0)) H17, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'18',1,0)) H18, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'19',1,0)) H19, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'20',1,0)) H20, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'21',1,0)) H21,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'22',1,0)) H22, 
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'23',1,0)) H23, 
       COUNT(*) TOTAL 
FROM gv\$log_history  a  
 WHERE first_time>=TO_CHAR(sysdate-30) and thread# = inst_id
    group by a.inst_id,         
 SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH:MI:SS'),1,5),TO_CHAR (first_time, 'Dy')
order by 1,2 ;
$ECHO

PRO redo log file info:
col status format a8
col member format a60 
SELECT 
       a.THREAD#,
       a.group#,
       a.SEQUENCE#,
       round(bytes / 1024 / 1024) size_m,
       a.status,
       a.ARCHIVED,
       a.MEMBERS,
       b.member,
       --TO_CHAR(listagg(b.MEMBER,',') within group(order by MEMBER))  MEMBER,
       b.type
FROM   gv\$log     a,
       gv\$logfile b
WHERE  b.GROUP# = a.GROUP#
AND    a.THREAD# = b.INST_ID
order by 1,2;
$ECHO
spool off

--rac: inst_id vs thread# ?
--Pro get log_switch_interval_s in recent 2 days
--with tmp as
--(select * from 
--    (
--    select inst_id,thread#,sequence#,first_time,
--    lag(first_time) over (partition by inst_id order by first_time desc) as next_time
--    from gv\$log_history a where first_time>sysdate-2
--    --order by first_time desc
--    ) 
--    where --rownum<=100 and 
--          next_time is not null 
--)
--select inst_id,thread#,sequence#,first_time,next_time,(next_time-first_time)*60*60*24 log_switch_interval_s
--from tmp order by inst_id,first_time;

!
exit 0
fi


################################################################################
if [ "$1" = "seq" -o "$1" = "sequence" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    col sequence_owner format a30
    col sequence_name format a30
    
    spool ora_seq_$filedate.log
    
    select sequence_owner,sequence_name,order_flag,cache_size 
    from dba_sequences
    where sequence_owner not in ('SYS','SYSTEM','MDSYS','OLAPSYS','SYSMAN','WMSYS','XDB','ORDDATA')
    and (order_flag='Y' or cache_size<=20)
    order by order_flag,sequence_owner,sequence_name;
    $ECHO
    spool off

!
exit 0
fi


################################################################################
if [ "$1" = "job" -o  "$1" = "jobs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 20
    set linesize 200
    
    col schema_user format a30
    col interval format a30
    col what format a50 trunc
    
    SELECT  instance,schema_user,next_date,failures,broken,interval,what
    FROM  dba_jobs
    ORDER BY schema_user;
    

col job_action format a30 trunc
col program_owner format a30
col program_name format a25 trunc
col repeat_interval format a20 
col interval format a30
col job_creator format a10 trunc
col owner format a10 trunc
col job_name format a10 trunc
col spid format a5
col job_state format a8 trunc
spool ora_job_$filedate.log

SELECT --j.JOB_CREATOR,
       j.OWNER,
       j.job_name,
       j.state job_STATE,
       DECODE(J.STATE, 'RUNNING', 'Y', 'N') is_running,
       --j.job_type,
       --j.job_action,
       --j.JOB_STYLE,
       --j.PROGRAM_OWNER,
       j.PROGRAM_NAME,
       --j.schedule_type,
       j.repeat_interval,
       --TO_CHAR(j.start_date, 'YYYY-MM-DD HH24:mi:ss') start_date,
       --TO_CHAR(j.end_date, 'YYYY-MM-DD HH24:mi:ss') end_date,
       TO_CHAR(J.NEXT_RUN_DATE, 'YYYY-MM-DD HH24:mi:ss') NEXT_RUN_DATE,
       TO_CHAR(J.last_start_date, 'YYYY-MM-DD HH24:mi:ss') last_start_date,
       --(J.LAST_RUN_DURATION) LAST_RUN_DURATION, 
       j.run_count,
       --j.NUMBER_OF_ARGUMENTS,
       j.ENABLED,
       --j.AUTO_DROP,
       --j.max_run_duration,
       --j.max_failures,
       --j.max_runs,
       --j.LOGGING_LEVEL,
       --j.SYSTEM is_systemjob,
       --j.comments,
       RJ.running_instance as inst_id,
       --RJ.cpu_used,
       --B.username,
       B.SID,
       B.SERIAL#,
       --(SELECT nb.spid FROM gv\$process nb WHERE nb.ADDR = b.SADDR) spid,
       b.STATUS
       --B.COMMAND,
       --B.LOGON_TIME
       --,B.OSUSER
  FROM dba_scheduler_jobs j
  LEFT OUTER JOIN dba_scheduler_running_jobs rj
    ON j.JOB_NAME = rj.JOB_NAME
  LEFT OUTER JOIN gv\$session b
    ON (rj.session_id = b.SID AND  rj.RUNNING_INSTANCE = b.INST_ID)
ORDER BY b.INST_ID, j.STATE, j.owner, j.JOB_NAME;
$ECHO
spool off

!
exit 0
fi


##############################################################################
if [ "$1" = "fulltext" -o "$1" = "full_text" ]; then
## spool to sqltext_$2.sql

  if [ "$2" = "" ]; then
    echo "ora fulltext <sql_id>"
    exit 1
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set serveroutput on size unlimited
    set feedback off verify off
    set trim off
    set linesize 180
    def sql_id=$2

    COL sql_id NEW_VALUE get_sql_id

    SELECT sql_id
      FROM gv\$sqlarea
     WHERE sql_id = TRIM('&sql_id')
     UNION
    SELECT sql_id
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&sql_id');
     
    VAR get_sql_id VARCHAR2(13);
    EXEC :get_sql_id := '&get_sql_id';

    --SET TERM ON;
    WHENEVER SQLERROR EXIT SQL.SQLCODE;

    BEGIN
      IF '&get_sql_id' IS NULL THEN
          RAISE_APPLICATION_ERROR(-20200, 'SQL_ID &sql_id not found in memory nor in AWR.');
      END IF;
    END;
    /

    --no error, sql_id must exist in awr or memory!
    spool ora_sqltext_&sql_id..log

    declare
      l_sql_text CLOB ;
      l_sql_id varchar2(13);
      l_pos NUMBER;
    BEGIN 
      l_sql_id := '&sql_id';
      select nvl((select sql_text from dba_hist_sqltext where sql_id=l_sql_id),'NOT_IN_AWR') 
           into l_sql_text from dual;
      
      if l_sql_text='NOT_IN_AWR' then
        select SQL_FULLTEXT into l_sql_text from gv\$sql where sql_id=l_sql_id and rownum=1;
      end if;
           
      --only chr(10) found in sql text. no chr(13)
      WHILE NVL(LENGTH(l_sql_text), 0) > 0
      LOOP
        l_pos := INSTR(l_sql_text, CHR(10));
        --DBMS_OUTPUT.PUT_LINE('position:'||l_pos);
        IF l_pos > 0 THEN
          DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));
          l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        ELSE
          DBMS_OUTPUT.PUT_LINE(l_sql_text);
          l_sql_text := NULL;
        END IF;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        --cu32d197864an
        --select sql_id,length(sql_text) from dba_hist_sqltext where length(sql_text)>32767 and instr(sql_text,chr(10))=0;
        DBMS_OUTPUT.PUT_LINE('sql length more than 32767 and no chr(10) in entire sql text.use fulltext_long.sql');
    END;
    /
    spool off

!

exit 0
fi


#####################################################################################################

if [ "$1" = "text2sqlid" ]; then
#use  "" for text ; only find in first 1000 char ; use double ' replace single '

  if [ "$2" = "" ]; then
    echo "ora text2sqlid "piece of sql text""
    exit 1
  fi
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600
    col sql_text format a150 trunc
    col sql_id format a14
    
    select *
    from
    (select
      'sqlarea' as sql_loc  , sql_id  
    , to_char(substr(sql_text,1,200)) as sql_text
    from
      gv\$sqlarea
    where
      upper(SQL_TEXT) like upper('%$2%')
      and SQL_TEXT not like '%SQL_TEXT%'
    union 
    select
      'sql_his'  , sql_id    
    , to_char(substr(sql_text,1,200))
    from
     dba_hist_sqltext 
    where
     upper(SQL_TEXT) like upper('%$2%')
     --and SQL_TEXT not like '%SQL_TEXT%' 
    ) where rownum<=100;
    $ECHO
    
!
echo "only random 100 listed"
  exit 0
fi


###############################################################################

if [ "$1" = "ashevent" ]; then
## top n event for every sample;recent 10 minutes

  if [ "$2" = "" ]; then
    dur=10
  else 
    dur=$2
  fi

  if [ "$3" = "" ]; then
    rn=2
  else 
    rn=$3
  fi
  


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set tab      off
    set linesize 220

    col sample_time format a25
    col event format a50
    spool ora_ashevent_$filedate.log
    --BREAK ON inst_id
    
    prompt top $rn events by sample_time in recent $dur minutes
    
     with tmp_ash as
    ( select to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') as sample_time,nvl(event,'ON CPU') as event,count(*) cnt
           from gv\$active_session_history
           where --event is not null and
                  sample_time>sysdate - $dur/24/60 --recent 10 minutes
                  and inst_id=$INST
        group by sample_time,event
    ) 
    select * from 
    (
    select sample_time,event,cnt,
           row_number() over (partition by sample_time order by cnt desc) rn
    from tmp_ash
    ) where rn<=$rn
    order by sample_time,rn;
    $ECHO
    spool off

!
echo "instance_number=$INST"
echo "active_session_history recent 10 minutes,top $rn events,group by sqmple_time"
echo "ora ashevent (recent) $dur minutes ,top $rn event."
exit 0
fi



###############################################################################

if [ "$1" = "dashevent" ]; then

  if [ "$2" = "" ]; then
    #echo "ora dashevent \"`date +"%Y/%m/%d %H:%M" -d "-2hour"`\" 20 2"
    echo "ora dashevent \"`date +"%Y/%m/%d %H:%M"`\" 20 2"
   exit 1
  fi
  
  if [ "$3" = "" ]; then
    dur=20
  else 
    dur=$3
  fi
  
  if [ "$4" = "" ]; then
    rn=2
  else 
    rn=$4
  fi
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set tab      off
    set linesize 150

    col sample_time format a25
    col event format a50
    spool ora_dashevent_$filedate.log
      
     with tmp_ash as
    ( select to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') as sample_time,nvl(event,'ON CPU') as event,count(*) cnt
           from dba_hist_active_sess_history
           where --event is not null and
                  sample_time>=to_date('$2','yyyy/mm/dd hh24:mi') and
                  sample_time<=to_date('$2','yyyy/mm/dd hh24:mi') + $dur/24/60                 
                  and INSTANCE_NUMBER=$INST
        group by sample_time,event
    ) 
    select * from 
    (
    select sample_time,event,cnt,
           row_number() over (partition by sample_time order by cnt desc) rn
    from tmp_ash
    ) where rn<=$rn
    order by sample_time,rn;
    $ECHO
    spool off

!
echo "instance_number=$INST"
echo "Usage: ora dashevent \"`date +"%Y/%m/%d %H:%M"`\" 20 2"
echo "dba_hist_active_sess_history from $2 last for $dur minutes,top $rn events,group by sqmple_time"
#echo "ora dashevent $2"
exit 0
fi

###############################################################################

if [ "$1" = "ashsessions" -o "$1" = "ashcnt" ]; then

# if [ "$2" = "" ]; then
#   echo "ora ashcnt 30"
#   echo "calc total active sessions group by sample_time(v\$active_session_histoy) recent [30] min"
#   exit 1
# fi
 
  if [ "$3" = "" ]; then
    dur=30
  else 
    dur=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 300
    set tab      off
    set linesize 220
    
    spool ora_ashcnt_$filedate.log

    col sample_time format a25
    col event format a60
    --BREAK ON sample_time skip 1
    
    Pro group by seconds:
    select inst_id,to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') as sample_time
        ,count(*) active_sess_count
    from gv\$active_session_history
    where sample_time >= sysdate- $dur/24/60 and inst_id=$INST
    group by inst_id,to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') 
    order by 1,2;
    $ECHO
    
    $DEFNODISP Pro group by minutes:
    $DEFNODISP select inst_id,to_char(sample_time,'yyyy-mm-dd hh24:mi') as sample_time
    $DEFNODISP     ,count(*) active_sess_count
    $DEFNODISP from gv\$active_session_history
    $DEFNODISP where sample_time >= sysdate- $dur/24/60 and inst_id=$INST
    $DEFNODISP group by inst_id,to_char(sample_time,'yyyy-mm-dd hh24:mi') 
    $DEFNODISP order by 1,2;
    $DEFNODISP $ECHO
    
    spool off

!
echo "instance_number=$INST"
echo "sample_time, count() from active_session_history for recent $dur mins group by sample_time"
exit 0
fi


###############################################################################

if [ "$1" = "dashsessions" -o "$1" = "dashcnt" ]; then

 if [ "$2" = "" ]; then
   #echo "ora dashcnt yyyymmdd-hh24mi [30]"
   #echo "ora dashcnt \"`date +"%Y/%m/%d %H:%M" -d "-1hour"`\" 30"
   echo "ora dashcnt \"`date +"%Y/%m/%d %H:%M"`\" 30"
   echo "calc total active sessions group by sample_time"
   exit 1
 fi
 
  if [ "$3" = "" ]; then
    dur=30
  else 
    dur=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set tab      off
    set linesize 220

    col sample_time format a25
    col event format a60
    --BREAK ON sample_time skip 1
    spool ora_dashcnt_$filedate.log
    
    Pro group by seconds:
    select instance_number,to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') as sample_time
        ,count(*) active_sess_count
    from dba_hist_active_sess_history
    where sample_time between to_date('$2'||'00','yyyy/mm/dd hh24:mi:ss') 
                          and to_date('$2'||'59','yyyy/mm/dd hh24:mi:ss')+$dur/24/60
          and instance_number=$INST
    group by instance_number,to_char(sample_time,'yyyy-mm-dd hh24:mi:ss') 
    order by 1,2;
    $ECHO
    
    Pro group by minutes:
    select instance_number,to_char(sample_time,'yyyy-mm-dd hh24:mi') as sample_time
        ,count(*) active_sess_count
    from dba_hist_active_sess_history
    where sample_time between to_date('$2'||'00','yyyy/mm/dd hh24:mi:ss') 
                          and to_date('$2'||'59','yyyy/mm/dd hh24:mi:ss')+$dur/24/60
          and instance_number=$INST
    group by instance_number,to_char(sample_time,'yyyy-mm-dd hh24:mi') 
    order by 1,2;
    $ECHO
    
    spool off

!
echo "instance_number=$INST"
echo "Usage: ora dashcnt \"`date +"%Y/%m/%d %H:%M"`\" 30"
echo "calc count from dba_hist_active_sess_history group by sample_time"
exit 0
fi

###############################################################################################

if [ "$1" = "sql" ] ; then

    #if [ "$2" = "" ]; then
    #  echo "ora sql <sqlid> [typical]|<adv> "
    #  exit 1
    #fi
    
     if [ "$2" = ""  ]; then
      read -p "Please input sqlid:" sqlid
       if [ -z "${sqlid}" ];then
         echo "No input,exit!"
         exit 1
       fi
    else
        sqlid=$2
    fi
    
    
     if [ "$3" = "adv" ]; then
      format=advanced
     else
      format=typical
    fi
  
     #sqlid=$2
     
     sqlplus -s /NOLOG << !  | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set verify off
    set feedback off;
    set linesize 150 pagesize 35
    spool ora_SQL_${sqlid}_${filedate}.log
    
    col sql_id format a13
    
    
    $DEFNODISP col sql_text_100 format a100
    $DEFNODISP col sql_text_800 format a100
    $DEFNODISP 
    $DEFNODISP pro sql_text from gv\$sql:
    $DEFNODISP 
    $DEFNODISP select substr(sql_text,1,100) as sql_text_100 from gv\$sql where sql_id='$sqlid' and rownum<=1;
    $DEFNODISP pro
    $DEFNODISP 
    $DEFNODISP 
    $DEFNODISP pro sql_text from dba_hist_sqlstat:
    $DEFNODISP select substr(sql_text,1,800) as sql_text_800 from dba_hist_sqltext where sql_id='$sqlid' and rownum<=1;  
    

    PRO
    PRO DBA_HIST_SQLSTAT detail(recent 15 days):
    PRO 
      
     col  snap_id format 9999999
     col inst format 99
     col cpu_s format 999999
     col execs format 99999999
     col DISK_R format 999999999
     col io_s  format 999999 
     col ms_pe format 99999999 
     col snap_date format a20
     select 
      a.snap_id,
      to_char(b.end_interval_time,'yyyymmdd hh24:mi') as snap_date,
      a.instance_number as inst,
      plan_hash_value as phv,
      round((cpu_time_delta)/1e6)  as cpu_s,
      (executions_delta) as execs,
      --BUFFER_GETS_DELTA as buffs,
      --ROWS_PROCESSED_DELTA as rows_processed,
      round((BUFFER_GETS_DELTA)/greatest((executions_delta),1))  as Buf_pe,
      round((ROWS_PROCESSED_DELTA)/greatest((executions_delta),1),1)  as Row_pe,
      --round((BUFFER_GETS_DELTA)/greatest((ROWS_PROCESSED_DELTA ),1),1) as buf_per_row,
      case when (ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1) <1 
           then round((ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1),2) 
           else round((ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1)) end  as ms_pe,
      round((DISK_READS_DELTA))  as DISK_R,
      round((IOWAIT_DELTA)/1e6)  as IO_s,
      round((APWAIT_DELTA)/1e3)  as App_ms
      --round((CCWAIT_DELTA)/1e3)  as ConC_ms,
      --round((CLWAIT_DELTA)/1e3)  as CLu_ms
      --round((PLSEXEC_TIME_DELTA)/1e3)  as PLSQL_ms
      --round((JAVEXEC_TIME_DELTA)/1e3)  as JAVA_ms,
      --round((CPU_TIME_DELTA))  as CPU_TIME_D,
      --round((DIRECT_WRITES_DELTA))  as DIRECT_W,
      --round((END_OF_FETCH_COUNT_DELTA))  as END_FET_cnt,
      --round((FETCHES_DELTA))  as FETCHES,
      --round((INVALIDATIONS_DELTA))  as INVALID,
      --round((IO_INTERCONNECT_BYTES_DELTA))  as IO_INTERCO,
      --round((IO_OFFLOAD_ELIG_BYTES_DELTA))  as IO_OFFLOAD_elig,
      --round((IO_OFFLOAD_RETURN_BYTES_DELTA))  as IO_OFFLOAD_return,
      --round((LOADS_DELTA))  as LOADS,
      --round((OPTIMIZED_PHYSICAL_READS_DELTA))  as OPT_phy_rds,
      --round((PARSE_CALLS_DELTA))  as PARSE_CALL,
      --round((PHYSICAL_READ_BYTES_DELTA))  as PHYSICAL_RB,
      --round((PHYSICAL_READ_REQUESTS_DELTA))  as PHY_R_Req,
      --round((PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
      --round((PHYSICAL_WRITE_REQUESTS_DELTA))  as PHY_W_Req,
      ---round((PX_SERVERS_EXECS_DELTA))  as PX_Svr,
      ---round((SORTS_DELTA))  as SORTS
       from dba_hist_sqlstat a,dba_hist_snapshot b
       where sql_id='$sqlid' and a.snap_id=b.snap_id and a.instance_number=b.instance_number
             and b.end_interval_time>sysdate-15
    order by snap_id; 
    $ECHO

    col SqlText format a120
    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO SQL count with same FORCE_MATCHING_SIGNATURE in AWR :
    $DEFNODISP PRO
    $DEFNODISP select count(distinct sql_id) from dba_hist_sqlstat 
    $DEFNODISP   where FORCE_MATCHING_SIGNATURE>0 and 
    $DEFNODISP       FORCE_MATCHING_SIGNATURE=
    $DEFNODISP   (select FORCE_MATCHING_SIGNATURE from dba_hist_sqlstat where sql_id='$sqlid' and rownum=1);
    $DEFNODISP 
    $DEFNODISP $ECHO
    $DEFNODISP 
    $DEFNODISP 
    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO Other sqls with same plan_hash_value  in AWR(rownum<=10):
    $DEFNODISP col sqltext format a120
    $DEFNODISP select sql_id,
    $DEFNODISP    nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,120)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** ')) SqlText 
    $DEFNODISP from dba_hist_sqltext b where sql_id in 
    $DEFNODISP (select distinct sql_id from dba_hist_sqlstat 
    $DEFNODISP where plan_hash_value>0 and 
    $DEFNODISP       plan_hash_value in(select plan_hash_value from dba_hist_sqlstat where sql_id='$sqlid')
    $DEFNODISP     --and FORCE_MATCHING_SIGNATURE<>(select FORCE_MATCHING_SIGNATURE from dba_hist_sqlstat where sql_id='$sqlid' and rownum=1)
    $DEFNODISP ) and sql_id<> '$sqlid' and rownum<=10;
    $DEFNODISP $ECHO
    
    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO Other sqls with same plan_hash_value and not full binded  in v#sql (only)(rownum<=10):
    $DEFNODISP select sql_id,
    $DEFNODISP    nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,120)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** ')) SqlText 
    $DEFNODISP from gv\$sqltext b where sql_id in 
    $DEFNODISP (select distinct sql_id from gv\$sql 
    $DEFNODISP where plan_hash_value>0 and 
    $DEFNODISP       plan_hash_value in(select plan_hash_value from gv\$sql where sql_id='$sqlid')
    $DEFNODISP       and FORCE_MATCHING_SIGNATURE=exact_matching_signature
    $DEFNODISP ) and sql_id<> '$sqlid' and rownum<=10;
    $DEFNODISP $ECHO
    
    

    PRO
    PRO
    
    Pro SQL top event in gv_active_session_history:
    col event format a50
    select * from 
    (select inst_id,event,count(*) cnt from gv\$active_session_history where sql_id='$sqlid'
      group by inst_id,event order by cnt desc
    )where rownum<=5;
    pro
    pro
   
    set pagesize 180
    
    PRO
    PRO Historical SQL plans in AWR:
    PRO

    col PLAN_TABLE_OUTPUT format a180
    select * from table(dbms_xplan.display_awr('$sqlid',format=>'$format -projection'));

    PRO
    PRO    
 

    set pagesize 180
    
    PRO
    PRO Current SQL plans in Curor:
    PRO

    col PLAN_TABLE_OUTPUT format a180
    select * from table(dbms_xplan.display_cursor('$sqlid',format=>'$format -projection allstats last'));

    PRO
    Pro
    Pro Historical Plans Summary(dba_hist_sqlstat):
    col AVG_CPU_S format a12
    col avg_etime_s format a12
    col first_snap format a19
    col last_snap format a19
    col rn forma 999
    SELECT ROWNUM as rn,
       v.plan_hash_value,
       TO_CHAR(v.avg_elapsed_time_secs, '9999990D990') as avg_etime_s,
       TO_CHAR(v.avg_cpu_time_secs, '9999990D990') as avg_cpu_s,
       --TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990') as avg_iowait_s,
       --TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990') as avg_conc_s,
       --TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990') as avg_app_s,
       --TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990') as avg_clu_s,
       --TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990') as avg_plsql_s,
       --TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990') as avg_java_s,
       v.avg_buffer_gets as avg_buffers,
       v.avg_disk_reads as avg_reads,
       --v.avg_direct_writes,
       v.avg_rows_processed as avg_rows,
       v.delta_executions as execs,
       --v.min_optimizer_cost as min_cost,
       --DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost) as max_cost,
       --v.min_optimizer_env_hash_value as min_opt_env,
       --DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value) as max_opt_env,
       TO_CHAR(v.first_snap_time, 'YYYY-MM-DD HH24:MI:SS') as first_snap,
       TO_CHAR(v.last_snap_time, 'YYYY-MM-DD HH24:MI:SS') as last_snap
  FROM 
(
SELECT /*+ NO_MERGE */
       h.plan_hash_value,
       ROUND((SUM(h.elapsed_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(h.cpu_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(h.iowait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(h.ccwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(h.apwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(h.clwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(h.plsexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(h.javexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(h.buffer_gets_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_buffer_gets,
       ROUND(SUM(h.disk_reads_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_disk_reads,
       ROUND(SUM(h.direct_writes_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_direct_writes,
       ROUND(SUM(h.rows_processed_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_rows_processed,
       SUM(GREATEST(h.executions_delta, 1)) delta_executions,
       --SUM(h.fetches_delta) delta_fetches,
       --SUM(h.loads_delta) delta_loads,
       --SUM(h.invalidations_delta) delta_invalidations,
       --SUM(h.parse_calls_delta) delta_parse_calls,
       MIN(h.optimizer_cost) min_optimizer_cost,
       MAX(h.optimizer_cost) max_optimizer_cost,
       MIN(h.optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(h.optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(s.end_interval_time) first_snap_time,
       MAX(s.end_interval_time) last_snap_time
  FROM dba_hist_sqlstat h,
       dba_hist_snapshot s
 WHERE h.sql_id = '$sqlid'
   AND h.snap_id = s.snap_id
   AND h.dbid = s.dbid
   AND h.instance_number = s.instance_number
 GROUP BY
       h.plan_hash_value
 ORDER BY  2
) v;
$ECHO

      PRo
      Pro
      PRO Current Plans Summary(gv_sql):
      col first_load_time format a20
      col last_load_time format a20
      col last_active format a20
      col rn format 99
      SELECT  ROWNUM as rn,
       v.plan_hash_value,
       TO_CHAR(v.avg_elapsed_time_secs, '9999990D990') as avg_etime_s,
       TO_CHAR(v.avg_cpu_time_secs, '9999990D990') as avg_cpu_s,
       --TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990') as avg_iowait_s,
       --TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990') as avg_conc_s,
       --TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990') as avg_app_s,
       --TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990') as avg_clu_s,
       --TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990') as avg_plsql_s,
       --TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990') as avg_java_s,
       v.avg_buffer_gets as avg_buffers,
       v.avg_disk_reads as avg_reads,
       --v.avg_direct_writes,
       v.avg_rows_processed as avg_rows,
       v.total_executions as total_exec,
       --v.total_fetches,
       --v.total_loads,
       --v.total_invalidations,
       --v.total_parse_calls,
       --v.child_cursors,
       --v.min_optimizer_cost,
       --DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost) as max_cost,
       --v.min_optimizer_env_hash_value,
       --DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value) as max_opt_env,
       v.first_load_time,
       --v.last_load_time,
       TO_CHAR(v.last_active_time, 'YYYY-MM-DD HH24:MI:SS') as last_active  
  FROM (
SELECT /*+ NO_MERGE */
       plan_hash_value,
       ROUND((SUM(elapsed_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(cpu_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(user_io_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(concurrency_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(application_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(cluster_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(plsql_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(java_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(buffer_gets)/SUM(GREATEST(executions, 1))) avg_buffer_gets,
       ROUND(SUM(disk_reads)/SUM(GREATEST(executions, 1))) avg_disk_reads,
       ROUND(SUM(direct_writes)/SUM(GREATEST(executions, 1))) avg_direct_writes,
       ROUND(SUM(rows_processed)/SUM(GREATEST(executions, 1))) avg_rows_processed,
       SUM(GREATEST(executions, 1)) total_executions,
       SUM(fetches) total_fetches,
       SUM(loads) total_loads,
       SUM(invalidations) total_invalidations,
       SUM(parse_calls) total_parse_calls,
       COUNT(*) child_cursors,
       MIN(optimizer_cost) min_optimizer_cost,
       MAX(optimizer_cost) max_optimizer_cost,
       MIN(optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(first_load_time) first_load_time,
       MAX(last_load_time) last_load_time,
       MAX(last_active_time) last_active_time
  FROM gv\$sql
 WHERE sql_id = '$sqlid'
 GROUP BY
       plan_hash_value
 ORDER BY
       2) v;
    $ECHO
       
    pro
    pro
    PRO Tables involved(used objects may not exists now):
    PRO
    col table_owner format a30
    col table_name format a30
    col LAST_ANALYZED format a20
    with tmp_tbs as
    (
        select table_owner,table_name from dba_indexes where 
        (owner,index_name) in 
          (select object_owner,object_name from dba_hist_sql_plan where sql_id='$sqlid' and object_type like 'INDEX%'
           union all
           select object_owner,object_name from gv\$sql_plan where sql_id='$sqlid' and object_type like 'INDEX%'
           )
        union
        select object_owner,object_name from dba_hist_sql_plan where sql_id='$sqlid' and object_type = 'TABLE'
        union
        select object_owner,object_name from gv\$sql_plan where sql_id='$sqlid' and object_type = 'TABLE'
    )
    select a.*,b.num_rows,to_char(b.last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
       (select round(sum(bytes)/1024/1024) 
          from dba_segments c where a.table_owner=c.owner and a.table_name=c.segment_name
       ) as size_m 
    from tmp_tbs a,dba_tab_statistics b
    where a.table_owner=b.owner and a.table_name=b.table_name 
    and b.object_type='TABLE';
    $ECHO
    PRO
    PRO
    spool off
!
echo "Above is sql info for sql_id :$sqlid ,plan format is $format. for advanced plan ,use ora sql <sqlid> adv"
exit 0
fi

##################################################################################################

if [ "$1" = "version" ]; then

  #version;

  #
  # Get Oracle version number
  #
  #echo "Oracle version:"
  sqlplus -s /NOLOG << !  | egrep -v "Session altered|Connected|rows selected"

    set echo off
    set head off
    connect $DBUSER

    select  version 
    from PRODUCT_COMPONENT_VERSION
    where PRODUCT like 'Oracle%';
!

  exit 0
fi

##############################################################################################

if [ "$1" = "repeat" ]; then

  shift;
  interval=$1
  shift
  count=$1
  shift

  while [ 1 = 1 ]; do
    echo
    CURDATE=`date +"%D %T"`
    echo "######################## $CURDATE ########################"
    $ORA_PROG $ARGS $*
    if [ $? -eq 1 ]; then
      exit 1
    fi
           
    if [ "$count" = "forever" ]; then
      continue;
    else
       let "count=count-1"
       if [ $count -le 0 ]; then
        break;
       fi;
    fi;
    
    sleep $interval
    
  done;
  exit 0
fi



#####################################################################################################

if [ "$1" = "sessions" ]; then

  if [ "$2" = "" -o "$2" = "active" ]; then
    PRED=" and status='ACTIVE' and type<>'BACKGROUND' "
    echo "active sessions and not BACKGROUND:"
  else 
    PRED=""
    echo "all sessions:"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col username format A15 trunc
    col inst_id format 9999
    col sid format 999999
    col serial# format 999999
    col pid format a6
    col cl_pid format A10
    col module format A8 trunc
    col program format a8 trunc
    col event format a15 trunc
    col sql_id format A13
    col logon_time format a20
    col status format a8
    col bl_i format 999999
    col bl_s format 999999

    select s.inst_id,s.sid,s.serial#--, s.PROCESS cl_pid
           , p.spid pid, s.username,status
           ,s.module
           ,blocking_instance as bl_i,blocking_session as bl_s,event
           --,s.type--, s.server, 
           ,s.PROGRAM, sql_id--$COLNM $COLNM_HEADER
           ,to_char(logon_time,'yyyy-mm-dd hh24:mi:ss') as logon_time
           ,P.PGA_ALLOC_MEM
           ,P.PGA_USED_MEM
    from gv\$session s, gv\$process p
    where s.PADDR = p.addr  $PRED
          and s.inst_id=p.inst_id and s.inst_id=$INST
    order by logon_time;
    $ECHO
!

echo "example:ora sessions [active]|all   (order by logon_timie)"
echo "instance_number=$INST"
exit 0
fi

#######################################################################################################
 
if [ "$1" = "degree" -o "$1" = "parallel" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 200
    col degree format A6
    col instances format A13
    col table_name format A30
    col owner format a30
    col index_name format A30
    col SID format 99999
    col QCSID format 99999
    col PID format 9999
    col SPID format 9999999
    col Inst format 999999
    col Group format 999999
    col Set format 999999
    col Degree format a12
    col "Req Degree" format 999999
    col "Wait Event" format A30
    spool ora_degree_$filedate.log
      
    pro Table with degree summary:
    select owner,trim(degree) as degree,count(*) 
    from dba_tables 
    where trim(degree)<>'1' group by owner,trim(degree) 
    order by 1,2,3;
    $ECHO
    
    Pro Table with degree Detail:
    select owner,table_name,trim(degree) as degree from dba_tables 
    where trim(degree)<>'1' order by 1,2;
    $ECHO

    Pro Index with degree Summary:
    select owner,trim(degree) as degree,count(*) 
    from dba_indexes 
    where trim(degree)not in('1','0') group by owner,trim(degree) 
    order by 1,2,3;
    $ECHO
    
    Pro Index with degree Detail:
    select owner,table_name,index_name,trim(degree) as degree from dba_indexes 
    where trim(degree)not in('1','0') order by 1,2;
    $ECHO

    Pro Parallel process running:
      select s.sql_id,px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree"
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;
      $ECHO
      spool off
!
exit 0
fi

########################################################################################################

if [ "$1" = "histogram" ]; then

  if [ "$2" = "" ]; then
    echo "ora histogram owner tabel_name col_name"
    exit 1
  fi
  
  owner=$2
  tname=$3
  cname=$4  

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    
    COL endpoint_value FORMAT A40
    col owner format a10 trunc
    col table_name format a20 trunc
    col column_name format a20 trunc
    
    select owner,table_name,column_name,endpoint_value, pct_total
        from
        (
        select a.owner,a.table_name,a.column_name,nvl(endpoint_actual_VALUE,endpoint_value) as endpoint_value,endpoint_number curr_ep,
               lag(endpoint_number,1,0) over(order by endpoint_number) prev_ep,
               (endpoint_number - lag(endpoint_number,1,0) over (order by endpoint_number)) num_in_bkt,
               max(endpoint_number) over () last_ep,
               round((endpoint_number - lag(endpoint_number,1,0) over (order by endpoint_number)) / max(endpoint_number) over (), 4) * 100 pct_total,
               row_number() over (order by endpoint_number) rn
          from dba_tab_histograms a ,dba_tab_columns b
         where a.owner =upper( '$owner')
           and a.table_name = upper('$tname')
           and a.column_name = upper('$cname')
           and b.table_name=a.table_name
           and b.owner=a.owner
           and b.column_name=a.column_name
           and b.histogram<>'NONE'
        ) ORDER BY pct_total;    
      $ECHO
!
exit 0
fi



###################################################################################################

if [ "$1" = "lock" -o "$1" = "blocker" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    --tested on rac
    set linesize 250 pagesize 200
    col owner format a10
    col object_name format a20
    col row# format a20
    col blocker_to_be_kill format a30
    col blocked_info format a30
    col blocked_sql_text format a40
    spool ora_lock_$filedate.log
    $DEFNODISP SELECT dba_objects.owner as owner,
    $DEFNODISP        dba_objects.object_name,       
    $DEFNODISP        DBMS_ROWID.ROWID_CREATE (1,dba_objects.data_object_id,   locks_t.row_wait_file#,    locks_t.row_wait_block#,  locks_t.row_wait_row#  ) row#,
    $DEFNODISP        locks_t.blocked_secs,type,locks_t.blocker_to_be_kill,locks_t.blocked_info,locks_t.blocked_sql_text
    $DEFNODISP   FROM (
            SELECT /*+ NO_MERGE */
                   blocking_sess.username||'@'||blocking_sess.machine||'('||blocked_sess.module||') (SID='||blocking_sess.sid||','||blocking_sess.serial#||') ['||
                   blocking_sess.program||'/client_PID='||blocking_sess.process||'/server_Pid='||p.spid||']' as blocker_to_be_kill,
                   blocked_sess.username||'@'||blocked_sess.machine||'('||blocked_sess.module||') (SID='||blocked_sess.sid||','||blocked_sess.serial#||') ['||
                   blocked_sess.program||'/client_PID='||blocked_sess.process||']' as blocked_info,
                   blocking_lock.type,
                   blocked_sess.row_wait_obj#,blocked_sess.row_wait_file#,blocked_sess.row_wait_block#,blocked_sess.row_wait_row#,
                   blocked_sess.seconds_in_wait blocked_secs
                   ,sql.sql_text blocked_sql_text
              FROM gv\$lock blocking_lock,
                   gv\$session blocking_sess,
                   gv\$lock blocked_lock,
                   gv\$session blocked_sess,
                   gv\$sqlarea sql,
                   gv\$process p
             WHERE blocking_lock.block = 1
               AND blocking_lock.id1 = blocked_lock.id1
               AND blocking_lock.id2 = blocked_lock.id2
               AND blocked_lock.request > 0
               AND blocking_lock.sid = blocking_sess.sid
               AND blocked_lock.sid = blocked_sess.sid
               AND blocked_sess.sql_id = sql.sql_id(+)
               and blocked_sess.inst_id= sql.inst_id(+)
               and blocking_sess.paddr=p.addr
               and blocking_sess.inst_id=p.inst_id
               and blocking_sess.inst_id=blocked_sess.blocking_instance --bug found by Albert Liang
               and blocked_sess.seconds_in_wait>=2
               --AND blocked_sess.sql_child_number = blocked_sql.child_number
    $DEFNODISP        ) locks_t,
    $DEFNODISP        dba_objects
    $DEFNODISP  WHERE locks_t.row_wait_obj# = dba_objects.object_id
    $DEFNODISP    --AND locks_t.blocked_secs >= 2
    ORDER BY BLOCKER_TO_BE_KILL;
    $ECHO
    ---------------------------------------------------------------------------------------------------
    --tested on rac
    set linesize 200 pagesize 30
    col s_info format a20
    col OBJECT_NAME format a30
    col SQL_TEXT format a80 trunc
    col module format a10 trunc
    col machine format a15 trunc
     
     WITH sessions AS
        (SELECT /*+materialize*/
                sid,inst_id,module, machine,blocking_session, BLOCKING_INSTANCE,row_wait_obj#, sql_id
           FROM gv\$session
         )
    SELECT LPAD(' ', 4*(LEVEL-1) ) || sid||'@'||s.inst_id as s_info, s.module,s.machine,object_name,s.sql_id
            ,substr(sql_text,1,100) sql_text
       FROM sessions s
       LEFT OUTER JOIN dba_objects
            ON (object_id = row_wait_obj#)
       LEFT OUTER JOIN gv\$sqlarea gs--in case of duplicate sql_id
            on (s.sql_id=gs.sql_id and s.inst_id=gs.inst_id)
      WHERE (s.sid,s.inst_id) IN (SELECT blocking_session,BLOCKING_INSTANCE FROM sessions)
            OR blocking_session IS NOT NULL
      CONNECT BY PRIOR s.sid = blocking_session and prior s.inst_id=blocking_instance --bug found by Albert Liang
      START WITH blocking_session IS NULL;
      $ECHO
      
        col obj_name format a30
        col pin_cnt format 999
        col pin_mode format 999
        col pin_req format 999
        col state format a30
        col event format a30
        col wait_time format 999999999
        col seconds_in_wait format 999999999

        Pro create or replace procedure hang:
        select distinct ses.ksusenum sid, ses.ksuseser serial#,
               ob.kglnaobj obj_name,
               pn.kglpncnt pin_cnt, pn.kglpnmod pin_mode, pn.kglpnreq pin_req,
               w.state, w.event, w.wait_time, w.seconds_in_Wait
        from   x\$kglpn pn, x\$kglob ob, x\$ksuse ses, v\$session_wait w
        where  pn.kglpnhdl in (select kglpnhdl from x\$kglpn where kglpnreq > 0)
        and    ob.kglhdadr = pn.kglpnhdl
        and    pn.kglpnuse = ses.addr
        and    w.sid = ses.indx
        order by seconds_in_wait desc;
        $ECHO
        
       Pro v\$locked_object: 
       col owner format a20
       col object_name format a30
       col oracle_username format a20
       col os_user_name format a20
        select do.OWNER, do.OBJECT_NAME, do.OBJECT_ID, 
       lo.SESSION_ID, lo.ORACLE_USERNAME, lo.OS_USER_NAME, 
       lo.PROCESS, lo.LOCKED_MODE 
        from   dba_objects do, v\$locked_object lo 
        where  do.OBJECT_ID = lo.OBJECT_ID 
        order by owner,object_name;
        $ECHO
      
      spool off
!
echo "full nodes"
exit 0
fi


###################################################################################################

if [ "$1" = "awrsnap" -o "$1" = "listsnap" ]; then

    if [ "$2" = "" ]; then
     days=3
  else
     days=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
 
    connect $DBUSER

    set pagesize 30
    set linesize 150
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time  format a20

    break on startup_time
     select  instance_number,snap_id-1 as begin_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,snap_id as end_snapid
            ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot 
     where end_interval_time>sysdate-$days and instance_number=$INST
     order by instance_number,snap_id;
     $ECHO
     
     Pro AWR setting:
     select
       extract( day from snap_interval) *24*60+  extract( hour from snap_interval) *60+  extract( minute from snap_interval ) as  "Interval_min",
       extract( day from retention) + extract( hour from retention) /24 +   extract( minute from retention )/24/60 as  "Retention_days"
     from dba_hist_wr_control;     
         
!
echo "display awr snapshots for recent $days days."
exit 0
fi

######################################################################################################

if [ "$1" = "mvsnap" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col status format A15
    col name format A30

    select name, status
    from all_snapshots order by 1;
    $ECHO
!
exit 0
fi

#################################################################################################

if [ "$1" = "asm" ]; then
  sqlplus -s  /NOLOG  << ! | egrep -v "Session altered|Connected|rows selected"
  connect $DBUSER

  col name format a20
  pro asm diskgroup info:
  select name, total_mb, free_mb,usable_file_mb ,type,state from v\$asm_diskgroup;
  
  pro asm disk info:
  select b.NAME,b.type,t.disk_number,t.TOTAL_MB,t.FREE_MB
  from v\$asm_disk t,v\$asm_diskgroup b
  where t.GROUP_NUMBER=b.GROUP_NUMBER 
  order by t.disk_number; 
  $ECHO
!
exit 0
fi

##################################################################################################

if [ "$1" = "parameter" ]; then

  if [ "$2" = "" ]; then
     kw=""
     kw2=""
  else
     kw=" and parameter_name like '%$2%' "
     kw2=" and name like '%$2%' "
  fi
  
   if [ "$3" = "" ]; then
     snaps=2
   else
     snaps=$3
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 200 pagesize 100
    col parameter_name format a40
    col name format a40
    col value format a60 trunc
    Prompt Display Parameters in last snapshot(dba_hist_parameter):

    select instance_number,snap_id,parameter_name as name,value
    from dba_hist_parameter 
    where snap_id>(select max(snap_id)-$snaps from dba_hist_snapshot)
     and isdefault ='FALSE' 
     and instance_number=$INST 
     and parameter_name not like '\_\_%' escape '\' $kw
    order by instance_number,snap_id,parameter_name;
    $ECHO
    
    
    Prompt Display Parameters in gv#parameter:

    select inst_id,name,display_value as value from gv\$parameter 
     where  isdefault ='FALSE' and inst_id=$INST 
     and name not like '\_\_%' escape '\' $kw2
     order by inst_id,name;
    $ECHO

!
echo "show Parameters in his and current"
echo inst_id=$INST
exit 0
fi

#'
##################################################################################################

if [ "$1" = "params" ]; then

  if [ "$2" != "" ]; then
    PAT="%${2}%"
  else
    PAT="%"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 200

    col name format A50
    col value format A20
    col description format A70 trunc

    select ksppinm name, ksppstvl value, ksppdesc description
    from x\$ksppi x, x\$ksppcv y
    where (x.indx = y.indx)
      and upper(ksppinm) like upper('$PAT')
    order by name;
    $ECHO
!
exit 0
fi

####################################################################################################

if [ "$1" = "bc" ]; then

     if [ "$2" = "" ]; then
      top=10
     else 
      top=$2
     fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80

    select * from (
      select /*+ ordered use_hash(obj\$ v\$bh) */owner#, name, count(*) "Buffer Count"
      from obj\$ o, v\$bh b
      where o.dataobj# = b.objd
        and b.status != 'free'
      group by owner#,o.name
      order by 3 desc)
    where rownum <= $top ;
    $ECHO

!
echo "Top $top Buffer Count."
exit 0
fi

#######################################################################################################

if [ "$1" = "session_event" ]; then

  if [ "$2" = "px" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 6000
      set linesize 150

      col SID format 99999
      col QCSID format 99999
      col PID format 9999
      col SPID format 9999999
      col Inst format 999999
      col Group format 999999
      col Set format 999999
      col Degree format 999999
      col "Req Degree" format 999999
      col "Wait Event" format A30
      col sql_hash format A15

      select px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree",
             w.event "Wait Event", s.SQL_HASH_VALUE hash_value
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p, GV\$session_wait w
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.sid = w.sid (+)
        and s.inst_id = w.inst_id (+)
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;
      $ECHO
!
  else

     SQLSTRING="select inst_id, event, count(*) from gv\$session_wait where wait_time = 0"

     if [ "$2" = "noidle" ]; then
       SQLSTRING=${SQLSTRING}" and wait_class <> 'Idle'"
     fi
     
     SQLSTRING=${SQLSTRING}" group by inst_id, event order by inst_id, event"
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 10000
      set linesize 150

      ${SQLSTRING};
!
  fi
echo "instance_number=$INST"
exit 0
fi

#####################################################################################################################

if [ "$1" = "temp" ] ; then

  if [ "$2" != "" ]; then
    EXTRA_PRED="AND   s.username=upper('$2')"
  else
    EXTRA_PRED=""
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col file_name format A40
    col USED_SPACE format A20
    col MAX_USED_SPACE format A20
    spool ora_temp_$filedate.log

    Pro Used Temp tablespace:
    select round(used_blocks*(select max(BLOCK_SIZE)
                              from dba_tablespaces
                              where tablespace_name='SYSTEM')
             /1024/1024)+1 || ' MB (used)' as used_space,
           round(max_used_blocks*8/1024)+1 ||' MB (max used)' as max_used_space
    from gv\$sort_segment where inst_id=$INST;
    $ECHO

    Pro temp file total size:
    select sum(round(BYTES/1024/1024)+1) total_size_mb
    from dba_temp_files ;
    $ECHO
    
    Pro sessions used more than 10M temp space(sort_usage):
    set linesize 200 pagesize 30
    col username format a11
    col status format a8
    col sql_id format a13
    col tablespace format a10
    col segtype format a10
    col contents format a10
    SELECT se.inst_id,
           se.username username,
           se.SID sid,
           se.serial#,
           se.status status,
           se.sql_id,
           su.TABLESPACE tablespace,
           su.segtype,
           su.CONTENTS CONTENTS,
           round(su.blocks * 8192 / 1024 / 1024, 2) size_MB 
    FROM gv\$session se,
         gv\$sort_usage su
    WHERE se.saddr=su.session_addr
    AND   se.inst_id=su.inst_id
    and   se.inst_id=$INST
    and  round(su.blocks * 8192 / 1024 / 1024, 2)>=10
    ORDER BY size_MB;
    $ECHO
    
   $DEFNODISP col sql_text format a80
   $DEFNODISP col username format a15
   $DEFNODISP col tablespace format a20
   $DEFNODISP Pro temp usage by sql_id (sort_usage):
   $DEFNODISP SELECT u.sql_id, t.sql_text, s.username, u.tablespace, u.segtype,
   $DEFNODISP        u.contents, u.extents, u.blocks
   $DEFNODISP FROM gv\$session s, gv\$sort_usage u, gv\$sqlarea t
   $DEFNODISP WHERE s.saddr=u.session_addr 
   $DEFNODISP and s.inst_id=u.inst_id and u.inst_id=t.inst_id and s.inst_id=$INST
   $DEFNODISP AND   u.sql_id=t.sql_id  ${EXTRA_PRED} ;
   $DEFNODISP $ECHO    
    
    
    Pro tempseg_usage:
    SELECT s.username, sid, serial#, contents, sql_address , extents,last_call_et
    FROM gv\$session s, gv\$tempseg_usage t
    WHERE s.saddr = t.session_addr and s.inst_id=t.inst_id and s.inst_id=$INST;
    $ECHO 
    spool off    
    
!
echo "instance_number=$INST"
  exit 0
fi

######################################################################################################

if [ "$1" = "event_set"  ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected|PL/SQL procedure"

    connect $DBUSER

    --set pagesize 10000
    --set linesize 200

    set linesize 200 pagesize 30
    col username format a11
    set serveroutput on size unlimited
    declare
     event_level number;
    begin
        dbms_output.put_line('list all trace event setted:');
        for i in 1..100000 loop
          sys.dbms_system.read_ev(i,event_level);
          if (event_level > 0) then
            dbms_output.put_line('   Event '||to_char(i)||' set at level '||to_char(event_level));
          end if;
     end loop;
    end;
    /    
    
!
echo "display all events setted in the system,e.g. Alter system set events=..."
  exit 0
fi

###############################################################################################################

if [ "$1" = "longops" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 150 pagesize 40
    column opname format a30 wrap
    select * from 
    (
     select inst_id,sid,sql_id, opname, sofar, totalwork,
           round(sofar*100/totalwork) percent,
           round(elapsed_seconds/60) "Elapsed (min)",
           decode(sofar,0,0,round(elapsed_seconds*(totalwork-sofar)/(sofar*60))) as "To go (min)",
           context dfo
    from gv\$session_longops 
    where sofar != totalwork 
    and inst_id=$INST
    order by elapsed_seconds desc
    )
    where rownum<=20;
  $ECHO
!
echo "instance_number=$INST"
echo "above info is top 20 long runing ops from gv_session_longops"
#ora monlist 20
exit 0
fi

###################################################################################################

if [ "$1" = "sga" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"


    connect $DBUSER

    set pagesize 1000 linesize 200
    set tab      off
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;

    Pro v#sgastat:
    select nvl(pool, 'Total') pool,
           decode(name, NULL, decode(pool, NULL, NULL, '(total)'), name) name,
           round(sum(bytes)/1024) as size_kb
    from gv\$sgastat
    where pool is not null
          and name in ('free memory', 'PX msg pool', 'sql area','library cache')
          and inst_id=$INST
    group by rollup(pool, name)
    order by 3;
    $ECHO
    
    Pro v#sga_dynamic_components:
    col component format a40
    select substr(COMPONENT,1,25) COMPONENT,
          CURRENT_SIZE/1024/1024 CURRENT_SIZE_mb,
          MIN_SIZE/1024/1024 MIN_SIZE_MB, MAX_SIZE/1024/1024 MAX_SIZE_MB,
          LAST_OPER_TYPE, LAST_OPER_MODE
    from gv\$sga_dynamic_components 
    where inst_id=$INST;
    $ECHO

    prompt
    prompt CURRENT SGA RESIZE OPERATIONS
    select COMPONENT, OPER_TYPE, OPER_MODE, PARAMETER
    from   gv\$sga_current_resize_ops 
    where inst_id=$INST;
    $ECHO
    
    prompt SGA_RESIZE_OPS
    SELECT substr(COMPONENT,1,25) COMPONENT,oper_type,initial_size/1024/1024 init_MB,target_size/1024/1024 target_MB,
    final_size/1024/1024 final_MB,status, to_char(start_time,'yyyymmdd hh24miss') as start_time,
    to_char(end_time,'yyyymmdd hh24miss') as end_time
    FROM gV\$SGA_RESIZE_OPS
    where PARAMETER in ('db_cache_size','shared_pool_size') 
    and OPER_TYPE in ('GROW','SHRINK')
    and inst_id=$INST
    order by PARAMETER,START_TIME;
    
    --pro _memory_imm_mode_without_autosga 
!
echo "instance_number=$INST"
ora params _memory_imm_mode_without_autosga
  exit 0
fi

########################################################################################################
##duplicate with pga command
if [ "$1" = "processes" ]; then

  MAX=""

  if [ "$2" != "" ]; then
    MAX=" and round(PGA_MAX_MEM/1024/1024) >= $2"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 6000
      set tab      off
      set linesize 160
      set echo off
      col prg format A30
      col spid format A12
      repfooter off;
      set timing off veri off space 1 flush on pause off termout on numwidth 10;

      select p.pid, p.spid, substr(p.program, 10, 30) prg,
             round(PGA_USED_MEM/1024/1024) used_M,
             round(PGA_ALLOC_MEM/1024/1024) alloc_M,
             round(PGA_FREEABLE_MEM/1024/1024) freeable_M,  round(PGA_MAX_MEM/1024/1024) max_M
      from gv\$process p
      where inst_id=$INST and spid is not NULL $MAX
      order by 4;
      $ECHO
!
echo "instance_number=$INST"
exit 0;
fi



#######################################################################################################

if [ "$1" = "pga" ]; then

     if [ "$2" = "" ]; then
      rn=50
     else
      rn=$2
     fi
     
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 100
    --set tab      off
    set linesize 200
    --set echo off
    --repfooter off;
    --set timing off veri off space 1 flush on pause off termout on numwidth 10;
    col spid format a8
    col program format a20 trunc
    col username format a15
    select * from
    (
    select SPID, username,program,pname
           ,round(PGA_USED_MEM/1024/1024) as PGA_USED_MEM_M
           ,round(PGA_ALLOC_MEM/1024/1024) as PGA_ALLOC_MEM_M
           ,round(PGA_MAX_MEM/1024/1024) as PGA_MAX_MEM_M
    from gv\$process
    where spid is not NULL and inst_id=$INST
    order by PGA_USED_MEM desc
    ) where rownum<=$rn;
!
echo "instance_number=$INST"
exit 0
fi

############################################################################################
# Detail of pga
##########################################################################################
if [ "$1" = "pga_detail" ]; then

  if [ "$2" = "" ]; then
    echo "ora pga_detail pid\(ora pga_detail 2584\)/\(ora pga_detail -mem 10\) >10M"
    exit 1
  fi

  if [ "$2" = "-mem" ] ; then
    if [ "$3" = "" ]; then
      echo "memory threshold not specified"
    else
      PRED="PGA_ALLOC_MEM > $3 * 1024 * 1024"
      OSPID=""
    fi
  else
    PRED="SPID=$2"
    OSPID=$2
  fi

  sqlplus -s /NOLOG << ! | grep '###' | sed -e 's/.*###\(.*\)###\(.*\)###\(.*\)###/\1 \2 \3/g' > $ORA_TMP/pid$$

     connect $DBUSER

     select '###' || pid || '###' || spid || '###' || round(pga_alloc_mem/1024/1024) || '###' version
     from v\$process
     where $PRED;
!

  FOUND=0
  cat $ORA_TMP/pid$$ | while read a; do
    set $a
    ORA_PID=$1
    OSPID=$2
    MEM=$3
    FOUND=1

    echo
    echo "Detail for process $OSPID \(PGA allocated is $MEM MB\)"
    echo '****************************************************'

    sqlplus -s /NOLOG << ! | egrep -v "Statement processed|Function returned|rows selected"

      connect $DBUSER

      set pagesize 6000
      set linesize 200
      set tab      off
      set echo off
      set long     4000

      oradebug setmypid
      oradebug call ksmpgd_get_detail $ORA_PID

      ! sleep 10

      select PID, SERIAL#, CATEGORY, NAME, HEAP_NAME, BYTES, ALLOCATION_COUNT,
             HEAP_DESCRIPTOR, PARENT_HEAP_DESCRIPTOR
      from gv\$process_memory_detail
      where PID=$ORA_PID and inst_id=$INST
      order by bytes;
      $ECHO
!

  done

  if [ $FOUND -eq 0 -a "$OSPID" != "" ]; then
    echo "OS pid $OSPID does not exists in v\$process"
  fi

  rm -f $ORA_TMP/pid$$
echo "instance_number=$INST"
exit 0
fi

#######################################################################################################

if [ "$1" = "alert" ]; then
#find all log.xml in $ORACLE_BASE/diag , include listener log.xml

  #if [ "$2" = "" ]; then
  #   days=2
  #else
  #   days=$2
  #fi
   
   if [ "$2" = "" ]; then
    read -p "please input alert his days to review [2]:" days
    if [ -z "${days}" ];then
      days=2
    fi
  else
    days=$2
  fi
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set tab      off
    set linesize 180
    col message_text format a140
    col inst_id format 9999
    col alert_time format a20

    select inst_id,to_char(originating_timestamp,'yyyy-mm-dd hh24:mi:ss')as alert_time, message_text
    from 
    TABLE(gv\$(cursor(select inst_id, originating_timestamp, message_text
                    from v\$diag_alert_ext
                    where originating_timestamp > (sysdate - $days)
                          and inst_id=$INST
                    and (message_text like '%ORA-%' 
                        or message_text ='Checkpoint not complete' 
                        or upper(message_text) like 'ALTER%'
                        )
                  )
            )
    )
    order by inst_id, originating_timestamp;
    $ECHO
!
  echo "****display alert log in recent $days days****"
  exit 0
fi

#################################################################################################

if [ "$1" = "users" -o  "$1" = "user" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set tab      off
    
    set linesize 150 pagesize 30
    col username format a25
    col default_tablespace format a20
    col temporary_tablespace format a20
    col account_status format a20
    col created format a20
    col profile format a20 
    --set echo on
    select username,default_tablespace,account_status
    ,temporary_tablespace,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
    ,profile 
    from dba_users 
    order by username;   
    $ECHO
!
  exit 0
fi


#################################################################################################

if [ "$1" = "lob" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set tab      off
    
    set linesize 200 pagesize 100
    --set echo on
    col rn format 99
    col SEGMENT_NAME format a25
    col owner format a15 trunc
    col table_name format a20 trunc
    col column_name format a25
    col index_name format a24
    col size_M format 99999
    col chunk format 99999
    --get big 
      select v1.*,b.table_name,b.column_name,index_name,chunk,securefile,in_row from
    (
        select rownum as rn,a.* from
        (select owner,segment_name--,segment_type
            ,round((bytes/1024/1024)) size_M
            from dba_segments 
            where round(bytes/1024/1024)>=10 and 
            segment_type='LOBSEGMENT'
            order by size_M desc
        )a where rownum<=50
    )v1,dba_Lobs b
    where v1.owner=b.owner and v1.segment_name=b.segment_name
    order by rn;
    $ECHO
!
echo "list biggest 50 lob segment >=10M"
  exit 0
fi

#################################################################################################

if [ "$1" = "lobfree" ]; then

  if [ "$2" = "" ]; then
    echo "ora lobfree owner lobname\$\$ ;not for basicfile"
    exit 0
  fi
  
  owner=$2
  lobname=$3  
  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

  connect $DBUSER

    
set serveroutput on size unlimited
declare  
  l_seg_size_blocks int;  
  l_seg_size_bytes int;  
  l_used_blocks int;  
  l_used_bytes int;  
  l_expired_blocks int;  
  l_expired_bytes int;  
  l_unexpired_blocks int;  
  l_unexpired_bytes int;   
  l_unused_blocks  int;
  l_unused_bytes int;
  l_non_data_blocks int;
  l_non_data_bytes int;

begin  
  dbms_space.space_usage(  
   segment_owner           => upper('$owner'),  
   segment_name            => upper('$lobname'),  
   segment_type            => 'LOB',  
   segment_size_blocks     => l_seg_size_blocks,  
   segment_size_bytes      => l_seg_size_bytes,  
   used_blocks             => l_used_blocks,  
   used_bytes              => l_used_bytes,  
   expired_blocks          => l_expired_blocks,  
   expired_bytes           => l_expired_bytes,  
   unexpired_blocks        => l_unexpired_blocks,  
   unexpired_bytes         => l_unexpired_bytes  
   );  
   
          l_unused_blocks := l_seg_size_blocks - (l_used_blocks + l_expired_blocks + l_unexpired_blocks);
          l_unused_bytes  := l_seg_size_bytes - (l_used_bytes + l_expired_bytes + l_unexpired_bytes);

          l_non_data_blocks := l_unused_blocks + l_expired_blocks + l_unexpired_blocks;
          l_non_data_bytes :=  l_unused_bytes + l_expired_bytes + l_unexpired_bytes;
          
  dbms_output.put_line(lpad('-',42,'-'));   
  dbms_output.put_line('lob segment blocks    = '|| l_seg_size_blocks);  
  dbms_output.put_line('lob segment bytes_M   = '|| round(l_seg_size_bytes/1024/1024));  
  dbms_output.put_line('lob used blocks       = '|| l_used_blocks);  
  dbms_output.put_line('lob expired blocks    = '|| l_expired_blocks);  
  dbms_output.put_line('lob unexpired blocks  = '|| l_unexpired_blocks);  
   
  dbms_output.put_line('lob unused   blocks / bytes(M)  = '|| l_unused_blocks||' / '||round(l_unused_bytes/1024/1024)); 
  dbms_output.put_line('lob non_date blocks / bytes(M)  = '|| l_non_data_blocks||' / '||round(l_non_data_bytes/1024/1024)); 
  dbms_output.put_line(lpad('-',42,'-'));   
end;  
/ 

!
  exit 0
fi

#####################################################################################################

if [ "$1" = "cputime" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 30
    set tab      off
    set verify off
    
    define statname='DB CPU'
    spool ora_cputime_$filedate.log
    Pro cputime by day:
    with stat_time as
    (
      select instance_number,begin_snap_id, end_snap_id,
      snap_begin_time, snap_end_time,
      round(interval_min) as interval_min,
      round(lag_value/60/1000000,0) as stat_time_min ,
      round(lag_value/60/1000000/interval_min,0) as stat_time_per_sec
      from
      (
        select sp.instance_number,
        sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
        sp.snap_id   as end_snap_id,   to_char(end_interval_time-1/24/60,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, --1 minute ahead for 00:00:xx,it belongs to prev day
        (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
        value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
        sy.stat_name
        from dba_hist_snapshot sp, dba_hist_sys_time_model sy
        where sp.snap_id=sy.snap_id
          and sp.instance_number=sy.instance_number
          and sy.stat_name='&statname'
        ) where   nvl(lag_value,0)>0
    )--end with 
    select instance_number,min(begin_snap_id),max(end_snap_id),substr(snap_end_time,1,10) as stat_time_day,sum(stat_time_min) as total_time_day 
    from stat_time group by instance_number,substr(snap_end_time,1,10)
    --order by total_time_day
    order by stat_time_day;
    $ECHO
    
    
    Pro top 20 cputime by snap:
    with stat_time as
    (
    select instance_number,begin_snap_id, end_snap_id,
    snap_begin_time, snap_end_time,
    round(interval_min) as interval_min,
    round(lag_value/60/1000000,2) as DB_CPU_min ,
    round(lag_value/60/1000000/interval_min,2) as DB_CPU_per_sec
    from
    (
    select sp.instance_number,
    sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time, 
    sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, 
    (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
    value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
    sy.stat_name
    from dba_hist_snapshot sp, dba_hist_sys_time_model sy
    where sp.snap_id=sy.snap_id
      and sp.instance_number=sy.instance_number
      and sy.stat_name='&statname'
    ) where   nvl(lag_value,0)>0
    )--with
    select * from 
    (
    select a.* ,row_number() over ( partition by instance_number order by DB_CPU_per_sec desc) as rank
     from stat_time a
    ) where rank<=20;
    $ECHO    
    spool off
!
 echo "display CPU time by day and show top 10 cputime by snapshots" 
  exit 0
fi

#####################################################################################################

if [ "$1" = "awr" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time format a20
    
    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot 
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
    
   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else 
    bid=$2
    eid=$3   
  fi
  
#    if [ "$2" = "" -o "$3" = "" ]; then
#    #ora awrsnap
#    #echo "ora awr  <begin_snapid> <end_snapid> "
#    bid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
#    let eid=bid+1
#    #exit 1
#   else
#    bid=$2
#    eid=$3
#   fi 

  
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
  
    connect $DBUSER

SET AUTOP OFF VER OFF SERVEROUT ON SIZE unlimited;
SET TERMout off ECHO OFF feedback off
set trims on

SPOOL _awr.sql

declare 

node_cnt number:=0; 
v_dbid number;
BEGIN

    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF PAGESIZE 0 HEADING OFF LINESIZE 8000 TRIMSPOOL ON TRIMOUT ON TAB OFF timing off feedback off');
    dbms_output.put_line('exec DBMS_WORKLOAD_REPOSITORY.AWR_SET_REPORT_THRESHOLDS(top_n_sql=>60);');
    
    
    
    for i in (select dbid,inst_id from gv\$database order by 1)
    loop
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for node'||i.inst_id||' ,  please wait for a few minutes......');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
        DBMS_OUTPUT.PUT_LINE('spool ora_awrrpt_'||i.inst_id||'_'||$bid||'_'||$eid||'.html');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_report_html('||i.dbid||','||i.inst_id||','||$bid||','||$eid||'));');
        DBMS_OUTPUT.PUT_LINE('spool off');
        node_cnt:=node_cnt+1;
        v_dbid  :=i.dbid;
    END LOOP;
    
    if node_cnt>1 then 
    DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
    DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for RAC ,  please wait for a few minutes');
    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
    DBMS_OUTPUT.PUT_LINE('spool ora_awrrpt_RAC_'||$bid||'_'||$eid||'.html');
    DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_global_report_html('||v_dbid||', CAST(null AS VARCHAR2(10)),'||$bid||' ,'||$eid||'));');
    DBMS_OUTPUT.PUT_LINE('spool off');
    end if;
END;
/

SPOOL OFF;

set SERVEROUT off

@_awr    
!
rm _awr.sql
echo "generate awr report for snapid $bid - $eid "
  exit 0
fi

#####################################################################################################

if [ "$1" = "awrsq" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time format a20
    
    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot 
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
   read -p "Please input        sql_id$defsql_id: " sql_id
    if [ -z "${sql_id}" ];then
         sql_id=$defsql_id
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
  
    connect $DBUSER

SET AUTOP OFF VER OFF SERVEROUT ON SIZE unlimited;
SET TERMout off ECHO OFF feedback off
set trims on

SPOOL _awr.sql

declare 

node_cnt number:=0; 
v_dbid number;
BEGIN

    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF PAGESIZE 0 HEADING OFF LINESIZE 8000 TRIMSPOOL ON TRIMOUT ON TAB OFF timing off feedback off');
    dbms_output.put_line('exec DBMS_WORKLOAD_REPOSITORY.AWR_SET_REPORT_THRESHOLDS(top_n_sql=>60);');
    
    
    
    for i in (select dbid,inst_id from gv\$database order by 1)
    loop
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for node'||i.inst_id||' ,  please wait for a few minutes......');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
        DBMS_OUTPUT.PUT_LINE('spool ora_awrsqrpt_'||i.inst_id||'_'||$bid||'_'||$eid||'_'||'$sql_id'||'.html');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.AWR_SQL_REPORT_HTML('||i.dbid||','||i.inst_id||','||$bid||','||$eid||','||q'[']'||'$sql_id'||q'[']'||'));');
        DBMS_OUTPUT.PUT_LINE('spool off');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.AWR_SQL_REPORT_TEXT('||i.dbid||','||i.inst_id||','||$bid||','||$eid||','||q'[']'||'$sql_id'||q'[']'||'));');
        node_cnt:=node_cnt+1;
        v_dbid  :=i.dbid;
    END LOOP;
END;
/

SPOOL OFF;

set SERVEROUT off

@_awr    
!
rm _awr.sql
echo "generate awrsqrpt report for snapid $bid - $eid sql_id $sql_id"
  exit 0
fi

#####################################################################################################

if [ "$1" = "highparse" ]; then
    
   if [ "$2" = "" ]; then
    cnt=500
   else
    cnt=$2
   fi

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600
    
    col sql_text format a100
    col sql_id format a13
    column FORCE_MATCHING_SIGNATURE format 99999999999999999999999
    
    spool ora_highparse_$filedate.log
    
    WITH c AS
        (SELECT  FORCE_MATCHING_SIGNATURE,
                 COUNT(*) cnt
        FROM     gv\$sqlarea
        WHERE    FORCE_MATCHING_SIGNATURE!=0
        GROUP BY FORCE_MATCHING_SIGNATURE
        HAVING   COUNT(*) > =$cnt   -- (P.S. You can run this query with larger values say 1000)
        ),
        sq AS
        (SELECT  sql_id,substr(sql_text,1,100) as sql_text ,
                 FORCE_MATCHING_SIGNATURE,
                 row_number() over (partition BY FORCE_MATCHING_SIGNATURE ORDER BY sql_id DESC) rn
        FROM     gv\$sqlarea s
        WHERE    FORCE_MATCHING_SIGNATURE IN (SELECT FORCE_MATCHING_SIGNATURE FROM  c)
        )
    select * from 
    (SELECT   
            sq.FORCE_MATCHING_SIGNATURE,
            sql_id,
            c.cnt unshared_count,
            sq.sql_text               
    FROM     c, sq
    WHERE    sq.FORCE_MATCHING_SIGNATURE=c.FORCE_MATCHING_SIGNATURE
    AND      sq.rn=1
    ORDER BY c.cnt DESC
    )where rownum<=100;
    $ECHO
    spool off
    
!
echo "full nodes"
echo "show same FORCE_MATCHING_SIGNATURE with diffrent sql_id,top 50 ,default threshold is 500. your selection is $cnt"
  exit 0
fi

#####################################################################################################

if [ "$1" = "highparse2" ]; then
    
   if [ "$2" = "" ]; then
    cnt=10
   else
    cnt=$2
   fi

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 600
    
    col sql_text format a150
    col sql_id format a13
    column FORCE_MATCHING_SIGNATURE format 99999999999999999999999
    col MIN_SQL_ID format a13
    
    spool ora_highparse2_$filedate.log
    
    WITH c AS
        (SELECT  FORCE_MATCHING_SIGNATURE,COUNT(*) cnt,max(sql_id) as min_sql_id
         ,min(optimizer_cost) as min_cost,max(optimizer_cost) as max_cost
         ,round(sum(cpu_time/1e6)) as sum_cpu_s,round(sum(elapsed_time/1e6)) as sum_elap_s
         ,round(sum(physical_read_bytes/1e3)) as read_k
        FROM     gv\$sqlarea
        WHERE    FORCE_MATCHING_SIGNATURE!=0
        GROUP BY FORCE_MATCHING_SIGNATURE
        HAVING   COUNT(*) > =$cnt   -- (P.S. You can run this query with larger values say 1000)
        )
    select rownum as rn,x.* from 
    (SELECT *             
     FROM   c
    ORDER BY sum_cpu_s DESC
    ) x where rownum<=50;
    $ECHO
    spool off
    
!
echo "full nodes"
echo "show same FORCE_MATCHING_SIGNATURE with diffrent sql_id,top 50 ,default threshold is 10. your selection is $cnt"
  exit 0
fi

#####################################################################################################

if [ "$1" = "pc" ]; then

    if [ "$2" = "" ]; then
      awr_his=8
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10
col sql_id format a13
col phvs format 99

spool ora_PC_$filedate.log

with base_info as
(
select  parsing_schema_name as exec_user,
        sql_id, plan_hash_value as phv,
        executions as execs,
        elapsed_time as ela
        from gv\$sql where plan_hash_value>0 and elapsed_time>0
union all        
select  parsing_schema_name,
        sql_id, plan_hash_value,
        executions_delta as execs,
        elapsed_time_delta
        from DBA_HIST_SQLSTAT 
        where plan_hash_value>0 and elapsed_time_delta>0
              and snap_id >= (select min(snap_id) from dba_hist_snapshot where begin_interval_time>=sysdate-$awr_his)
),tmp_gby as
(
  select exec_user,sql_id,phv,sum(ela) as sum_ela,greatest(sum(execs),1) as sum_execs
      ,round(sum(ela)/greatest(sum(execs),1)) as avg_etime
  from base_info
  group by exec_user,sql_id,phv
),tmp_ana as
(select sql_id, exec_user,phv as best_phv, sum_execs as b_sum_execs, avg_etime as b_avg_etime
 ,round(stddev(avg_etime) over (partition by exec_user,sql_id)) as stddev_etime
 ,count(phv) over(partition by exec_user,sql_id) as phvs
 ,first_value(phv)       over (partition by exec_user,sql_id order by avg_etime desc)as worst_phv
 ,first_value(sum_execs) over (partition by exec_user,sql_id order by avg_etime desc)as w_sum_execs
 ,first_value(avg_etime) over (partition by exec_user,sql_id order by avg_etime desc)as w_avg_etime
 ,row_number() over(partition by exec_user,sql_id order by avg_etime) as rn
from tmp_gby 
)select * from 
( select sql_id,exec_user,phvs--,stddev_etime
     ,best_phv,b_sum_execs ,round(b_avg_etime/1e6,4) as b_avg_etime_s
     ,worst_phv,w_sum_execs,round(w_avg_etime/1e6,4) as w_avg_etime_s
     ,round(stddev_etime/b_avg_etime) as norm_stddev
     ,round(w_avg_etime/b_avg_etime,1) as ratio
from tmp_ana a 
where phvs>1 and rn=1 and stddev_etime/b_avg_etime>1
order by stddev_etime/b_avg_etime desc
) where rownum<=50 order by norm_stddev;
$ECHO

spool off   
   
!
echo "full nodes. for recent $awr_his (given) days"
exit 0
fi


#####################################################################################################

if [ "$1" = "pc2" ]; then

    if [ "$2" = "" ]; then
      awr_his=8
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10
col sql_id format a13
col phvs format 99
col B_LAST_TIME format a11
col curr_last_time format a11
col ratio format 9999999
col STDDEV format 999999

spool ora_PC2_$filedate.log

with base_info as
(
select  parsing_schema_name as exec_user,
        sql_id, plan_hash_value as phv,
        executions as execs,
        elapsed_time as ela,
        LAST_ACTIVE_TIME as last_exec_time
        from gv\$sql 
        where plan_hash_value>0 and elapsed_time>0
union all        
select  parsing_schema_name,
        sql_id, plan_hash_value,
        executions_delta as execs,
        elapsed_time_delta,
        cast(begin_interval_time as date)
        from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
        where ss.snap_id = S.snap_id
        and ss.instance_number = S.instance_number 
        and SS.end_INTERVAL_TIME > sysdate-31
        and plan_hash_value>0 and elapsed_time_delta>0
),tmp_gby as
(
select sql_id,exec_user,phv,sum(ela) as sum_ela,greatest(sum(execs),1) as sum_execs
      ,round(sum(ela)/greatest(sum(execs),1)) as avg_etime
      ,max(last_exec_time) as max_exec_time
from base_info
group by sql_id,exec_user,phv
),tmp_ana as
(select sql_id,exec_user, phv as best_phv, sum_execs as b_sum_execs, avg_etime as b_avg_etime,max_exec_time as b_last_time
 ,round(stddev(avg_etime) over (partition by exec_user,sql_id)) as stddev_etime
 ,count(phv) over(partition by exec_user,sql_id) as phvs
 ,first_value(phv) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_phv
 ,first_value(sum_execs) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_sum_execs
 ,first_value(avg_etime) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_avg_etime
 ,first_value(max_exec_time) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_last_time
 ,row_number() over(partition by exec_user,sql_id order by avg_etime) as rn
from tmp_gby 
)select * from --tmp_ana where sql_id='0wqx6mfuhashb'
( select sql_id,exec_user,phvs--,stddev_etime
     ,best_phv,b_sum_execs as b_execs ,round(b_avg_etime/1e6,4) as b_avg_s,to_char(b_last_time,'mmdd hh24miss') as b_last_time
     ,curr_phv,curr_sum_execs as curr_execs,round(curr_avg_etime/1e6,4) as curr_avg_s,to_char(curr_last_time,'mmdd hh24miss') as curr_last_time
     ,round(stddev_etime/b_avg_etime) as stddev
     ,round(curr_avg_etime/b_avg_etime,1) as ratio
     ,case when curr_last_time>b_last_time then 'not' else '--' end as res
from tmp_ana a 
where phvs>1 and rn=1 and stddev_etime/b_avg_etime>1
order by stddev_etime/b_avg_etime desc
) where rownum<=50 order by stddev;
$ECHO

spool off   
   
!
echo "full nodes. for recent $awr_his(given) days"
exit 0
fi


#####################################################################################################

if [ "$1" = "pc_old" ]; then

    if [ "$2" = "" ]; then
      awr_his=31
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10

spool ora_PC_OLD$filedate.log

--find plan change sql_id in (gv\$sql and dba_hist_sqlstat recent n days )
--awr history in days
--define awr_his=7
--ACCEPT awr_his DEFAULT &awr_his PROMPT 'Please input recent awr days ,default is [&awr_his]:'
define exclude_users='and PARSING_SCHEMA_NAME not in (''SYS'',''SYSMAN'',''DBSNMP'')' 
--define order_by='order by w_sum_exec'
--define order_by='order by b_sum_execs'
define order_by='order by ratio'

set term off

with plan_sum as (  
  select sql_id,PARSING_SCHEMA_NAME, plan_hash_value
    ,sum(elapsed_time_delta) sum_ela
    ,ROUND((SUM(elapsed_time_delta)/SUM(GREATEST(executions_delta, 1))) ) avg_ela
    ,SUM(executions_delta) sum_exec
    from (
          select sql_id,plan_hash_value,elapsed_time_delta,executions_delta,PARSING_SCHEMA_NAME from dba_hist_sqlstat  
          where  snap_id >= (select min(snap_id) from dba_hist_snapshot where begin_interval_time>=sysdate-$awr_his)
            and  plan_hash_value > 0 and elapsed_time_delta>0
            $DEFDISP &exclude_users
          union all 
          select sql_id,plan_hash_value,elapsed_time,executions,PARSING_SCHEMA_NAME from gv\$sql
          where plan_hash_value > 0 and elapsed_time>0
            $DEFDISP &exclude_users
          )a
    group by sql_id,PARSING_SCHEMA_NAME, plan_hash_value --having SUM(executions_delta)>0
 ),
 ana_plan as 
(
 select * from 
 (
  select 
        sql_id,PARSING_SCHEMA_NAME,plan_hash_value
       ,sum_ela
       ,sum_exec 
       ,avg_ela 
       ,count(*) over (partition by sql_id,PARSING_SCHEMA_NAME)  total_plans 
       ,max(avg_ela) over (partition by sql_id,PARSING_SCHEMA_NAME) as max_avg_ela 
       ,min(avg_ela) over (partition by sql_id,PARSING_SCHEMA_NAME) as min_avg_ela
      -- ,row_number() over (partition by sql_id,PARSING_SCHEMA_NAME order by avg_ela) as rn
   from plan_sum
 ) where total_plans>1
)
 select 
  b_plan.sql_id,b_plan.PARSING_SCHEMA_NAME as exec_user
 ,b_plan.total_plans as plans
 ,b_plan.plan_hash_value as b_PHV
 ,w_plan.plan_hash_value as w_PHV
 ,round(b_plan.sum_ela/1e6,4) as b_sum_ela
 ,round(w_plan.sum_ela/1e6,4) as w_sum_ela
 ,b_plan.sum_exec as b_sum_execs
 ,w_plan.sum_exec as w_sum_exec
 ,round(b_plan.avg_ela/1e6,4) as b_avg_ela
 ,round(w_plan.avg_ela/1e6,4) as w_avg_ela
 ,round( w_plan.avg_ela/ b_plan.avg_ela,1) as ratio
 from (select * from ana_plan where avg_ela=min_avg_ela) b_plan,
      (select * from ana_plan where avg_ela=max_avg_ela) w_plan
 where 
     b_plan.sql_id=w_plan.sql_id  
 and b_plan.PARSING_SCHEMA_NAME=w_plan.PARSING_SCHEMA_NAME 
 and round( w_plan.avg_ela/ b_plan.avg_ela,1) >=1.5
 and ((w_plan.avg_ela/1e6 >=1) or ( w_plan.avg_ela/1e6 <1 and  w_plan.sum_exec >=1))
&order_by;
$ECHO

spool off   
   
!
echo "full nodes"
 echo "plan change info for recent $awr_his days. default is 7 "
  exit 0
fi


#####################################################################################################

if [ "$1" = "toparea" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 300 pagesize 30
    
    col db_user format a10 trunc
    col "wait/elap" format a10
    col sql_text format a25
    col rank format 9999
    col avg_buffer format 99999999
    col rc format 999
    col rr format 999
    col rt format 999
    col inst_id format 99
    col sql_id format a14
    spool ora_toparea_$filedate.log
    select a.*
    from
      (select inst_id as inst_id,
            row_number() over (partition by inst_id order by cpu_time desc) as rc,
            row_number() over (partition by inst_id order by disk_reads desc) as rr,
            row_number() over (partition by inst_id order by elapsed_Time desc) as rt,
            PARSING_SCHEMA_NAME db_USER,
            sql_id,
            round(cpu_time/1e6) as cpu_s ,
            round(elapsed_Time/1e6) as elap_s ,
            round((elapsed_Time - cpu_time)/1e6) wait_s,
            trunc((elapsed_Time - cpu_time)*100/greatest(elapsed_Time,1),1)||'%' as "wait/elap",
            executions as execs,
            round(elapsed_Time/(executions+1)/1e6,2) ela_Pe,
            buffer_gets as tot_bufs,
            round(buffer_gets/greatest(executions,1),1) as avg_buf,
            disk_reads as reads,
            round(USER_IO_WAIT_TIME/1e6) as IOwait_s,
            substr(sql_text,1,25) sql_text
            from gv\$sqlarea t where inst_id=$INST
            --where elapsed_time > 20000　and PARSING_SCHEMA_NAME<>'SYS'
        ) a
    where rc <=5 or rr<=5 or rt<=5
    order by inst_id,rc;
$ECHO
spool off
   
!
echo "instance_number=$INST"
  exit 0
fi


#####################################################################################################

if [ "$1" = "rman" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600
    --set head off
    
    Pro rman backup status:

    select * from 
    (
    SELECT recid,operation,status,to_char(start_time,'yyyy-mm-dd hh24:mi:ss') as start_time
     ,to_char(end_time,'yyyy-mm-dd hh24:mi:ss') as end_time,object_type 
    FROM V\$RMAN_STATUS 
    WHERE START_TIME >= sysdate-100    AND OPERATION ='BACKUP'
     -- AND STATUS ='COMPLETED'  
    order by start_time desc
    )
    where rownum<=50;
    $ECHO


    Pro recovery_file_dest usage:
    
    col name format a60
    SELECT NAME,
           round(SPACE_LIMIT / 1024 / 1024 / 1024) SPACE_LIMIT_GB,
           round((SPACE_LIMIT - SPACE_USED + SPACE_RECLAIMABLE) / 1024 / 1024 / 1024) AS SPACE_AVAILABLE_GB,
           ROUND((SPACE_USED - SPACE_RECLAIMABLE) / SPACE_LIMIT * 100, 1) AS PERCENT_USED
      FROM V\$RECOVERY_FILE_DEST;
    $ECHO
    
!
  exit 0
fi


#####################################################################################################

if [ "$1" = "batch_osstat" -o "$1" = "osstat" ]; then

    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi
   
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 100
    col END_SNAP_TIME format a20
    col inst_id format 9999
    spool ora_batch_osstat_${INST}_$filedate.log
    select os.instance_number as inst_id
         ,s.snap_id-1 as bid
         ,s.snap_id as eid
         ,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss')  end_snap_time
         , round(load,2) as load
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(busy_time/(busy_time+idle_time)*100,2))   busy_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(user_time/(busy_time+idle_time)*100,2))   user_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(sys_time/(busy_time+idle_time)*100,2))     sys_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(idle_time/(busy_time+idle_time)*100,2))    idl_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(wio_time/(busy_time+idle_time)*100,2))     wio_pct
       from (select snap_id
            , instance_number
            , dbid
            , count(*)                                                        cnt
            , sum(decode(stat_name,'LOAD',value,0))                        load
            , sum(decode(stat_name,'BUSY_TIME',value-prev_value,0))   busy_time
            , sum(decode(stat_name,'IDLE_TIME',value-prev_value,0))   idle_time
            , sum(decode(stat_name,'USER_TIME',value-prev_value,0))   user_time
            , sum(decode(stat_name,'SYS_TIME',value-prev_value,0))     sys_time
            , sum(decode(stat_name,'IOWAIT_TIME',value-prev_value,0))  wio_time
            from (select snap_id
                 , instance_number
                 , dbid
                 , stat_name
                 , value
                 , lag(value,1) over (partition by stat_name,instance_number, dbid
                                      order by snap_id)   prev_value
                  from dba_hist_osstat
                  where snap_id >=$bid and snap_id <=$eid
                  and dbid = (select dbid from v\$database)
                  and instance_number = $INST
                 )
            group by snap_id,dbid,instance_number
            ) os
      , dba_hist_snapshot s
      where os.snap_id         = s.snap_id
      and os.instance_number = s.instance_number
      and os.instance_number = $INST
      and os.dbid            = s.dbid
    order by os.instance_number,os.snap_id;
    $ECHO
    spool off
    
!
echo "instance_number=$INST"
 echo "ora osstat for recent 48 snapshots"
  exit 0
fi


#####################################################################################################

if [ "$1" = "transaction" -o "$1" = "tran" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 20
    col schemaname format a10
    col program format a15 trunc
    col sid format 999999

    select a.inst_id,a.sid,a.serial#,a.sql_id,a.prev_sql_id,a.status --as session_status
    ,a.program,schemaname
    ,b.phy_io,b.cr_get,b.cr_change,
    b.status as t_status,b.start_time
    ,(sysdate-to_date(b.start_time,'mm/dd/yy hh24:mi:ss'))*86400 as active_time_s
    from gv\$session a,gv\$transaction b
    where a.taddr=b.addr
    and a.inst_id=b.inst_id
    and a.inst_id=$INST
    order by active_time_s;
    $ECHO
    
!
echo "instance_number=$INST"
  exit 0
fi



#####################################################################################################

if [ "$1" = "obj" ]; then

   if [ "$2" = "" ]; then
       echo "ora obj %optstat%  <owner>" 
       exit 1
   fi
   
   if [ "$3" = "" ]; then
      pred=""
   else 
      pred="and a.owner=upper('$3')"
   fi
    
   #echo $2
   #pref=$2|cut -c1-1
   #str1=$2
   #echo ${str1:1:1} 
   #echo ${str1:2:10}
   #${str1:2:(20-5)} begin 2 len 15
   
   #if [ "$pref" = "=" ]; then
   # cond=" = upper($2"
   #else if [ "$pref" = "^" ]; then
   #
   #else if [ "$pref" = "*" ]; then
   # fi
    
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 40
    set tab      off
    col object_name format a30
    col owner format a15 trunc
    col SYNONYM_DB_LINK format a15 trunc
    col SYNONYM_OWNER format a15 trunc
    col object_type format a11 trunc
    col synonym_table format a10 trunc 
    col table_name format a30
    col created format a17
    col LAST_DDL format a17
    col status format a6 trunc
    
    select a.owner,object_name,object_id,--data_object_id,
            object_type,status
           ,to_char(created,'yyyymmdd hh24:mi:ss') as created
           ,to_char(last_ddl_time,'yyyymmdd hh24:mi:ss') as last_ddl
           --,b.table_owner as synonym_owner,
           ,b.table_name as synonym_table,b.db_link as synonym_db_link
    from dba_objects a,dba_synonyms b
    where object_name like upper('$2')
         and a.object_name=b.synonym_name(+)
         and a.owner=b.owner(+) $pred
    order by a.owner,a.object_name;
    $ECHO
    --select * from dba_synonyms 
    --where synonym_name like upper('%$2%');
    
!
#echo "ora obj %abc%  [owner] "
  exit 0
fi



#####################################################################################################

if [ "$1" = "table" ]; then

#   if [ "$2" = "" -o "$3" = "" ]; then
#      echo "ora table table_name owner"
#      exit 1
#   fi

  ## if [ "$2" = ""  ]; then
  ##    echo "ora table table_name [owner]"
  ##    exit 1
  ## fi
  
  if [ "$2" = ""  ]; then
   read -p "Please input table_name:" tablename
    if [ -z "${tablename}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    tablename=$2
  fi   
   
   if [ "$3" = ""  ]; then
    
    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_tables where table_name=upper('$tablename') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    #defowner=`echo "select trim(12345||owner) as owner from dba_tables where table_name=upper('$tablename') and rownum<=1;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-30`
    if [ -z "${defowner}" ];then
       echo "table $tablename not found,please check again!"
       exit 1
    fi
   read -p "Please input table_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else 
    owner=$3   
  fi
    
    ver2=`get_ver 2`
    if [ $ver2 -lt 11 ]; then
      ver2='--'
    else
      ver2=''
    fi
    
#    owner=$2
#    tablename=$3
   
    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 30

    col filename new_value filename
    col filename format a30
    select replace(upper('$tablename'),'$','_') as filename from dual;
    
    --in case of \$ in table_name:
    spool ora_table_${tablename}_${filedate}.log
     
    $DEFNODISP pro
    $DEFNODISP pro
    $DEFNODISP prompt Dependencies  info:
    $DEFNODISP 
    $DEFNODISP col referenced_name format a30
    $DEFNODISP col referenced_owner format a30
    $DEFNODISP col owner format a30
    $DEFNODISP col name format a30
    $DEFNODISP 
    $DEFNODISP SELECT referenced_owner,referenced_name,owner,name,type,dependency_type
    $DEFNODISP FROM dba_dependencies 
    $DEFNODISP where referenced_name=upper('$tablename') and referenced_owner=upper('$owner'); 
    $DEFNODISP $ECHO    

    $DEFNODISP pro
    $DEFNODISP pro
    $DEFNODISP Pro Child Table:
    $DEFNODISP col child_owner format a30
    $DEFNODISP col child_table format a30
    $DEFNODISP col constraint_name format a30
    $DEFNODISP col r_constraint_name format a30
    $DEFNODISP 
    $DEFNODISP select --r_owner parent_owner,
    $DEFNODISP owner as child_owner,table_name as child_table,constraint_name,r_constraint_name,delete_rule,status
    $DEFNODISP from dba_constraints 
    $DEFNODISP where constraint_type='R' and (r_owner , r_constraint_name) in 
    $DEFNODISP (select /*+ no_merge */owner,constraint_name 
    $DEFNODISP from dba_constraints where owner=upper('$owner') and table_name=upper('$tablename') );
    $DEFNODISP $ECHO
    $DEFNODISP Pro Parent Table:
    $DEFNODISP --find parent
    $DEFNODISP select owner as parent_owner,table_name as parent_table
    $DEFNODISP ,constraint_name,constraint_type
    $DEFNODISP  from dba_constraints where (owner,constraint_name) in
    $DEFNODISP (select r_owner,r_constraint_name from dba_constraints 
    $DEFNODISP  where owner=upper('$owner') and table_name=upper('$tablename') and constraint_type='R'
    $DEFNODISP  );
    $DEFNODISP  $ECHO

    pro
    pro
    prompt Table partitions (Top 50 order by pos asc):

    col high_value format a40 trunc
    col partition_name format a30 trunc
    col pos format 999
    col tablespace_name format a15 trunc
    set long 500000
    select * from 
    (
    select PARTITION_POSITION pos, PARTITION_NAME, SAMPLE_SIZE, 
           NUM_ROWS, BLOCKS, HIGH_VALUE, 
           to_char(LAST_ANALYZED,'yyyy-mm-dd hh24:mi:ss') as last_analyzed
           ,TABLESPACE_NAME
    from dba_tab_partitions
    where table_owner = UPPER('$owner')
      and table_name  = upper('$tablename')
    order by partition_position
    ) where rownum<=50;
    $ECHO

    pro
    pro
    prompt Table partition by:
    col column_name format a30

    select column_name,column_position 
    from dba_part_key_columns 
    where owner=upper('$owner') and name=upper('$tablename') and object_type='TABLE' 
    order by column_position;
    $ECHO


    pro
    pro
    prompt Table subpartition by: 
    col column_name format a30
    select column_name,column_position 
    from dba_subpart_key_columns 
    where owner=upper('$owner') and name=upper('$tablename') 
    and object_type='TABLE' 
    order by column_position;
    $ECHO
    
     pro
     pro
     Pro Partition info (top pos 50): 
     col partition_name format a20 trunc
     col owner format a15 trunc
     col part_cnt format 99999
     select * from 
     (
     select --table_owner as owner,table_name ,
            partition_name,subpartition_count as sub_cnt 
           ,partition_position as part_pos--,tablespace_name
           ,pct_free,logging,compression,num_rows
           ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed
           ,count(*) over () as part_cnt
           --,interval--,segment_created 
    from dba_tab_partitions
    where table_name=upper('$tablename') and table_owner=upper('$owner')
    order by part_pos desc
    )
    where rownum<=50;
    $ECHO


    pro
    pro
    prompt dba_tab_modifications (top partition_name 50):

    col partition_name format a20 trunc
    col table_owner format a20
    col flush_time format a20
     
     select * from 
     (
      select b.table_owner,b.TABLE_NAME,b.partition_name    
              ,b.INSERTS,b.UPDATES,b.DELETES               
              ,to_char(b.TIMESTAMP,'yyyy-mm-dd hh24:mi:ss') as flush_time
              ,b.TRUNCATED             
      --,b.DROP_SEGMENTS  
      from dba_tab_modifications b
      where table_name=upper('$tablename') and table_owner=upper('$owner')
      order by partition_name 
    ) where rownum<=50;
    $ECHO

    pro
    pro
    prompt Table Statistics history:

    col table_name format a20 trunc
    col owner format a15  trunc
    col savtime format a20
    --col perc format a5
    SELECT *
      FROM 
    (SELECT /*+ NO_MERGE LEADING(pt s t m) */
           t.table_name ,
           t.owner,
           'CURRENT' version_type,
           NULL savtime, 
           t.last_analyzed analyzetime, 
           t.num_rows rowcnt, 
           t.sample_size samplesize, 
           CASE WHEN t.num_rows > 0 THEN (ROUND(t.sample_size * 100 / t.num_rows,1)) END perc, 
           t.blocks blkcnt, 
           t.avg_row_len avgrln
      FROM  dba_tables t
     WHERE t.owner = upper('$owner') and
           t.table_name=upper('$tablename')
    UNION ALL
    SELECT /*+ NO_MERGE LEADING(s t m) */
           t.object_name,
           t.owner,
           'HISTORY' version_type,
           to_char(h.savtime, 'yyyy-mm-dd hh24:mi:ss') as savetime,
           h.analyzetime, 
           h.rowcnt, 
           h.samplesize, 
           CASE WHEN h.rowcnt > 0 THEN (ROUND(h.samplesize * 100 / h.rowcnt, 1)) END perc, 
           h.blkcnt, 
           h.avgrln
      FROM dba_objects t,
           sys.WRI\$_OPTSTAT_TAB_HISTORY h  -------------------no dba_hist view?
     WHERE t.owner = upper('$owner')
       and t.object_name=upper('$tablename')
       AND t.object_id = h.obj#
       AND t.object_type = 'TABLE' 
     )
     ORDER BY
           table_name,owner,savtime DESC NULLS FIRST;
     $ECHO           
        
    pro
    pro
    Pro Index statistics : 
    set linesize 180 pagesize 100
    col idx_type format a10 trunc
    col deg format a3 
    col vis format a3
    col cols format 99
    col lv format 99
    col index_name format a30
    col locked format a5 
    col LAST_ANALYZED format a20
    
    SELECT /*+ NO_MERGE LEADING(pt s i) */
          -- s.table_name,
          -- s.table_owner,
           s.index_name,
          -- s.owner,
           decode(i.index_type,'FUNCTION-BASED NORMAL','F_normal',i.index_type) as idx_type,
           --i.partitioned,
           --i.degree as deg,
           --i.temporary,
           --i.status,
           --decode(i.VISIBILITy,'VISIBLE','Y','N') as vis,
           --decode(i.uniqueness,'NONUNIQUE','N','UNIQUE','Y','N/A') as uni,
           (SELECT COUNT(*)
              FROM dba_ind_columns c
             WHERE c.index_owner = s.owner
               AND c.index_name = s.index_name
               AND c.table_owner = s.table_owner
               AND c.table_name = s.table_name) cols,
           s.num_rows,
           --s.sample_size,
           --CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
           TO_CHAR(s.last_analyzed, 'YY-MM-DD/HH24:MI:SS') last_analyzed,
           s.distinct_keys as DK,
           s.blevel as lv,
           s.leaf_blocks as lf_blks,
           s.avg_leaf_blocks_per_key as LF_key,
           s.avg_data_blocks_per_key as DB_Key,
           s.clustering_factor as CF,
           --s.global_stats,
           --s.user_stats,
           s.stattype_locked as locked,
           s.stale_stats as stale
      FROM --plan_tables pt,
           dba_ind_statistics s,
           dba_indexes i
     WHERE --pt.object_type = 'TABLE'
       --AND pt.object_owner = s.table_owner
       --AND pt.object_name = s.table_name
           s.table_owner=upper('$owner')
       AND s.table_name=upper('$tablename')
       AND s.object_type = 'INDEX'
       AND s.owner = i.owner
       AND s.index_name = i.index_name
       AND s.table_owner = i.table_owner
       AND s.table_name = i.table_name
     ORDER BY s.index_name;    
     $ECHO
     
     
    PRO
    pro
    pro Table Columns info: 
    col owner format a12
    col table_name format a30
    col table_owner format a15 trunc
    col column_name format a25
    col data_type format a10 trunc
    col low_val_25 format a25
    col high_val_25 format a25
    col histogram format a9 trunc
    col NULLABLE format a5
    col ndv format 999999999
    col nul format a3

    select --owner,table_name,
    column_name,num_distinct as ndv,NULLABLE as nul ,NUM_NULLS,data_type,
    substr(low_value,1,25) as low_val_25,substr(high_value,1,25) as high_val_25,
    to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
    histogram
    --,NUM_BUCKETS
    from dba_tab_columns
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by column_name;
    $ECHO
    
    pro
    pro
    Pro Table current statistics with partition: 
    col stale format a5
    col owner format a10 trunc
    col table_name format a30 trunc
    col last_analyzed format a20
    col partition_name format a30
    col pos format 999
    select owner,table_name,
       partition_name,partition_position as pos,num_rows,blocks
      ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed
      ,stattype_locked as locked,stale_stats as stale
    from dba_tab_statistics 
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by partition_position;
    $ECHO
    
    
   
    pro
    pro
    prompt Table Index info: 
    col index_name format a30
    col table_owner format a10 trunc
    col table_name format a30
    col INDEX_TYPE format a10 trunc
    col degree format a7
    col TABLESPACE_NAME format a20 trunc
    col INDEX_PARTITION format a10 trunc
    col temp format a4
    select --a.table_owner,a.table_name,
          a.index_name,a.status,
          $ver2 decode(a.visibility,'INVISIBLE','---NO---','YES') as visible,
          decode(a.uniqueness,'UNIQUE','YES','NO') uniq
          ,a.index_type,a.blevel,trim(degree) as degree,
          temporary as temp,TABLESPACE_NAME,
          decode(b.LOCALITY,null,'NO','GLOBAL','GLOBAL PARTITIONED','LOCAL') as index_partition
    from dba_indexes a,DBA_PART_INDEXES b
    where a.table_name=upper('$tablename') and  a.table_owner=upper('$owner')
    and a.owner=b.owner(+) and a.table_name=b.table_name(+) and a.index_name=b.index_name(+);
    $ECHO
    
    pro
    pro
    prompt Table Index columns:  

    col table_name format a30
    col index_name format a30
    col column_name format a30
    col uniq format a4
    col idx_type format a10
    col pos format 99
    break on INDEX_NAME skip 1

    select col.table_name--, decode(ind.uniqueness,'UNIQUE','YES','NO') uniq
     --,decode(ind.index_type,'FUNCTION-BASED NORMAL','FB_Normal',ind.index_type) idx_type
     ,col.index_name  
     ,col.column_name
     ,col.column_position as pos
     --,status
     --,visibility
   from   dba_ind_columns  col,
          dba_indexes      ind
   where  col.table_owner = ind.table_owner
    and  col.index_name = ind.index_name
    and  col.table_name = ind.table_name
    and  ind.table_owner = upper('$owner') 
    and  ind.table_name  = upper('$tablename') 
   order by col.table_name, col.index_name, col.column_position ;
   $ECHO
   clear break
    
    pro
    pro
    Pro Table Basic Info: 
    col owner format a10 trunc
    col table_name format a20 trunc
    col degree format a7
    col temporary format a4
    col segment_created format a5
    col logging format a5
    col compression format a9
    col created format a20
    col last_analyzed format a20
    col TABLESPACE_NAME format a15
    select a.owner,table_name,
           num_rows,blocks,trim(degree) as degree,a.temporary,
           a.logging,--a.segment_created,
           a.partitioned,a.compression,TABLESPACE_NAME,
           to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
           to_char(b.created,'yyyy-mm-dd hh24:mi:ss') as created
    from dba_tables a,dba_objects b
    where table_name=upper('$tablename') and a.owner=upper('$owner')
          and a.owner=b.owner and b.object_name=a.table_name and b.object_type='TABLE';
    $ECHO
    
    pro
    pro
    prompt Segment info: 
    col segment_name format a30
    col max_tbs_name format a30
    select owner,segment_name,round(sum(bytes)/1024/1024) seg_size_M ,count(*) as segment_cnt
           ,max(tablespace_name) as max_tbs_name
    from dba_segments 
    where  segment_name=upper('$tablename') and owner=upper('$owner')
    group by owner,segment_name;
    $ECHO
   

    spool off     
!

  exit 0
fi

#####################################################################################################


if [ "$1" = "source" ]; then

    if [ "$2" = "" ]; then
       echo "ora source <keyword to find in dba_source>"
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
   
    set linesize 250 pagesize 1000
    col owner for a20 trunc
    col name for a30
    col line head LINE# for 999999
    col text for a100 trunc
    col type format a15

    select 
        owner,
        name,
        type,
        line, 
        text
    from 
        dba_source
    where 
    lower(text) like lower('%$2%')
    order by
        owner,name,type, line ;
    $ECHO
    
!
  exit 0
fi


#####################################################################################################

if [ "$1" = "x" ]; then

   if [ "$2" = "" ]; then
    echo "ora x <sql_id>"
    exit 1
   fi
   
  sqlid=$2
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 600
    set tab      off
    col plan_table format a180
    Pro Display sql execution plan in AWR:
    select * from table(dbms_xplan.display_awr('$sqlid',format=>'advanced -PROJECTION'));
    $ECHO    
!
  exit 0
fi


########################################################################################
if [ "$1" = "xp" ]; then

  if [ "$2" = "" ]; then
    echo  "ora xp <sql_id in mem>"
    exit 1
  fi


    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 200
    set tab      off
    set linesize 150
    set echo off
    repfooter off;
    Pro Display sql execution plan in Cursor (memory) :
    select * from table(dbms_xplan.display_cursor('$2', null, 'advanced -bytes -PROJECTION allstats last'));
    $ECHO
!
echo "current instance"
exit 0

fi


########################################################################################
if [ "$1" = "xpo" ]; then

  if [ "$2" = "" ]; then
    echo  "ora xpo <sql_id> <child_number>"
    exit 1
  fi
  
    if [ "$3" = "" ]; then
      childno=0
    else
      childno=$3
    fi


    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
     
    set verify off
    set define on 
    --set linesize 150 pagesize 200
    define v_xc_version = 1.2

    
    -- Main Xplan SQL...
    -- -----------------
    set termout on lines 250 pages 200
    col plan_table_output format a200

    with sql_plan_data as (
            select  id, parent_id
            from    gv\$sql_plan
            where   inst_id = sys_context('userenv','instance')
            and     sql_id = '$2'
            and     child_number = $childno
            )
    ,    hierarchy_data as (
            select  id, parent_id
            from    sql_plan_data
            start   with id = 0
            connect by prior id = parent_id
            order   siblings by id desc
            )
    ,    ordered_hierarchy_data as (
            select id
            ,      parent_id as pid
            ,      row_number() over (order by rownum desc) as oid
            ,      max(id) over () as maxid
            from   hierarchy_data
            )
    ,    xplan_data as (
            select /*+ ordered use_nl(o) */
                   rownum as r
            ,      x.plan_table_output as plan_table_output
            ,      o.id
            ,      o.pid
            ,      o.oid
            ,      o.maxid 
            ,      count(*) over () as rc
            from   table(dbms_xplan.display_cursor('$2',$childno,'advanced -PROJECTION allstats,last')) x
                   left outer join
                   ordered_hierarchy_data o
                   on (o.id = case
                                 when regexp_like(x.plan_table_output, '^\|[\* 0-9]+\|')
                                 then to_number(regexp_substr(x.plan_table_output, '[0-9]+'))
                              end)
            )
    select plan_table_output
    from   xplan_data
    model
       dimension by (rownum as r)
       measures (plan_table_output,
                 id,
                 maxid,
                 pid,
                 oid,
                 greatest(max(length(maxid)) over () + 3, 6) as csize,
                 cast(null as varchar2(128)) as inject,
                 rc)
       rules sequential order (
              inject[r] = case
                             when id[cv()+1] = 0
                             or   id[cv()+3] = 0
                             or   id[cv()-1] = maxid[cv()-1]
                             then rpad('-', csize[cv()]*2, '-')
                             when id[cv()+2] = 0
                             then '|' || lpad('Pid |', csize[cv()]) || lpad('Ord |', csize[cv()])
                             when id[cv()] is not null
                             then '|' || lpad(pid[cv()] || ' |', csize[cv()]) || lpad(oid[cv()] || ' |', csize[cv()]) 
                          end, 
              plan_table_output[r] = case
                                        when inject[cv()] like '---%'
                                        then inject[cv()] || plan_table_output[cv()]
                                        when inject[cv()] is not null
                                        then regexp_replace(plan_table_output[cv()], '\|', inject[cv()], 1, 2)
                                        else plan_table_output[cv()]
                                     end ||
                                     case
                                        when cv(r) = rc[cv()]
                                        then  chr(10) ||
                                             'About'  || chr(10) || 
                                             '------' || chr(10) ||
                                             '  - XPlan v&v_xc_version by Adrian Billington (http://www.oracle-developer.net)'
                                     end 
             )
    order  by r;
    $ECHO
    
    pro sql child numbers:
    
    select distinct child_number,PLAN_HASH_VALUE from gv\$sql_plan where sql_id='$2';
!

exit 0

fi


#####################################################################################################

if [ "$1" = "xo" ]; then

   if [ "$2" = "" ]; then
    echo "ora xo <sql_id> [phv]"
    exit 1
   fi
   
   if [ "$3" = "" ]; then
     phv=null
   else
     phv=$3
   fi
   

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set define on
    set verify off
    
    define v_xa_version = 1.2

    -- Main Xplan SQL...
    -- -----------------
    set termout on lines 200 pages 1000
    col plan_table_output format a150

    with sql_plan_data as (
            select id, parent_id, plan_hash_value
            from   dba_hist_sql_plan
            where  sql_id = '$2'
            and    plan_hash_value = nvl($phv, plan_hash_value)
            and    dbid = (select dbid from v\$database)
            )
    ,    hierarchy_data as (
            select  id, parent_id, plan_hash_value
            from    sql_plan_data
            start   with id = 0
            connect by prior id = parent_id
                   and prior plan_hash_value = plan_hash_value 
            order   siblings by id desc
            )
    ,    ordered_hierarchy_data as (
            select id
            ,      parent_id as pid
            ,      plan_hash_value as phv
            ,      row_number() over (partition by plan_hash_value order by rownum desc) as oid
            ,      max(id) over (partition by plan_hash_value) as maxid
            from   hierarchy_data
            )
    ,    xplan_data as (
            select /*+ ordered use_nl(o) */
                   rownum as r
            ,      x.plan_table_output as plan_table_output
            ,      o.id
            ,      o.pid
            ,      o.oid
            ,      o.maxid
            ,      p.phv
            ,      count(*) over () as rc
            from  (
                   select distinct phv
                   from   ordered_hierarchy_data
                  ) p
                   cross join
                   table(dbms_xplan.display_awr('$2',p.phv,format=>'advanced -PROJECTION')) x
                   left outer join
                   ordered_hierarchy_data o
                   on (    o.phv = p.phv
                       and o.id = case
                                     when regexp_like(x.plan_table_output, '^\|[\* 0-9]+\|')
                                     then to_number(regexp_substr(x.plan_table_output, '[0-9]+'))
                                  end)
            )
    select plan_table_output
    from   xplan_data
    model
       dimension by (phv, rownum as r)
       measures (plan_table_output,
                 id,
                 maxid,
                 pid,
                 oid,
                 greatest(max(length(maxid)) over () + 3, 6) as csize,
                 cast(null as varchar2(128)) as inject,
                 rc)
       rules sequential order (
              inject[phv,r] = case
                                 when id[cv(),cv()+1] = 0
                                 or   id[cv(),cv()+3] = 0
                                 or   id[cv(),cv()-1] = maxid[cv(),cv()-1]
                                 then rpad('-', csize[cv(),cv()]*2, '-')
                                 when id[cv(),cv()+2] = 0
                                 then '|' || lpad('Pid |', csize[cv(),cv()]) || lpad('Ord |', csize[cv(),cv()])
                                 when id[cv(),cv()] is not null
                                 then '|' || lpad(pid[cv(),cv()] || ' |', csize[cv(),cv()]) || lpad(oid[cv(),cv()] || ' |', csize[cv(),cv()]) 
                              end, 
              plan_table_output[phv,r] = case
                                            when inject[cv(),cv()] like '---%'
                                            then inject[cv(),cv()] || plan_table_output[cv(),cv()]
                                            when inject[cv(),cv()] is not null
                                            then regexp_replace(plan_table_output[cv(),cv()], '\|', inject[cv(),cv()], 1, 2)
                                            else plan_table_output[cv(),cv()]
                                         end || 
                                         case
                                            when cv(r) = rc[cv(),cv()]
                                            then chr(10)  ||
                                                 'About'  || chr(10) || 
                                                 '------' || chr(10) ||
                                                 '  - XPlan v&v_xa_version by Adrian Billington (http://www.oracle-developer.net)'
                                         end
             )
    order  by r;
    $ECHO
!
  exit 0
fi

####################################################################################################

if [ "$1" = "tbsinc" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 100
    set tab      off
    with max_ts_by_day as
    (
     select to_date(substr(rtime,1,10),'mm/dd/yyyy') as rday,tablespace_id
            ,max(tablespace_usedsize) as used_blocks
     from dba_hist_tbspc_space_usage 
    group by to_date(substr(rtime,1,10),'mm/dd/yyyy'),tablespace_id
    )
    select rday,round(sum(used_blocks)*8/1024/1024) as total_size_g from max_ts_by_day
    group by rday
    order by 1;
    $ECHO
    
!
  exit 0
fi

###################################################################################################

if [ "$1" = "tbs" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 20
    col autoextensible format a4 heading "autoExt"
    col tbsn format a20 trunc
    col contents format a10 trunc
    col status format a8
    col RENTENTION format a9 trunc
    col LOGGING format a8 trunc
    col manage format a6
    col files format 9999
    col owner format a20 trunc
    col blk_sz format 99999
    spool ora_tbs_$filedate.log
    pro "order by usage percent:"
    SELECT 
      d.tablespace_name tbsn,round(a.bytes/1024/1024-round(DECODE(d.contents, 'UNDO', NVL(u.bytes, 0), NVL(a.bytes - NVL(f.bytes, 0), 0))/1024/1024)) as free_M 
      ,d.STATUS status,d.contents contents,d.extent_management manage,d.segment_space_management space_manage,
      d.bigfile big,d.LOGGING logging   ,d.RETENTION rentention--,d.ENCRYPTED encry
      ,d.BLOCK_SIZE blk_sz,NVL(a.count, 1) files,
      round(DECODE(d.contents, 'UNDO', NVL(u.bytes, 0), NVL(a.bytes - NVL(f.bytes, 0), 0))/1024/1024) 
      used_M, round(a.bytes/1024/1024) total_M 
        ,round(DECODE(d.contents, 'UNDO', NVL(u.bytes, 0), NVL(a.bytes - NVL(f.bytes, 0), 0))/a.bytes*100,1) as usage_pct  ,autoextensible
    FROM sys.dba_tablespaces d,
     ( SELECT tablespace_name,SUM(bytes) bytes,SUM(maxbytes) maxb,COUNT(file_id) count ,max(autoextensible) as autoextensible
        FROM dba_data_files 
        GROUP BY       tablespace_name 
      ) a,
      ( SELECT tablespace_name,sum(bytes) bytes 
        FROM dba_free_space  --------------------------------------------------
        GROUP BY       tablespace_name 
      ) f,
      ( SELECT tablespace_name,SUM(bytes) bytes 
        FROM dba_undo_extents 
        WHERE STATUS IN ('ACTIVE', 'UNEXPIRED') 
        GROUP BY       tablespace_name 
      ) u 
    WHERE d.tablespace_name = a.tablespace_name(+) 
      AND d.tablespace_name = f.tablespace_name(+) 
      AND d.tablespace_name = u.tablespace_name(+) 
      AND NOT (d.extent_management = 'LOCAL'  AND d.contents = 'TEMPORARY') 
    UNION ALL ------------------------------------------------------------------
    SELECT d.tablespace_name tbsn,round(a.bytes/1024/1024-NVL(t.bytes,0)/1024/1024) as free_M
        ,d.STATUS tbss,d.contents tbsc,d.extent_management manage, 
       d.segment_space_management tbsm,d.bigfile tbsf,d.LOGGING tbsl,d.RETENTION tbsr--,d.ENCRYPTED tbsy
      ,d.BLOCK_SIZE blk_sz,NVL(a.count, 1) tbsi,round(NVL(t.bytes,0)/1024/1024) tbsu,round(a.bytes/1024/1024) tbsz ,
       round(NVL(t.bytes, 0)/a.bytes*100,1) as usage_pct  ,autoextensible
    FROM sys.dba_tablespaces d,
     ( SELECT tablespace_name,sum(bytes) bytes,SUM(maxbytes) maxb,count(file_id) count ,max(autoextensible) as autoextensible
        FROM dba_temp_files 
        GROUP BY       tablespace_name 
      ) a,
      ( SELECT     ss.tablespace_name,sum((ss.used_blocks * ts.blocksize)) bytes 
        FROM gv\$sort_segment ss,sys.ts\$ ts WHERE ss.tablespace_name = ts.NAME 
        GROUP BY       ss.tablespace_name 
      ) t 
    WHERE d.tablespace_name = a.tablespace_name(+)   AND d.tablespace_name = t.tablespace_name(+)   
         AND d.extent_management = 'LOCAL'   AND d.contents = 'TEMPORARY' 
    ORDER BY usage_pct;
    $ECHO
    
    Pro Non sys user objects stored in SYS tablespace:
    select owner,count(*),round(sum(bytes/1024/1024)) as size_M 
    from dba_segments 
    where tablespace_name in ('SYSTEM','SYSAUX') 
    and owner not in ('SYS','SYSTEM','MDSYS','CTXSYS','OUTLN','OLAPSYS','DBSNMP','EXFSYS','ORDSYS','SYSMAN','XDB','ORDDATA','WMSYS') 
    group by owner;
    
    spool off
!
  exit 0
fi


##########################################################################


if [ "$1" = "binds" -o "$1" = "bind" -o "$1" = "bind_his" ]; then

  if [ "$2" = "" ]; then
    echo "ora binds <sql_id>"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 37
    set tab      off
    set linesize 220
    set echo off
    col sql_text format A75 WORD_WRAP
    repfooter off;
    col BIND_NAME format A15
    column VALUE_STRING format A40 wrap
    column CAPTURED format A10
    column LAST_CAPTURED format A20
    col sql_hash format A15
    col sql_id format A18
    col sql_text format A75 WORD_WRAP
    pro gv\$sql_bind_capture:
    select NAME BIND_NAME, POSITION POS, DATATYPE_STRING BIND_TYPE,
           WAS_CAPTURED CAPTURED,
           case
             when WAS_CAPTURED='YES' and LAST_CAPTURED is null
             then 'YES'
             else 'NO'
           end "Reverted",
           TO_CHAR(LAST_CAPTURED, 'HH:MI:SS (DD Mon)') LAST_CAPTURED,
           case datatype 
           when 180 then to_char(anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss') 
             else value_string end as VALUE_STRING
           --VALUE_STRING
    from  gv\$sql_bind_capture
    where sql_id='$2';
    $ECHO
    
    
    set linesize 150 pagesize 37
    col name format a20
    col DATATYPE_STRING format a30
    col BIND_VALUE format a40
    col POSITION format 99
    pro dba_hist_sqlbind:
    
    SELECT snap_id,LAST_CAPTURED,NAME, P.POSITION, P.DATATYPE_STRING,
    case datatype 
    when 180 then to_char(anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss') 
             else value_string end as bind_value
    from dba_hist_sqlbind p 
    where SQL_ID = '$2' and snap_id >=(select max(snap_id)-10 from dba_hist_snapshot)
    and was_captured='YES'
    order by snap_id,LAST_CAPTURED,name;
    $ECHO

!
echo "get sql binds in gv\$sql_bind_capture and dba_hist_sqlbind(recent 10 snapshots)"
exit 0
fi

################################################################################
if [ "$1" = "seg" -o "$1" = "segment" ]; then

  if [ "$2" = "" ]; then
    echo "ora seg segment_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col owner format a15 trunc
    col tablespace_name format a20 trunc
    col SEGMENT_NAME format a30
    col partition_name format a20
    Pro Segment info of $2 :
    select owner,segment_name,partition_name,segment_type,tablespace_name
          , round(bytes/(1024*1024)) Size_MB
    from dba_segments where segment_name=upper('$2')
    order by 1,2,3;
    $ECHO

!
 echo "ora seg <seg_name>"
exit 0
fi


#######################################################################################################

if [ "$1" = "big" ]; then

  echo "ora big [n def=20] "

    if [ "$2" = "" ]; then
      topn=20
    else
      topn=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

  connect $DBUSER
  
  set linesize 240
  set pagesize 30
  column segment_name    format a30;
  column owner           format a20 trunc;
  column tablespace_name format a20 trunc;
  column partition_name  format a20 trunc;
  column SEGMENT_TYPE format a20
  col rn format 99
  column Size_MB      format 999999999;
  --break  on segment_name skip 1

  -- compute sum label Total of Size_MB on segment_name;


--prompt Top segment 10 by extents:
--select * from
--(
--  select owner,tablespace_name, segment_name,partition_name,segment_type,extents
--      , round(bytes/(1024*1024)) Size_MB
--  from dba_segments 
--  order by extents desc
--)where rownum<=20;
    spool ora_big_$filedate.log
    prompt Top single segment $topn :
    
    select rownum as rn,a.* from
    (
      select owner,tablespace_name, segment_name,partition_name,segment_type
          , round(bytes/(1024*1024)) Size_MB
      from dba_segments 
      order by Size_Mb desc nulls last
    ) a where rownum<=$topn ;
    $ECHO
    
    
   prompt Top total segment $topn :
   
     select rownum as rn,a.* from
    (
      select owner, segment_name,segment_type
          , round(sum(bytes/(1024*1024))) Size_MB,count(*) as segment_cnt
      from dba_segments group by owner,segment_name,segment_type
      order by Size_Mb desc nulls last
    ) a where rownum<=$topn ;
    $ECHO
    spool off
!
exit 0
fi




####################################################################################################
if [ "$1" = "stats" -o "$1" = "optstats" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
   
    Prompt "Top 50 DBA_OPTSTAT_OPERATIONS: top 30"
    set linesize 200 pagesize 100
    col OPERATION format a30
    col target format a30 trunc
    col start_time format a20
    col SAVTIME format a20
    
    spool ora_stats_$filedate.log
   
    select * from 
    (
    select operation,target,to_char(start_time,'yyyy-mm-dd hh24:mi:ss') as start_time,
    extract( day from (end_time-start_time)) *24*60+  
    extract( hour from (end_time-start_time)) *60+  
    extract( minute from (end_time-start_time)) as duration_Min
    from DBA_OPTSTAT_OPERATIONS 
    where (target not like 'SYS.%' or target is null)--and operation like '%auto%' 
    order by start_time desc 
    ) 
    where rownum<=30;
    $ECHO
    
    Prompt All Stale Tables not locked ,last_analyzed range (group by owner):    
    col owner format a20 trunc
    col table_name format a20 trunc
    col LAST_ANALYZED format a20
    
    select owner,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') as cur_time,
        sum(case when ceil(sysdate-LAST_ANALYZED)<=1 then 1 end) days_1,
        sum(case when ceil(sysdate-LAST_ANALYZED)>1  and ceil(sysdate-LAST_ANALYZED)<=10 then 1 end) days_1_10,
        sum(case when ceil(sysdate-LAST_ANALYZED)>10 and ceil(sysdate-LAST_ANALYZED)<=30 then 1 end) days_10_30,
        sum(case when ceil(sysdate-LAST_ANALYZED)>30 then 1 end) days_30
    from dba_tab_statistics 
    where STALE_STATS='YES' AND stattype_locked not IN ('ALL', 'DATA')
    group by owner;
    $ECHO
    
    Prompt Table Stats locked (no sys created uses) top 50:
    select * from 
    (
    select owner,table_name,object_type,stattype_locked,num_rows,STALE_STATS as stale
          ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed
    from   dba_tab_statistics t
    WHERE t.stattype_locked IN ('ALL', 'DATA')
         and owner not in ('SQLTXPLAIN','SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA') 
         --and STALE_STATS
    order by last_analyzed
    )
    where rownum<=50;
    $ECHO

    pro Num_rows=0 and Stale=Y / LAST_ANALYZED is null (maybe no segment /new create) (sample 50):
    col partition_name format a15 trunc
    select a.owner,a.table_name,object_type,a.partition_name,stattype_locked,stale_stats
          ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') last_analyzed,num_rows,blocks--,bytes
    from dba_tab_statistics a--,dba_segments b
    where a.object_type='TABLE' and
       (LAST_ANALYZED is null or (num_rows=0 and STALE_STATS='YES'))
     --and (a.table_name=b.segment_name(+)  and a.owner=b.owner(+) and b.segment_type(+)='TABLE')          
     and table_name not in (select table_name from dba_tables where temporary='Y')
     and a.owner not in ('SQLTXPLAIN','SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA') 
     and rownum<=50;
     $ECHO
    --order by 1,2;
    
    prompt Stale tables(no sys users)  top 50:
    col owner format a15 trunc
    col table_name format a20 trunc
    col partition_name format a8 trunc
    col subpartition_name format a8 trunc
    col RUN_TIME format a20
    select * from 
    (
        select a.owner,a.table_name,a.partition_name,a.SUBPARTITION_NAME,num_rows,a.blocks ,b.blocks as real_blocks,
        to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
        to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') as run_time,round((sysdate-LAST_ANALYZED),2) as stale_days
        ,stattype_locked
        from dba_tab_statistics a,dba_segments b 
        where STALE_STATS='YES' --and (last_analyzed<sysdate-1)
        and a.owner not in ('SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA') 
        and a.owner not like 'APEX%'
        and (a.owner=b.owner(+) and a.table_name=b.segment_name(+) and b.segment_type(+)='TABLE')
        and sysdate-LAST_ANALYZED>1
        order by stale_days desc
    ) where rownum<=50;
    $ECHO
    
    Pro DBA_TAB_STAT_PREFS sample 20:
    col PREFERENCE_NAME format a30
    col PREFERENCE_VALUE format a70 trunc
    select * from DBA_TAB_STAT_PREFS where rownum<=20;   
    $ECHO
    
        
     Pro Dba_Autotask_task:
     col auto_collect_status format a80
     select nvl((select client_name||' '||status as auto_collect_status from Dba_Autotask_task
     where client_name='auto optimizer stats collection'),'Auto stats collection task not ENABLED!!!') as auto_collect_status 
     from dual;
     $ECHO
     
     Pro dba_autotask_client:
     col CLIENT_NAME format a50
    select client_name,status 
    from dba_autotask_client
    where client_name='auto optimizer stats collection';
    $ECHO
    
    Pro table with long Stats colleciton top 20: 
    col object_name format a30
    col temporary format a10
    select * from 
     (select * from
        (select a.owner,object_name,obj#,temporary
               ,to_char(lag(savtime) over ( order by savtime),'yyyy-mm-dd hh24:mi:ss') as start_time
               , to_char(savtime,'yyyy-mm-dd hh24:mi:ss') as savtime
               ,round((cast(savtime as date) - cast(lag(savtime) over ( order by savtime) as date))*24*60,2) as dur_min
               ,rowcnt,blkcnt
         from dba_objects a,sys.WRI\$_OPTSTAT_TAB_HISTORY b
        where a.object_id=b.obj# 
        and savtime >=(select max(start_time) from DBA_OPTSTAT_OPERATIONS where operation='gather_database_stats(auto)')
        and savtime <=(select max( end_time ) from DBA_OPTSTAT_OPERATIONS where operation='gather_database_stats(auto)')
        ) --where dur_min>1
     order by dur_min desc
     )where rownum<=20  ;
     $ECHO  
     spool off     
!
exit 0
fi




##################################################################################################

#
# Do pstack on all process
#
if [ "$1" = "pstack" ]; then
#be careful use "all" option
#ora pstack pid|all $DIR

  HOST_NAME=`uname -n`

  PID=$2
  shift 2

  if [ "$1" != "" ]; then
    DIR=$1
  else
    DIR=$T_TRC
  fi

  if [ ! -d $DIR ]; then
    echo "Directory $DIR does not exists"
  fi

  if [ "$ORACLE_SID" = "" ]; then
    echo "ORACLE_SID must be defined"
  fi

  if [ "$PID" = "all" ]; then
    ps -edf | egrep "ora_[a-z0-9]*_${ORACLE_SID}|oracle${ORACLE_SID}" | grep -v egrep | while read a; do
      set $a

      PID=$2

      TARGET_FILE="$DIR/pstack_${PID}_${HOST_NAME}.trc"

      echo >> $TARGET_FILE
      CURDATE=`date +"%T (%D)"`
      echo "######################## $CURDATE ########################" >> $TARGET_FILE

      pstack $PID >> $TARGET_FILE 2> /dev/null
      echo >> $TARGET_FILE

    done

    CURDATE=`date +"%T (%D)"`
    echo "pstack_all completed for all process at $CURDATE"

  else

    pstack $PID
    echo "pstack $PID complete"
  fi

  exit 0
fi

############################################################################################
#
# Get system state dump and place result in specified directory
#
if [ "$1" = "system_state" ]; then

  echo "may generate huge trc file , command commented!"

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set linesize 300
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    --alter session set events 'immediate trace name systemstate level 266';

    select '##'||VALUE || '/${ORACLE_SID}_ora_'|| spid ||'.trc' file_name
    from v\$parameter, v\$process
    where name = 'user_dump_dest' and pid=userenv('pid');
!

  #echo "System state file $FILE successfully produced"
  exit 0
fi


##########################################################################################

if [ "$1" = "cursor_summary" -o "$1" = "pinned_cursors" ]; then
  #
  # This query summarizes information about pinned/locked/unpinned cursors
  # and their sizes
  #

  ##create_format_functions

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"

    connect $DBUSER

    set echo off
    set lines 200
    set pages 200

    column curtyp           heading curtyp      format a6 truncate
    column lmd              heading lmd         format a2
    column pmd              heading pmd         format a2
    column pc               heading pc          format a3
    column tot              heading total       format 999999999
    column cnt              heading count       format 999999999

    column sum_heap0        heading sum0        format 999999999
    column sum_heap4        heading sum4        format 999999999
    column sum_heap6        heading sum6        format 999999999

    column cnt_heap0        heading cnt0        format 999999999
    column cnt_heap4        heading cnt4        format 999999999
    column cnt_heap6        heading cnt6        format 999999999

    column avg_heap0        heading avg0        format 999999999
    column avg_heap4        heading avg4        format 999999999
    column avg_heap6        heading avg6        format 999999999

    column max_heap0        heading max0        format 999999999
    column max_heap4        heading max4        format 999999999
    column max_heap6        heading max6        format 999999999

    select /* ora pinned_cursors */
           case
             when pc = 'PAR' and lmd = '0' and pmd = '0' then
               'Parent Freeable'
             when pc = 'PAR' and lmd = 'N' and pmd = '0' then
               'Parent Inuse'
             when pc = 'CHI' and lmd = '0' and pmd = '0' then
               'Child Freeable'
             when pc = 'CHI' and lmd = '0' and pmd = 'S' then
               'Pseudo Cursor '
             when pc = 'CHI' and lmd = 'N' and pmd = '0' then
               'Child Cached'
             when pc = 'CHI' and lmd = 'N' and pmd = 'S' then
               'Child Executing'
             else
               'Not Sure'
           end cursor_type,
           pc, lmd, pmd,
           (count(*))           cnt,
           (sum(tot))      tot,
           (count(decode(KGLOBHS0, 0, NULL, KGLOBHS0))) cnt_heap0,
           (count(decode(KGLOBHS6, 0, NULL, KGLOBHS6))) cnt_heap6,
           (sum(KGLOBHS0)) sum_heap0,
--           (sum(KGLOBHS4)) sum_heap4,
           (sum(KGLOBHS6)) sum_heap6,
           round((avg(KGLOBHS0))) avg_heap0,
--         (avg(KGLOBHS4)) avg_heap4,
           round(avg(KGLOBHS6)) avg_heap6,
           (max(KGLOBHS0)) max_heap0,
--           (max(KGLOBHS4)) max_heap4,
           (max(KGLOBHS6)) max_heap6
    from (
            select KGLOBHS0,
                   KGLOBHS4,
                   KGLOBHS6,
                   kglobhs0+kglobhs4+kglobhs6 tot,
                   decode(kglhdadr, kglhdpar, 'PAR', 'CHI') pc,
                   decode(kglhdlmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') lmd,
                   decode(kglhdpmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') pmd,
                   case
                      when KGLOBT09 = 65535 then
                            '0 PAR'
                      when KGLHDLMD = 1 and KGLHDPMD > 0 then
                            '1 PN CHI'
                      when KGLHDLMD = 1 then
                            '2 LK CHI'
                      else
                            '3 CHI'
                   end cursor_type
            from x\$kglcursor)
    group by pc, lmd, pmd
    order by pc desc, lmd, pmd;
    $ECHO

!

echo "Summarizes information about pinned/locked/unpinned cursors and their sizes"
  exit 0
fi

###########################################################################################

##if [ "$1" = "rowcache" ]; then
##  #
##  # This query summarizes information about row cache objects
##  #
##
##  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"
##
##    connect $DBUSER
##
##    set echo off
##    set lines 80
##    set pages 200
##
##    column cache_name format a30 trunc
##    column subcache_name format a30 trunc
##
##    select $INST_ID parameter, count
##    from gV\$rowcache
##    order by 1,2;
##    $ECHO
##
##    select $INST_ID cache_name, lock_mode, lock_request, count(*)
##    from gV\$rowcache_parent
##    group by $INST_ID cache_name, lock_mode, lock_request
##    order by $INST_ID cache_name, lock_mode, lock_request;
##    $ECHO
##
##    select $INST_ID cache#, subcache_name, existent, count(*)
##    from gV\$rowcache_subordinate rs
##    group by $INST_ID cache#, subcache_name, existent
##    order by $INST_ID cache#, subcache_name, existent;
##    $ECHO
##!
##
##  exit 0
##fi

#####################################################################################################

if [ "$1" = "montop" -o "$1" = "topmon" ]; then
   
   if [ "$2" = "" ]; then
     topn=20
   else
     topn=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 300 pagesize 0
SET DEF ^ TERM OFF ECHO ON AUTOP OFF VER OFF SERVEROUT ON SIZE 1000000;
SET TERM ON ECHO OFF;
set trims on
PRO 
PRO  generate top sql monitor html files
PRO

DEF sql_monitor_reports = '$topn';

set term off

SPO _sqlmon.sql;
DECLARE
  l_count NUMBER := 0;
  TYPE mon_rt IS RECORD (
    sql_id varchar2(30),
    elapsed_time number,
    sql_exec_start DATE,
    sql_exec_id NUMBER,
    sql_plan_hash_value NUMBER,
    status varchar2(10),
    username varchar2(30),
    avg_time number,
    con_cnt number );
  mon_rec mon_rt;
  mon_cv SYS_REFCURSOR;
BEGIN

    DBMS_OUTPUT.PUT_LINE('VAR mon_exec_start VARCHAR2(14);');
    DBMS_OUTPUT.PUT_LINE('VAR mon_elapsed_time NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_exec_id NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_sql_plan_hash_value NUMBER;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_status varchar2(10);');
    DBMS_OUTPUT.PUT_LINE('VAR mon_username varchar2(30);');
    DBMS_OUTPUT.PUT_LINE('VAR mon_con_cnt number;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_report CLOB;');
    DBMS_OUTPUT.PUT_LINE('VAR mon_sql_id VARCHAR2(13);');

    DBMS_OUTPUT.PUT_LINE('SET ECHO OFF FEED OFF VER OFF SHOW OFF HEA OFF LIN 3000 NEWP NONE PAGES 0 LONG 2000000 LONGC 2000 SQLC MIX TAB ON TRIMS ON TI OFF TIMI OFF ARRAY 100 NUMF "" SQLP SQL> SUF sql BLO . RECSEP OFF APPI OFF AUTOT OFF;');

    -- cursor variable to avoid error on 10g since v\$sql_monitor didn't exist then
    OPEN mon_cv FOR
    select * from                                                                               
    ( select sql_id,elapsed_time,sql_exec_start,sql_exec_id, sql_plan_hash_value,status,username,round(avg_elap/1e6) as avg_time,con_cnt 
     from                                                                                       
     (     SELECT sql_id, elapsed_time, sql_exec_start, sql_exec_id, sql_plan_hash_value,            
             row_number() over (partition by sql_id order by elapsed_time desc) as rn, 
             sum(elapsed_time) over (partition by sql_id) as total_elap,
             avg(elapsed_time) over (partition by sql_id) as avg_elap,
             count(*) over (partition by sql_id ) as con_cnt,         
             username,             
             decode(status,'EXECUTING','EXEC','DONE (ERROR)','ERROR','DONE') as status                                                       
      FROM gv\$sql_monitor WHERE process_name = 'ora' and sql_plan_hash_value>0                                         
     ) where rn=1 ORDER BY total_elap desc                                                    
    ) where rownum<=^^sql_monitor_reports.;
    LOOP
      FETCH mon_cv INTO mon_rec;
      EXIT WHEN mon_cv%NOTFOUND;

      --l_count := l_count + 1;
      --IF l_count > ^^sql_monitor_reports. THEN
      --  EXIT; -- exits loop
      --END IF;
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_sql_id := '''||mon_rec.sql_id||''';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_elapsed_time := '||lpad(round(mon_rec.elapsed_time/1e6),5,'0')||';');
      
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_start := '''||TO_CHAR(mon_rec.sql_exec_start, 'YYYYMMDDHH24MISS')||''';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_exec_id := '||TO_CHAR(mon_rec.sql_exec_id)||';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_sql_plan_hash_value := '||TO_CHAR(mon_rec.sql_plan_hash_value)||';');
      DBMS_OUTPUT.PUT_LINE('EXEC :mon_status := '''||substr(mon_rec.status,1,4)||''';');
      DBMS_OUTPUT.PUT_LINE('SPO ora_sqlmon_'||lpad(round(mon_rec.elapsed_time/1e6),5,'0')||'_'||TO_CHAR(mon_rec.sql_plan_hash_value)||'_'||mon_rec.sql_id||'_'||TO_CHAR(mon_rec.sql_exec_start, 'YYYYMMDDHH24MISS')||'_'||mon_rec.status||'_'||mon_rec.username||'_'||to_char(mon_rec.avg_time)||'_'||to_char(mon_rec.con_cnt)||'.html;');
      DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
      DBMS_OUTPUT.PUT_LINE('set term on');
      DBMS_OUTPUT.PUT_LINE('PRO <!-- begin DBMS_SQLTUNE.REPORT_SQL_MONITOR: '||mon_rec.sql_id);
      DBMS_OUTPUT.PUT_LINE('set term off');
      DBMS_OUTPUT.PUT_LINE('BEGIN');
      DBMS_OUTPUT.PUT_LINE('  :mon_report := DBMS_SQLTUNE.REPORT_SQL_MONITOR (');
      DBMS_OUTPUT.PUT_LINE('    sql_id         => :mon_sql_id,');
      DBMS_OUTPUT.PUT_LINE('    sql_exec_start => TO_DATE(:mon_exec_start, ''YYYYMMDDHH24MISS''),');
      DBMS_OUTPUT.PUT_LINE('    sql_exec_id    => :mon_exec_id,');
      DBMS_OUTPUT.PUT_LINE('    report_level   => ''ALL'',');
      DBMS_OUTPUT.PUT_LINE('    type           => ''ACTIVE'' );');
      DBMS_OUTPUT.PUT_LINE('END;');
      DBMS_OUTPUT.PUT_LINE('/');
      DBMS_OUTPUT.PUT_LINE('set term on');
      DBMS_OUTPUT.PUT_LINE('PRO end -->');
      DBMS_OUTPUT.PUT_LINE('set term off'); 
      DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');

      DBMS_OUTPUT.PUT_LINE('SELECT :mon_report FROM DUAL;');

      DBMS_OUTPUT.PUT_LINE('SELECT ''<!-- ''||TO_CHAR(SYSDATE, ''YYYY-MM-DD/HH24:MI:SS'')||'' -->'' FROM dual;');
      DBMS_OUTPUT.PUT_LINE('SPO OFF;');
    END LOOP;
    CLOSE mon_cv;
END;
/

SPO OFF;

@_sqlmon
!
#rm _sqlmon.sql
exit 0
fi

########################################################################################


if [ "$1" = "monlist" -o "$1" = "monitor_list" ]; then

    if [ "$2" = "" ]; then
      topn=50
    else
      topn=$2
    fi  

  sqlplus -s /NOLOG  << ! | egrep -v "Session altered|Connected|rows selected|successfully"

  connect $DBUSER


  set linesize 200
  set pages 30

  col sql_text format A40 trunc 
  --wrap
  col inst_id format 99
  col username format a10 trunc
  col sql_id format a14
  col date_start format a20
  col status format a6
  col sql_exec_id format 999999999
  col px_req format 999
  col px_real format 999
  spool ora_monlist_$filedate.log
  select * from
  (
  select m.inst_id,m.username,m.sql_id, to_char(sql_exec_start, 'yyyymmdd HH24:MI:SS') date_start, 
         substr(status,1,5) as status, sql_exec_id,px_servers_requested px_req,px_servers_allocated as px_real,
         round(m.elapsed_time/1000000) "Elapsed(s)", round(m.CPU_TIME/1000000) "Cpu(s)"
         , sql_text
  from gv\$sql_monitor m
  where m.process_name='ora'--m.PX_SERVER# is null
  --order by elapsed_time desc 
  order by sql_exec_start desc
  )
  where rownum<=$topn;
  $ECHO
  spool off
!
 echo "order by elapsed_time,top $topn only"
 exit 0
fi

#################################################################################
if [ "$1" = "monsave" -o "$1" = "savemon" ]; then

   if [ "$2" = "" ]; then
     echo "ora monitor sql_id [active]|text <sql_exec_id>"
     exit 0
   fi
   
    if [ "$3" = "" -o "$3" = "active" -o "$3" = "ACTIVE" ]; then
       type=ACTIVE
       ftype=html
    else 
       type=TEXT
       ftype=txt
    fi
    
    #if [ "$3" = "text" -o "$3" = "TEXT" ]; then
    #   type=TEXT
    #else 
    #   type=ACTIVE
    #fi
    
    if [ "$4" != "" ]; then
       execid="SQL_EXEC_ID=>$4,"
    else 
       execid=""
    fi


  FILTER='Session altered|Connected|rows selected|successfully|MONITOR_REPORT|---------------------'

  sqlplus -s /NOLOG  << ! | egrep -v "$FILTER"

  connect $DBUSER

  set echo off
  set linesize 10000 pages 6000
  set long 20000000
  set longchunksize 20000000
  set trimout on trims on term off head off
  
  spool $2_$type.$ftype
  
    select
    DBMS_SQLTUNE.REPORT_SQL_MONITOR(
            sql_id=>'$2',$execid
            report_level=>'ALL',
            type=>'$type') as report
    from dual;
    
  spool off
  
!
  exit 0
  echo "ora monsave sql_id text   or  ora monsave sql_id  (active is default)"
fi


##############################################################################################################



###################################################################################################
#
# Run a shell command. Useful when combined with repeat...
#
if [ "$1" = "sh" ]; then

  shift 1
  sh -fc "$*"
  echo "usage:ora repeat 5 10 sh 'ps -edf | grep DESC'"
  exit 0
fi

usage
echo "Command 'ora $1' not defined,please check the command again."
